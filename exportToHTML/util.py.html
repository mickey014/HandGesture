<html>
<head>
<title>util.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
util.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2018 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">import </span><span class="s1">itertools </span><span class="s2">as </span><span class="s1">it</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(Any</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Generic</span><span class="s2">, </span><span class="s1">Iterable</span><span class="s2">, </span><span class="s1">Iterator</span><span class="s2">, </span><span class="s1">List</span><span class="s2">,</span>
                    <span class="s1">Optional</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">, </span><span class="s1">Set</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">TypeVar</span><span class="s2">, </span><span class="s1">overload</span><span class="s2">,</span>
                    <span class="s1">TYPE_CHECKING</span><span class="s2">, </span><span class="s1">cast)</span>
<span class="s2">import </span><span class="s1">weakref</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">jax._src.lib </span><span class="s2">import </span><span class="s1">xla_client </span><span class="s2">as </span><span class="s1">xc</span>
<span class="s2">from </span><span class="s1">jax._src.lib </span><span class="s2">import </span><span class="s1">utils </span><span class="s2">as </span><span class="s1">jaxlib_utils</span>
<span class="s2">from </span><span class="s1">jax._src.config </span><span class="s2">import </span><span class="s1">config</span>

<span class="s1">logger = logging.getLogger(__name__)</span>

<span class="s1">Seq = Sequence</span>

<span class="s1">T = TypeVar(</span><span class="s3">&quot;T&quot;</span><span class="s1">)</span>
<span class="s1">T1 = TypeVar(</span><span class="s3">&quot;T1&quot;</span><span class="s1">)</span>
<span class="s1">T2 = TypeVar(</span><span class="s3">&quot;T2&quot;</span><span class="s1">)</span>
<span class="s1">T3 = TypeVar(</span><span class="s3">&quot;T3&quot;</span><span class="s1">)</span>


<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
  <span class="s0"># safe_zip cannot yet be fully annotated, so we use a strategy similar</span>
  <span class="s0"># to that used for builtins.zip in python/typeshed. This supports</span>
  <span class="s0"># return types matching input types for up to three arguments.</span>
  <span class="s1">@overload</span>
  <span class="s2">def </span><span class="s1">safe_zip(__arg1: Iterable[T1]) -&gt; List[Tuple[T1]]: ...</span>
  <span class="s1">@overload</span>
  <span class="s2">def </span><span class="s1">safe_zip(__arg1: Iterable[T1]</span><span class="s2">, </span><span class="s1">__arg2: Iterable[T2]) -&gt; List[Tuple[T1</span><span class="s2">, </span><span class="s1">T2]]: ...</span>
  <span class="s1">@overload</span>
  <span class="s2">def </span><span class="s1">safe_zip(__arg1: Iterable[T1]</span><span class="s2">, </span><span class="s1">__arg2: Iterable[T2]</span><span class="s2">, </span><span class="s1">__arg3: Iterable[T3]) -&gt; List[Tuple[T1</span><span class="s2">, </span><span class="s1">T2</span><span class="s2">, </span><span class="s1">T3]]: ...</span>
  <span class="s1">@overload</span>
  <span class="s2">def </span><span class="s1">safe_zip(__arg1: Iterable[Any]</span><span class="s2">, </span><span class="s1">__arg2: Iterable[Any]</span><span class="s2">, </span><span class="s1">__arg3: Iterable[Any]</span><span class="s2">, </span><span class="s1">__arg4: Iterable[Any]</span><span class="s2">, </span><span class="s1">*args) -&gt; List[Tuple[Any</span><span class="s2">, </span><span class="s1">...]]: ...</span>

  <span class="s2">def </span><span class="s1">safe_zip(*args):</span>
    <span class="s1">args = list(map(list</span><span class="s2">, </span><span class="s1">args))</span>
    <span class="s1">n = len(args[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args[</span><span class="s4">1</span><span class="s1">:]:</span>
      <span class="s2">assert </span><span class="s1">len(arg) == n</span><span class="s2">, </span><span class="s3">f'length mismatch: </span><span class="s2">{</span><span class="s1">list(map(len</span><span class="s2">, </span><span class="s1">args))</span><span class="s2">}</span><span class="s3">'</span>
    <span class="s2">return </span><span class="s1">list(zip(*args))</span>

<span class="s2">else</span><span class="s1">:</span>
  <span class="s0"># TODO(phawkins): remove the hasattr condition after jaxlib 0.4.9 is the</span>
  <span class="s0"># minimum</span>
  <span class="s2">if </span><span class="s1">hasattr(jaxlib_utils</span><span class="s2">, </span><span class="s3">'safe_zip'</span><span class="s1">):</span>
    <span class="s1">safe_zip = jaxlib_utils.safe_zip</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">def </span><span class="s1">safe_zip(*args):</span>
      <span class="s1">args = list(map(list</span><span class="s2">, </span><span class="s1">args))</span>
      <span class="s1">n = len(args[</span><span class="s4">0</span><span class="s1">])</span>
      <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args[</span><span class="s4">1</span><span class="s1">:]:</span>
        <span class="s2">assert </span><span class="s1">len(arg) == n</span><span class="s2">, </span><span class="s3">f'length mismatch: </span><span class="s2">{</span><span class="s1">list(map(len</span><span class="s2">, </span><span class="s1">args))</span><span class="s2">}</span><span class="s3">'</span>
      <span class="s2">return </span><span class="s1">list(zip(*args))</span>


<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
  <span class="s0"># safe_map cannot yet be fully annotated, so we use a strategy similar</span>
  <span class="s0"># to that used for builtins.map in python/typeshed. This supports</span>
  <span class="s0"># checking input types for the callable with up to three arguments.</span>
  <span class="s1">@overload</span>
  <span class="s2">def </span><span class="s1">safe_map(f: Callable[[T1]</span><span class="s2">, </span><span class="s1">T]</span><span class="s2">, </span><span class="s1">__arg1: Iterable[T1]) -&gt; List[T]: ...</span>

  <span class="s1">@overload</span>
  <span class="s2">def </span><span class="s1">safe_map(f: Callable[[T1</span><span class="s2">, </span><span class="s1">T2]</span><span class="s2">, </span><span class="s1">T]</span><span class="s2">, </span><span class="s1">__arg1: Iterable[T1]</span><span class="s2">, </span><span class="s1">__arg2: Iterable[T2]) -&gt; List[T]: ...</span>

  <span class="s1">@overload</span>
  <span class="s2">def </span><span class="s1">safe_map(f: Callable[[T1</span><span class="s2">, </span><span class="s1">T2</span><span class="s2">, </span><span class="s1">T3]</span><span class="s2">, </span><span class="s1">T]</span><span class="s2">, </span><span class="s1">__arg1: Iterable[T1]</span><span class="s2">, </span><span class="s1">__arg2: Iterable[T2]</span><span class="s2">, </span><span class="s1">__arg3: Iterable[T3]) -&gt; List[T]: ...</span>

  <span class="s1">@overload</span>
  <span class="s2">def </span><span class="s1">safe_map(f: Callable[...</span><span class="s2">, </span><span class="s1">T]</span><span class="s2">, </span><span class="s1">__arg1: Iterable[Any]</span><span class="s2">, </span><span class="s1">__arg2: Iterable[Any]</span><span class="s2">, </span><span class="s1">__arg3: Iterable[Any]</span><span class="s2">, </span><span class="s1">__arg4: Iterable[Any]</span><span class="s2">, </span><span class="s1">*args) -&gt; List[T]: ...</span>

  <span class="s2">def </span><span class="s1">safe_map(f</span><span class="s2">, </span><span class="s1">*args):</span>
    <span class="s1">args = list(map(list</span><span class="s2">, </span><span class="s1">args))</span>
    <span class="s1">n = len(args[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args[</span><span class="s4">1</span><span class="s1">:]:</span>
      <span class="s2">assert </span><span class="s1">len(arg) == n</span><span class="s2">, </span><span class="s3">f'length mismatch: </span><span class="s2">{</span><span class="s1">list(map(len</span><span class="s2">, </span><span class="s1">args))</span><span class="s2">}</span><span class="s3">'</span>
    <span class="s2">return </span><span class="s1">list(map(f</span><span class="s2">, </span><span class="s1">*args))</span>

<span class="s2">else</span><span class="s1">:</span>
  <span class="s0"># TODO(phawkins): remove the hasattr condition after jaxlib 0.4.9 is the</span>
  <span class="s0"># minimum</span>
  <span class="s2">if </span><span class="s1">hasattr(jaxlib_utils</span><span class="s2">, </span><span class="s3">'safe_map'</span><span class="s1">):</span>
    <span class="s1">safe_map = jaxlib_utils.safe_map</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">def </span><span class="s1">safe_map(f</span><span class="s2">, </span><span class="s1">*args):</span>
      <span class="s1">args = list(map(list</span><span class="s2">, </span><span class="s1">args))</span>
      <span class="s1">n = len(args[</span><span class="s4">0</span><span class="s1">])</span>
      <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args[</span><span class="s4">1</span><span class="s1">:]:</span>
        <span class="s2">assert </span><span class="s1">len(arg) == n</span><span class="s2">, </span><span class="s3">f'length mismatch: </span><span class="s2">{</span><span class="s1">list(map(len</span><span class="s2">, </span><span class="s1">args))</span><span class="s2">}</span><span class="s3">'</span>
      <span class="s2">return </span><span class="s1">list(map(f</span><span class="s2">, </span><span class="s1">*args))</span>

<span class="s2">def </span><span class="s1">unzip2(xys: Iterable[Tuple[T1</span><span class="s2">, </span><span class="s1">T2]]</span>
    <span class="s1">) -&gt; Tuple[Tuple[T1</span><span class="s2">, </span><span class="s1">...]</span><span class="s2">, </span><span class="s1">Tuple[T2</span><span class="s2">, </span><span class="s1">...]]:</span>
  <span class="s5">&quot;&quot;&quot;Unzip sequence of length-2 tuples into two tuples.&quot;&quot;&quot;</span>
  <span class="s0"># Note: we deliberately don't use zip(*xys) because it is lazily evaluated,</span>
  <span class="s0"># is too permissive about inputs, and does not guarantee a length-2 output.</span>
  <span class="s1">xs: List[T1] = []</span>
  <span class="s1">ys: List[T2] = []</span>
  <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">xys:</span>
    <span class="s1">xs.append(x)</span>
    <span class="s1">ys.append(y)</span>
  <span class="s2">return </span><span class="s1">tuple(xs)</span><span class="s2">, </span><span class="s1">tuple(ys)</span>

<span class="s2">def </span><span class="s1">unzip3(xyzs: Iterable[Tuple[T1</span><span class="s2">, </span><span class="s1">T2</span><span class="s2">, </span><span class="s1">T3]]</span>
    <span class="s1">) -&gt; Tuple[Tuple[T1</span><span class="s2">, </span><span class="s1">...]</span><span class="s2">, </span><span class="s1">Tuple[T2</span><span class="s2">, </span><span class="s1">...]</span><span class="s2">, </span><span class="s1">Tuple[T3</span><span class="s2">, </span><span class="s1">...]]:</span>
  <span class="s5">&quot;&quot;&quot;Unzip sequence of length-3 tuples into three tuples.&quot;&quot;&quot;</span>
  <span class="s0"># Note: we deliberately don't use zip(*xyzs) because it is lazily evaluated,</span>
  <span class="s0"># is too permissive about inputs, and does not guarantee a length-3 output.</span>
  <span class="s1">xs: List[T1] = []</span>
  <span class="s1">ys: List[T2] = []</span>
  <span class="s1">zs: List[T3] = []</span>
  <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z </span><span class="s2">in </span><span class="s1">xyzs:</span>
    <span class="s1">xs.append(x)</span>
    <span class="s1">ys.append(y)</span>
    <span class="s1">zs.append(z)</span>
  <span class="s2">return </span><span class="s1">tuple(xs)</span><span class="s2">, </span><span class="s1">tuple(ys)</span><span class="s2">, </span><span class="s1">tuple(zs)</span>

<span class="s2">def </span><span class="s1">subvals(lst</span><span class="s2">, </span><span class="s1">replace):</span>
  <span class="s1">lst = list(lst)</span>
  <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">replace:</span>
    <span class="s1">lst[i] = v</span>
  <span class="s2">return </span><span class="s1">tuple(lst)</span>

<span class="s2">def </span><span class="s1">split_list(args: Sequence[T]</span><span class="s2">, </span><span class="s1">ns: Sequence[int]) -&gt; List[List[T]]:</span>
  <span class="s1">args = list(args)</span>
  <span class="s1">lists = []</span>
  <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">ns:</span>
    <span class="s1">lists.append(args[:n])</span>
    <span class="s1">args = args[n:]</span>
  <span class="s1">lists.append(args)</span>
  <span class="s2">return </span><span class="s1">lists</span>

<span class="s2">def </span><span class="s1">partition_list(bs: Sequence[bool]</span><span class="s2">, </span><span class="s1">l: Sequence[T]) -&gt; Tuple[List[T]</span><span class="s2">, </span><span class="s1">List[T]]:</span>
  <span class="s2">assert </span><span class="s1">len(bs) == len(l)</span>
  <span class="s1">lists = []</span><span class="s2">, </span><span class="s1">[]  </span><span class="s0"># type: ignore</span>
  <span class="s2">for </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">zip(bs</span><span class="s2">, </span><span class="s1">l):</span>
    <span class="s1">lists[b].append(x)</span>
  <span class="s2">return </span><span class="s1">lists</span>

<span class="s2">def </span><span class="s1">merge_lists(bs: Sequence[bool]</span><span class="s2">, </span><span class="s1">l0: Sequence[T]</span><span class="s2">, </span><span class="s1">l1: Sequence[T]) -&gt; List[T]:</span>
  <span class="s2">assert </span><span class="s1">sum(bs) == len(l1) </span><span class="s2">and </span><span class="s1">len(bs) - sum(bs) == len(l0)</span>
  <span class="s1">i0</span><span class="s2">, </span><span class="s1">i1 = iter(l0)</span><span class="s2">, </span><span class="s1">iter(l1)</span>
  <span class="s1">out = [next(i1) </span><span class="s2">if </span><span class="s1">b </span><span class="s2">else </span><span class="s1">next(i0) </span><span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">bs]</span>
  <span class="s1">sentinel = object()</span>
  <span class="s2">assert </span><span class="s1">next(i0</span><span class="s2">, </span><span class="s1">sentinel) </span><span class="s2">is </span><span class="s1">next(i1</span><span class="s2">, </span><span class="s1">sentinel) </span><span class="s2">is </span><span class="s1">sentinel</span>
  <span class="s2">return </span><span class="s1">out</span>

<span class="s2">def </span><span class="s1">split_dict(dct</span><span class="s2">, </span><span class="s1">names):</span>
  <span class="s1">dct = dict(dct)</span>
  <span class="s1">lst = [dct.pop(name) </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names]</span>
  <span class="s2">assert not </span><span class="s1">dct</span>
  <span class="s2">return </span><span class="s1">lst</span>

<span class="s2">def </span><span class="s1">concatenate(xs: Iterable[Sequence[T]]) -&gt; List[T]:</span>
  <span class="s5">&quot;&quot;&quot;Concatenates/flattens a list of lists.&quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">list(it.chain.from_iterable(xs))</span>

<span class="s1">flatten = concatenate</span>

<span class="s1">_unflatten_done = object()</span>

<span class="s2">def </span><span class="s1">unflatten(xs: Iterable[T]</span><span class="s2">, </span><span class="s1">ns: Sequence[int]) -&gt; List[List[T]]:</span>
  <span class="s5">&quot;&quot;&quot;Splits `xs` into subsequences of lengths `ns`. 
 
  Unlike `split_list`, the `sum(ns)` must be equal to `len(xs)`.&quot;&quot;&quot;</span>
  <span class="s1">xs_iter = iter(xs)</span>
  <span class="s1">unflattened = [[next(xs_iter) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(n)] </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">ns]</span>
  <span class="s2">assert </span><span class="s1">next(xs_iter</span><span class="s2">, </span><span class="s1">_unflatten_done) </span><span class="s2">is </span><span class="s1">_unflatten_done</span>
  <span class="s2">return </span><span class="s1">unflattened</span>


<span class="s2">def </span><span class="s1">curry(f):</span>
  <span class="s5">&quot;&quot;&quot;Curries arguments of f, returning a function on any remaining arguments. 
 
  For example: 
  &gt;&gt;&gt; f = lambda x, y, z, w: x * y + z * w 
  &gt;&gt;&gt; f(2,3,4,5) 
  26 
  &gt;&gt;&gt; curry(f)(2)(3, 4, 5) 
  26 
  &gt;&gt;&gt; curry(f)(2, 3)(4, 5) 
  26 
  &gt;&gt;&gt; curry(f)(2, 3, 4, 5)() 
  26 
  &quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">partial(partial</span><span class="s2">, </span><span class="s1">f)</span>

<span class="s2">def </span><span class="s1">toposort(end_nodes):</span>
  <span class="s2">if not </span><span class="s1">end_nodes: </span><span class="s2">return </span><span class="s1">[]</span>
  <span class="s1">end_nodes = _remove_duplicates(end_nodes)</span>

  <span class="s1">child_counts = {}</span>
  <span class="s1">stack = list(end_nodes)</span>
  <span class="s2">while </span><span class="s1">stack:</span>
    <span class="s1">node = stack.pop()</span>
    <span class="s2">if </span><span class="s1">id(node) </span><span class="s2">in </span><span class="s1">child_counts:</span>
      <span class="s1">child_counts[id(node)] += </span><span class="s4">1</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">child_counts[id(node)] = </span><span class="s4">1</span>
      <span class="s1">stack.extend(node.parents)</span>
  <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">end_nodes:</span>
    <span class="s1">child_counts[id(node)] -= </span><span class="s4">1</span>

  <span class="s1">sorted_nodes = []</span>
  <span class="s1">childless_nodes = [node </span><span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">end_nodes </span><span class="s2">if </span><span class="s1">child_counts[id(node)] == </span><span class="s4">0</span><span class="s1">]</span>
  <span class="s2">assert </span><span class="s1">childless_nodes</span>
  <span class="s2">while </span><span class="s1">childless_nodes:</span>
    <span class="s1">node = childless_nodes.pop()</span>
    <span class="s1">sorted_nodes.append(node)</span>
    <span class="s2">for </span><span class="s1">parent </span><span class="s2">in </span><span class="s1">node.parents:</span>
      <span class="s2">if </span><span class="s1">child_counts[id(parent)] == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">childless_nodes.append(parent)</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">child_counts[id(parent)] -= </span><span class="s4">1</span>
  <span class="s1">sorted_nodes = sorted_nodes[::-</span><span class="s4">1</span><span class="s1">]</span>

  <span class="s1">check_toposort(sorted_nodes)</span>
  <span class="s2">return </span><span class="s1">sorted_nodes</span>

<span class="s2">def </span><span class="s1">check_toposort(nodes):</span>
  <span class="s1">visited = set()</span>
  <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">nodes:</span>
    <span class="s2">assert </span><span class="s1">all(id(parent) </span><span class="s2">in </span><span class="s1">visited </span><span class="s2">for </span><span class="s1">parent </span><span class="s2">in </span><span class="s1">node.parents)</span>
    <span class="s1">visited.add(id(node))</span>

<span class="s2">def </span><span class="s1">_remove_duplicates(node_list):</span>
  <span class="s1">seen = set()</span>
  <span class="s1">out = []</span>
  <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">node_list:</span>
    <span class="s2">if </span><span class="s1">id(n) </span><span class="s2">not in </span><span class="s1">seen:</span>
      <span class="s1">seen.add(id(n))</span>
      <span class="s1">out.append(n)</span>
  <span class="s2">return </span><span class="s1">out</span>

<span class="s2">def </span><span class="s1">split_merge(predicate</span><span class="s2">, </span><span class="s1">xs):</span>
  <span class="s1">sides = list(map(predicate</span><span class="s2">, </span><span class="s1">xs))</span>
  <span class="s1">lhs = [x </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">zip(xs</span><span class="s2">, </span><span class="s1">sides) </span><span class="s2">if </span><span class="s1">s]</span>
  <span class="s1">rhs = [x </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">zip(xs</span><span class="s2">, </span><span class="s1">sides) </span><span class="s2">if not </span><span class="s1">s]</span>
  <span class="s2">def </span><span class="s1">merge(new_lhs</span><span class="s2">, </span><span class="s1">new_rhs):</span>
    <span class="s1">out = []</span>
    <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">sides:</span>
      <span class="s2">if </span><span class="s1">s:</span>
        <span class="s1">out.append(new_lhs[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">new_lhs = new_lhs[</span><span class="s4">1</span><span class="s1">:]</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">out.append(new_rhs[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">new_rhs = new_rhs[</span><span class="s4">1</span><span class="s1">:]</span>
    <span class="s2">assert not </span><span class="s1">new_rhs</span>
    <span class="s2">assert not </span><span class="s1">new_lhs</span>
    <span class="s2">return </span><span class="s1">out</span>

  <span class="s2">return </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs</span><span class="s2">, </span><span class="s1">merge</span>

<span class="s2">def </span><span class="s1">cache(max_size=</span><span class="s4">4096</span><span class="s1">):</span>
  <span class="s2">def </span><span class="s1">wrap(f):</span>
    <span class="s1">@functools.lru_cache(max_size)</span>
    <span class="s2">def </span><span class="s1">cached(_</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
      <span class="s2">return </span><span class="s1">f(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@functools.wraps(f)</span>
    <span class="s2">def </span><span class="s1">wrapper(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
      <span class="s2">if </span><span class="s1">config.jax_check_tracer_leaks:</span>
        <span class="s2">return </span><span class="s1">f(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">cached(config._trace_context()</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">wrapper.cache_clear = cached.cache_clear</span>
    <span class="s1">wrapper.cache_info = cached.cache_info</span>
    <span class="s2">return </span><span class="s1">wrapper</span>
  <span class="s2">return </span><span class="s1">wrap</span>

<span class="s1">memoize = cache(max_size=</span><span class="s2">None</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">weakref_lru_cache(call: Callable</span><span class="s2">, </span><span class="s1">maxsize=</span><span class="s4">2048</span><span class="s1">):</span>
  <span class="s5">&quot;&quot;&quot; 
  Least recently used cache decorator with weakref support. 
 
  The cache will take a weakref to the first argument of the wrapped function 
  and strong refs to all subsequent operations. In all other respects it should 
  behave similar to `functools.lru_cache`. 
  &quot;&quot;&quot;</span>
  <span class="s2">global </span><span class="s1">_weakref_lru_caches</span>
  <span class="s1">cached_call = xc.weakref_lru_cache(config._trace_context</span><span class="s2">, </span><span class="s1">call</span><span class="s2">, </span><span class="s1">maxsize)</span>
  <span class="s1">_weakref_lru_caches.add(cached_call)</span>
  <span class="s2">return </span><span class="s1">cached_call</span>

<span class="s1">_weakref_lru_caches = weakref.WeakSet()  </span><span class="s0"># type: ignore</span>

<span class="s2">def </span><span class="s1">clear_all_weakref_lru_caches():</span>
  <span class="s2">for </span><span class="s1">cached_call </span><span class="s2">in </span><span class="s1">_weakref_lru_caches:</span>
    <span class="s1">cached_call.cache_clear()</span>

<span class="s2">class </span><span class="s1">Unhashable:</span>
  <span class="s1">__slots__ = [</span><span class="s3">&quot;val&quot;</span><span class="s1">]</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">val):</span>
    <span class="s1">self.val = val</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return </span><span class="s1">self.val == other.val</span>

<span class="s2">class </span><span class="s1">Hashable:</span>
  <span class="s1">__slots__ = [</span><span class="s3">&quot;val&quot;</span><span class="s1">]</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">val):</span>
    <span class="s1">self.val = val</span>

  <span class="s2">def </span><span class="s1">__hash__(self):</span>
    <span class="s2">return </span><span class="s1">hash(self.val)</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return </span><span class="s1">self.val == other.val</span>

<span class="s2">class </span><span class="s1">WrapKwArgs:</span>
  <span class="s1">__slots__ = [</span><span class="s3">&quot;val&quot;</span><span class="s1">]</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">val):</span>
    <span class="s1">self.val = val</span>

  <span class="s2">def </span><span class="s1">__hash__(self):</span>
    <span class="s2">return </span><span class="s1">hash(tuple((k</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">sorted(self.val.items())))</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return </span><span class="s1">self.val == other.val</span>

<span class="s2">def </span><span class="s1">wrap_name(name</span><span class="s2">, </span><span class="s1">transform_name):</span>
  <span class="s2">return </span><span class="s1">transform_name + </span><span class="s3">'(' </span><span class="s1">+ name + </span><span class="s3">')'</span>

<span class="s2">def </span><span class="s1">canonicalize_axis(axis</span><span class="s2">, </span><span class="s1">num_dims) -&gt; int:</span>
  <span class="s5">&quot;&quot;&quot;Canonicalize an axis in [-num_dims, num_dims) to [0, num_dims).&quot;&quot;&quot;</span>
  <span class="s1">axis = operator.index(axis)</span>
  <span class="s2">if not </span><span class="s1">-num_dims &lt;= axis &lt; num_dims:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;axis </span><span class="s2">{</span><span class="s1">axis</span><span class="s2">} </span><span class="s3">is out of bounds for array of dimension </span><span class="s2">{</span><span class="s1">num_dims</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s1">axis &lt; </span><span class="s4">0</span><span class="s1">:</span>
    <span class="s1">axis = axis + num_dims</span>
  <span class="s2">return </span><span class="s1">axis</span>

<span class="s2">def </span><span class="s1">moveaxis(x</span><span class="s2">, </span><span class="s1">src</span><span class="s2">, </span><span class="s1">dst):</span>
  <span class="s2">if </span><span class="s1">src == dst:</span>
    <span class="s2">return </span><span class="s1">x</span>
  <span class="s2">if </span><span class="s1">isinstance(src</span><span class="s2">, </span><span class="s1">int):</span>
    <span class="s1">src = (src</span><span class="s2">,</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s1">isinstance(dst</span><span class="s2">, </span><span class="s1">int):</span>
    <span class="s1">dst = (dst</span><span class="s2">,</span><span class="s1">)</span>
  <span class="s1">src = [canonicalize_axis(a</span><span class="s2">, </span><span class="s1">x.ndim) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">src]</span>
  <span class="s1">dst = [canonicalize_axis(a</span><span class="s2">, </span><span class="s1">x.ndim) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">dst]</span>
  <span class="s1">perm = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(np.ndim(x)) </span><span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">src]</span>
  <span class="s2">for </span><span class="s1">d</span><span class="s2">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">sorted(zip(dst</span><span class="s2">, </span><span class="s1">src)):</span>
    <span class="s1">perm.insert(d</span><span class="s2">, </span><span class="s1">s)</span>
  <span class="s2">return </span><span class="s1">x.transpose(perm)</span>

<span class="s2">def </span><span class="s1">ceil_of_ratio(x</span><span class="s2">, </span><span class="s1">y):</span>
  <span class="s2">return </span><span class="s1">-(-x // y)</span>


<span class="s2">def </span><span class="s1">wraps(</span>
    <span class="s1">wrapped: Callable</span><span class="s2">,</span>
    <span class="s1">namestr: Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">docstr: Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">**kwargs</span><span class="s2">,</span>
<span class="s1">) -&gt; Callable[[T]</span><span class="s2">, </span><span class="s1">T]:</span>
  <span class="s5">&quot;&quot;&quot; 
  Like functools.wraps, but with finer-grained control over the name and docstring 
  of the resulting function. 
  &quot;&quot;&quot;</span>
  <span class="s2">def </span><span class="s1">wrapper(fun: T) -&gt; T:</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s1">name = getattr(wrapped</span><span class="s2">, </span><span class="s3">&quot;__name__&quot;</span><span class="s2">, </span><span class="s3">&quot;&lt;unnamed function&gt;&quot;</span><span class="s1">)</span>
      <span class="s1">doc = getattr(wrapped</span><span class="s2">, </span><span class="s3">&quot;__doc__&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s3">&quot;&quot;</span>
      <span class="s1">fun.__dict__.update(getattr(wrapped</span><span class="s2">, </span><span class="s3">&quot;__dict__&quot;</span><span class="s2">, </span><span class="s1">{}))</span>
      <span class="s1">fun.__annotations__ = getattr(wrapped</span><span class="s2">, </span><span class="s3">&quot;__annotations__&quot;</span><span class="s2">, </span><span class="s1">{})</span>
      <span class="s1">fun.__name__ = name </span><span class="s2">if </span><span class="s1">namestr </span><span class="s2">is None else </span><span class="s1">namestr.format(fun=name)</span>
      <span class="s1">fun.__module__ = getattr(wrapped</span><span class="s2">, </span><span class="s3">&quot;__module__&quot;</span><span class="s2">, </span><span class="s3">&quot;&lt;unknown module&gt;&quot;</span><span class="s1">)</span>
      <span class="s1">fun.__doc__ = (doc </span><span class="s2">if </span><span class="s1">docstr </span><span class="s2">is None</span>
                     <span class="s2">else </span><span class="s1">docstr.format(fun=name</span><span class="s2">, </span><span class="s1">doc=doc</span><span class="s2">, </span><span class="s1">**kwargs))</span>
      <span class="s1">fun.__qualname__ = getattr(wrapped</span><span class="s2">, </span><span class="s3">&quot;__qualname__&quot;</span><span class="s2">, </span><span class="s1">fun.__name__)</span>
      <span class="s1">fun.__wrapped__ = wrapped</span>
    <span class="s2">finally</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">fun</span>
  <span class="s2">return </span><span class="s1">wrapper</span>


<span class="s0"># NOTE: Ideally we would annotate both the argument and return type as NoReturn</span>
<span class="s0">#       but it seems like pytype doesn't support that...</span>
<span class="s2">def </span><span class="s1">assert_unreachable(x):</span>
  <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s3">f&quot;Unhandled case: </span><span class="s2">{</span><span class="s1">type(x).__name__</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">tuple_insert(t</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">val):</span>
  <span class="s2">assert </span><span class="s4">0 </span><span class="s1">&lt;= idx &lt;= len(t)</span><span class="s2">, </span><span class="s1">(idx</span><span class="s2">, </span><span class="s1">len(t))</span>
  <span class="s2">return </span><span class="s1">t[:idx] + (val</span><span class="s2">,</span><span class="s1">) + t[idx:]</span>

<span class="s2">def </span><span class="s1">tuple_delete(t</span><span class="s2">, </span><span class="s1">idx):</span>
  <span class="s2">assert </span><span class="s4">0 </span><span class="s1">&lt;= idx &lt; len(t)</span><span class="s2">, </span><span class="s1">(idx</span><span class="s2">, </span><span class="s1">len(t))</span>
  <span class="s2">return </span><span class="s1">t[:idx] + t[idx + </span><span class="s4">1</span><span class="s1">:]</span>

<span class="s2">class </span><span class="s1">HashableFunction:</span>
  <span class="s5">&quot;&quot;&quot;Decouples function equality and hash from its identity. 
 
  Local lambdas and function defs are reallocated on each function call, making 
  the functions created on different calls compare as unequal. This breaks our 
  caching logic, which should really only care about comparing the semantics and 
  not actual identity. 
 
  This class makes it possible to compare different functions based on their 
  semantics. The parts that are taken into account are: the bytecode of the 
  wrapped function (which is cached by the CPython interpreter and is stable 
  across the invocations of the surrounding function), and `closure` which 
  should contain all values in scope that affect the function semantics. In 
  particular `closure` should contain all elements of the function closure, or 
  it should be possible to derive the relevant elements of the true function 
  closure based solely on the contents of the `closure` argument (e.g. in case 
  some closed-over values are not hashable, but are entirely determined by 
  hashable locals). 
  &quot;&quot;&quot;</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">closure):</span>
    <span class="s1">self.f = f</span>
    <span class="s1">self.closure = closure</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return </span><span class="s1">(type(other) </span><span class="s2">is </span><span class="s1">HashableFunction </span><span class="s2">and</span>
            <span class="s1">self.f.__code__ == other.f.__code__ </span><span class="s2">and</span>
            <span class="s1">self.closure == other.closure)</span>

  <span class="s2">def </span><span class="s1">__hash__(self):</span>
    <span class="s2">return </span><span class="s1">hash((self.f.__code__</span><span class="s2">, </span><span class="s1">self.closure))</span>

  <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s2">return </span><span class="s1">self.f(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

  <span class="s2">def </span><span class="s1">__repr__(self):</span>
    <span class="s2">return </span><span class="s3">f'&lt;hashable </span><span class="s2">{</span><span class="s1">self.f.__name__</span><span class="s2">} </span><span class="s3">with closure=</span><span class="s2">{</span><span class="s1">self.closure</span><span class="s2">}</span><span class="s3">&gt;'</span>

<span class="s2">def </span><span class="s1">as_hashable_function(closure):</span>
  <span class="s2">return lambda </span><span class="s1">f: HashableFunction(f</span><span class="s2">, </span><span class="s1">closure)</span>

<span class="s2">class </span><span class="s1">HashablePartial:</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s1">self.f = f</span>
    <span class="s1">self.args = args</span>
    <span class="s1">self.kwargs = kwargs</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return </span><span class="s1">(type(other) </span><span class="s2">is </span><span class="s1">HashablePartial </span><span class="s2">and</span>
            <span class="s1">self.f.__code__ == other.f.__code__ </span><span class="s2">and</span>
            <span class="s1">self.args == other.args </span><span class="s2">and </span><span class="s1">self.kwargs == other.kwargs)</span>

  <span class="s2">def </span><span class="s1">__hash__(self):</span>
    <span class="s2">return </span><span class="s1">hash((self.f.__code__</span><span class="s2">, </span><span class="s1">self.args</span><span class="s2">, </span><span class="s1">tuple(self.kwargs.items())))</span>

  <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s2">return </span><span class="s1">self.f(*self.args</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**self.kwargs</span><span class="s2">, </span><span class="s1">**kwargs)</span>

<span class="s2">def </span><span class="s1">maybe_named_axis(axis</span><span class="s2">, </span><span class="s1">if_pos</span><span class="s2">, </span><span class="s1">if_named):</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s1">pos = operator.index(axis)</span>
    <span class="s1">named = </span><span class="s2">False</span>
  <span class="s2">except </span><span class="s1">TypeError:</span>
    <span class="s1">named = </span><span class="s2">True</span>
  <span class="s2">return </span><span class="s1">if_named(axis) </span><span class="s2">if </span><span class="s1">named </span><span class="s2">else </span><span class="s1">if_pos(pos)</span>

<span class="s2">def </span><span class="s1">distributed_debug_log(*pairs):</span>
  <span class="s5">&quot;&quot;&quot;Format and log `pairs` if config.jax_distributed_debug is enabled. 
 
  Args: 
    pairs: A sequence of label/value pairs to log. The first pair is treated as 
    a heading for subsequent pairs. 
  &quot;&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">config.jax_distributed_debug:</span>
    <span class="s1">lines = [</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">DISTRIBUTED_DEBUG_BEGIN&quot;</span><span class="s1">]</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s1">lines.append(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">pairs[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span><span class="s2">}</span><span class="s3">: </span><span class="s2">{</span><span class="s1">pairs[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
      <span class="s2">for </span><span class="s1">label</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">pairs[</span><span class="s4">1</span><span class="s1">:]:</span>
        <span class="s1">lines.append(</span><span class="s3">f&quot;  </span><span class="s2">{</span><span class="s1">label</span><span class="s2">}</span><span class="s3">: </span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
      <span class="s1">lines.append(</span><span class="s3">&quot;DISTRIBUTED_DEBUG logging failed!&quot;</span><span class="s1">)</span>
      <span class="s1">lines.append(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">e</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">lines.append(</span><span class="s3">&quot;DISTRIBUTED_DEBUG_END&quot;</span><span class="s1">)</span>
    <span class="s1">logger.warning(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(lines))</span>


<span class="s2">class </span><span class="s1">OrderedSet(Generic[T]):</span>
  <span class="s1">elts_set: Set[T]</span>
  <span class="s1">elts_list: List[T]</span>

  <span class="s2">def </span><span class="s1">__init__(self):</span>
    <span class="s1">self.elts_set = set()</span>
    <span class="s1">self.elts_list = []</span>

  <span class="s2">def </span><span class="s1">add(self</span><span class="s2">, </span><span class="s1">elt: T) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">elt </span><span class="s2">not in </span><span class="s1">self.elts_set:</span>
      <span class="s1">self.elts_set.add(elt)</span>
      <span class="s1">self.elts_list.append(elt)</span>

  <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">elts: Seq[T]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">elts:</span>
      <span class="s1">self.add(e)</span>

  <span class="s2">def </span><span class="s1">__iter__(self) -&gt; Iterator[T]:</span>
    <span class="s2">return </span><span class="s1">iter(self.elts_list)</span>

  <span class="s2">def </span><span class="s1">__len__(self) -&gt; int:</span>
    <span class="s2">return </span><span class="s1">len(self.elts_list)</span>

  <span class="s2">def </span><span class="s1">__contains__(self</span><span class="s2">, </span><span class="s1">elt: T) -&gt; bool:</span>
    <span class="s2">return </span><span class="s1">elt </span><span class="s2">in </span><span class="s1">self.elts_set</span>


<span class="s2">class </span><span class="s1">HashableWrapper:</span>
  <span class="s1">x: Any</span>
  <span class="s1">hash: Optional[int]</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">x):</span>
    <span class="s1">self.x = x</span>
    <span class="s2">try</span><span class="s1">: self.hash = hash(x)</span>
    <span class="s2">except</span><span class="s1">: self.hash = </span><span class="s2">None</span>
  <span class="s2">def </span><span class="s1">__hash__(self):</span>
    <span class="s2">return </span><span class="s1">self.hash </span><span class="s2">if </span><span class="s1">self.hash </span><span class="s2">is not None else </span><span class="s1">id(self.x)</span>
  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">HashableWrapper):</span>
      <span class="s2">return False</span>
    <span class="s2">return </span><span class="s1">self.x == other.x </span><span class="s2">if </span><span class="s1">self.hash </span><span class="s2">is not None else </span><span class="s1">self.x </span><span class="s2">is </span><span class="s1">other.x</span>


<span class="s2">def </span><span class="s1">_original_func(f):</span>
  <span class="s2">if </span><span class="s1">isinstance(f</span><span class="s2">, </span><span class="s1">property):</span>
    <span class="s2">return </span><span class="s1">cast(property</span><span class="s2">, </span><span class="s1">f).fget</span>
  <span class="s2">elif </span><span class="s1">isinstance(f</span><span class="s2">, </span><span class="s1">functools.cached_property):</span>
    <span class="s2">return </span><span class="s1">f.func</span>
  <span class="s2">return </span><span class="s1">f</span>


<span class="s2">def </span><span class="s1">set_module(module):</span>
  <span class="s2">def </span><span class="s1">wrapper(func):</span>
    <span class="s2">if </span><span class="s1">module </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s1">func.__module__ = module</span>
    <span class="s2">return </span><span class="s1">func</span>
  <span class="s2">return </span><span class="s1">wrapper</span>


<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
  <span class="s2">def </span><span class="s1">use_cpp_class(cpp_cls: Any) -&gt; Callable[[T]</span><span class="s2">, </span><span class="s1">T]:</span>
    <span class="s2">def </span><span class="s1">wrapper(cls: T) -&gt; T:</span>
      <span class="s2">return </span><span class="s1">cls</span>
    <span class="s2">return </span><span class="s1">wrapper</span>

  <span class="s2">def </span><span class="s1">use_cpp_method(is_enabled: bool = </span><span class="s2">True</span><span class="s1">) -&gt; Callable[[T]</span><span class="s2">, </span><span class="s1">T]:</span>
    <span class="s2">def </span><span class="s1">wrapper(cls: T) -&gt; T:</span>
      <span class="s2">return </span><span class="s1">cls</span>
    <span class="s2">return </span><span class="s1">wrapper</span>

<span class="s2">else</span><span class="s1">:</span>
  <span class="s2">def </span><span class="s1">use_cpp_class(cpp_cls):</span>
    <span class="s5">&quot;&quot;&quot;A helper decorator to replace a python class with its C++ version&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">wrapper(cls):</span>
      <span class="s2">if </span><span class="s1">cpp_cls </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">cls</span>

      <span class="s1">exclude_methods = {</span><span class="s3">'__module__'</span><span class="s2">, </span><span class="s3">'__dict__'</span><span class="s2">, </span><span class="s3">'__doc__'</span><span class="s1">}</span>

      <span class="s1">originals = {}</span>
      <span class="s2">for </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">cls.__dict__.items():</span>
        <span class="s2">if </span><span class="s1">attr_name </span><span class="s2">not in </span><span class="s1">exclude_methods:</span>
          <span class="s2">if </span><span class="s1">hasattr(_original_func(attr)</span><span class="s2">, </span><span class="s3">&quot;_use_cpp&quot;</span><span class="s1">):</span>
            <span class="s1">originals[attr_name] = attr</span>
          <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">setattr(cpp_cls</span><span class="s2">, </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">attr)</span>

      <span class="s1">cpp_cls.__doc__ = cls.__doc__</span>
      <span class="s0"># TODO(pschuh): Remove once fastpath is gone.</span>
      <span class="s1">cpp_cls._original_py_fns = originals</span>
      <span class="s2">return </span><span class="s1">cpp_cls</span>

    <span class="s2">return </span><span class="s1">wrapper</span>

  <span class="s2">def </span><span class="s1">use_cpp_method(is_enabled=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;A helper decorator to exclude methods from the set that are forwarded to C++ class&quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">decorator(f):</span>
      <span class="s2">if </span><span class="s1">is_enabled:</span>
        <span class="s1">original_func = _original_func(f)</span>
        <span class="s1">original_func._use_cpp = </span><span class="s2">True</span>
      <span class="s2">return </span><span class="s1">f</span>

    <span class="s2">if not </span><span class="s1">isinstance(is_enabled</span><span class="s2">, </span><span class="s1">bool):</span>
      <span class="s2">raise </span><span class="s1">TypeError(</span>
          <span class="s3">&quot;Decorator got wrong type: @use_cpp_method(is_enabled: bool=True)&quot;</span>
      <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">decorator</span>
</pre>
</body>
</html>