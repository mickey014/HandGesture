<html>
<head>
<title>maps.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
maps.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2020 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">itertools </span><span class="s2">as </span><span class="s1">it</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">OrderedDict</span><span class="s2">, </span><span class="s1">abc</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(Callable</span><span class="s2">, </span><span class="s1">Iterable</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">Dict</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Set</span><span class="s2">,</span>
                    <span class="s1">NamedTuple</span><span class="s2">, </span><span class="s1">Union</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">, </span><span class="s1">Mapping)</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">wraps</span><span class="s2">, </span><span class="s1">partial</span><span class="s2">, </span><span class="s1">partialmethod</span><span class="s2">, </span><span class="s1">lru_cache</span>
<span class="s2">import </span><span class="s1">math</span>

<span class="s2">from </span><span class="s1">jax </span><span class="s2">import </span><span class="s1">lax</span>
<span class="s2">from </span><span class="s1">jax </span><span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">jnp</span>

<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">core</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">dispatch</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">effects</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">mesh </span><span class="s2">as </span><span class="s1">mesh_lib</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">linear_util </span><span class="s2">as </span><span class="s1">lu</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">op_shardings</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">sharding_impls</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">source_info_util</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">stages</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">traceback_util</span>
<span class="s2">from </span><span class="s1">jax._src.api_util </span><span class="s2">import </span><span class="s1">(flatten_fun_nokwargs</span><span class="s2">, </span><span class="s1">flatten_axes</span><span class="s2">,</span>
                               <span class="s1">_ensure_index_tuple</span><span class="s2">, </span><span class="s1">donation_vector</span><span class="s2">,</span>
                               <span class="s1">shaped_abstractify</span><span class="s2">, </span><span class="s1">check_callable)</span>
<span class="s2">from </span><span class="s1">jax._src.array </span><span class="s2">import </span><span class="s1">ArrayImpl</span>
<span class="s2">from </span><span class="s1">jax._src.config </span><span class="s2">import </span><span class="s1">config</span>
<span class="s2">from </span><span class="s1">jax._src.errors </span><span class="s2">import </span><span class="s1">JAXTypeError</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">ad</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">batching</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">mlir</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">partial_eval </span><span class="s2">as </span><span class="s1">pe</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters.partial_eval </span><span class="s2">import </span><span class="s1">(</span>
  <span class="s1">trace_to_subjaxpr_dynamic</span><span class="s2">, </span><span class="s1">DynamicJaxprTracer</span><span class="s2">,</span>
  <span class="s1">convert_constvars_jaxpr</span><span class="s2">, </span><span class="s1">new_jaxpr_eqn)</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">pxla</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">xla</span>
<span class="s2">from </span><span class="s1">jax._src.pjit </span><span class="s2">import </span><span class="s1">(sharding_constraint_p</span><span class="s2">, </span><span class="s1">get_unconstrained_dims</span><span class="s2">,</span>
                           <span class="s1">GSPMDSharding)</span>
<span class="s2">from </span><span class="s1">jax._src.sharding_impls </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ArrayMapping</span><span class="s2">, </span><span class="s1">NamedSharding</span><span class="s2">, </span><span class="s1">ParsedPartitionSpec</span><span class="s2">,</span>
    <span class="s1">array_mapping_to_axis_resources)</span>
<span class="s2">from </span><span class="s1">jax._src.tree_util </span><span class="s2">import </span><span class="s1">(tree_flatten</span><span class="s2">, </span><span class="s1">tree_unflatten</span><span class="s2">, </span><span class="s1">all_leaves</span><span class="s2">,</span>
                                <span class="s1">tree_map</span><span class="s2">, </span><span class="s1">treedef_tuple)</span>
<span class="s2">from </span><span class="s1">jax._src.util </span><span class="s2">import </span><span class="s1">(safe_map</span><span class="s2">, </span><span class="s1">safe_zip</span><span class="s2">, </span><span class="s1">HashableFunction</span><span class="s2">, </span><span class="s1">unzip2</span><span class="s2">, </span><span class="s1">unzip3</span><span class="s2">,</span>
                           <span class="s1">as_hashable_function</span><span class="s2">, </span><span class="s1">distributed_debug_log</span><span class="s2">,</span>
                           <span class="s1">tuple_insert</span><span class="s2">, </span><span class="s1">moveaxis</span><span class="s2">, </span><span class="s1">split_list</span><span class="s2">, </span><span class="s1">wrap_name</span><span class="s2">,</span>
                           <span class="s1">merge_lists</span><span class="s2">, </span><span class="s1">partition_list)</span>

<span class="s1">source_info_util.register_exclusion(__file__)</span>
<span class="s1">traceback_util.register_exclusion(__file__)</span>

<span class="s1">map</span><span class="s2">, </span><span class="s1">unsafe_map = safe_map</span><span class="s2">, </span><span class="s1">map</span>
<span class="s1">zip = safe_zip</span>


<span class="s2">class </span><span class="s1">FrozenDict(abc.Mapping):</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s1">self.contents = dict(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

  <span class="s2">def </span><span class="s1">__iter__(self):</span>
    <span class="s2">return </span><span class="s1">iter(self.contents)</span>

  <span class="s2">def </span><span class="s1">__len__(self):</span>
    <span class="s2">return </span><span class="s1">len(self.contents)</span>

  <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">name):</span>
    <span class="s2">return </span><span class="s1">self.contents[name]</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">FrozenDict) </span><span class="s2">and </span><span class="s1">self.contents == other.contents</span>

  <span class="s2">def </span><span class="s1">__hash__(self):</span>
    <span class="s2">return </span><span class="s1">hash(tuple(self.contents.items()))</span>

  <span class="s2">def </span><span class="s1">__repr__(self):</span>
    <span class="s2">return </span><span class="s3">f&quot;FrozenDict(</span><span class="s2">{</span><span class="s1">self.contents</span><span class="s2">}</span><span class="s3">)&quot;</span>

<span class="s0"># Multi-dimensional generalized map</span>

<span class="s1">AxisName = core.AxisName</span>
<span class="s1">ResourceAxisName = mesh_lib.ResourceAxisName  </span><span class="s0"># Different name just for documentation purposes</span>
<span class="s1">Mesh = mesh_lib.Mesh</span>
<span class="s1">MeshAxisName = mesh_lib.MeshAxisName</span>
<span class="s1">ResourceEnv = mesh_lib.ResourceEnv</span>
<span class="s1">EMPTY_ENV = mesh_lib.EMPTY_ENV</span>
<span class="s1">thread_resources = mesh_lib.thread_resources</span>


<span class="s2">class </span><span class="s1">SerialLoop:</span>
  <span class="s4">&quot;&quot;&quot;Create an anonymous serial loop resource for use in a single xmap axis. 
 
  A use of :py:class:`SerialLoop` in :py:func:`xmap`'s ``axis_resources`` 
  extends the resource environment with a new serial loop with a unique 
  unspecified name, that will only be used to partition the axis that 
  used a given instance. 
 
  This is unlike :py:func:`serial_loop`, which makes it possible to iterate 
  jointly over chunks of multiple axes (with the usual requirement that they 
  do not coincide in a named shape of any value in the program). 
 
  Example:: 
 
      # Processes `x` in a vectorized way, but in 20 micro-batches. 
      xmap(f, in_axes=['i'], out_axes=[i], axis_resources={'i': SerialLoop(20)})(x) 
 
      # Computes the result in a vectorized way, but in 400 micro-batches, 
      # once for each coordinate (0, 0) &lt;= (i, j) &lt; (20, 20). Each `SerialLoop` 
      # creates a fresh anonymous loop. 
      xmap(h, in_axes=(['i'], ['j']), out_axes=['i', 'j'], 
           axis_resources={'i': SerialLoop(20), 'j': SerialLoop(20)})(x, y) 
  &quot;&quot;&quot;</span>
  <span class="s1">length: int</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">length):</span>
    <span class="s1">self.length = length</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return </span><span class="s1">self.length == other.length</span>

  <span class="s2">def </span><span class="s1">__hash__(self):</span>
    <span class="s2">return </span><span class="s1">hash(self.length)</span>


<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">serial_loop(name: ResourceAxisName</span><span class="s2">, </span><span class="s1">length: int):</span>
  <span class="s4">&quot;&quot;&quot;Define a serial loop resource to be available in scope of this context manager. 
 
  This is similar to :py:class:`Mesh` in that it extends the resource 
  environment with a resource called ``name``. But, any use of this resource 
  axis in ``axis_resources`` argument of :py:func:`xmap` will cause the 
  body of :py:func:`xmap` to get executed ``length`` times with each execution 
  only processing only a slice of inputs mapped along logical axes assigned 
  to this resource. 
 
  This is especially useful in that it makes it possible to lower the memory 
  usage compared to :py:func:`vmap`, because it will avoid simultaneous 
  materialization of intermediate values for every point in the batch. 
 
  Note that collectives over loop axes are not supported, so they are less 
  versatile than physical mesh axes. 
 
  Args: 
    name: Name of the loop in the resource environment. 
    length: Number of iterations. 
 
  Example:: 
 
    &gt;&gt;&gt; x = jnp.linspace(0, jnp.pi, 4) 
    ... 
    &gt;&gt;&gt; with serial_loop('l', len(x)): 
    ...   out = xmap( 
    ...     lambda x: jnp.sin(x) * 5,  # This will be called 4 times with different 
    ...                                # slices of x. 
    ...     in_axes=['i'], out_axes=['i'], 
    ...     axis_resources={'i': 'l'})(x) 
    &gt;&gt;&gt; out.shape 
    (4,) 
  &quot;&quot;&quot;</span>
  <span class="s1">old_env: ResourceEnv = getattr(thread_resources</span><span class="s2">, </span><span class="s3">&quot;env&quot;</span><span class="s2">, </span><span class="s1">EMPTY_ENV)</span>
  <span class="s1">thread_resources.env = old_env.with_extra_loop(mesh_lib.Loop(name</span><span class="s2">, </span><span class="s1">length))</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">yield</span>
  <span class="s2">finally</span><span class="s1">:</span>
    <span class="s1">thread_resources.env = old_env</span>


<span class="s1">_next_resource_id = </span><span class="s5">0</span>
<span class="s2">class </span><span class="s1">_UniqueResourceName:</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">uid</span><span class="s2">, </span><span class="s1">tag=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">self.uid = uid</span>
    <span class="s1">self.tag = tag</span>
  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return </span><span class="s1">type(other) </span><span class="s2">is </span><span class="s1">_UniqueResourceName </span><span class="s2">and </span><span class="s1">self.uid == other.uid</span>
  <span class="s2">def </span><span class="s1">__hash__(self):</span>
    <span class="s2">return </span><span class="s1">hash(self.uid)</span>
  <span class="s2">def </span><span class="s1">__repr__(self):</span>
    <span class="s2">return </span><span class="s3">f&quot;&lt;UniqueResource </span><span class="s2">{</span><span class="s1">self.tag</span><span class="s2">} {</span><span class="s1">self.uid</span><span class="s2">}</span><span class="s3">&gt;&quot;</span>

<span class="s2">def </span><span class="s1">fresh_resource_name(tag=</span><span class="s2">None</span><span class="s1">):</span>
  <span class="s2">global </span><span class="s1">_next_resource_id</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">_UniqueResourceName(_next_resource_id</span><span class="s2">, </span><span class="s1">tag)</span>
  <span class="s2">finally</span><span class="s1">:</span>
    <span class="s1">_next_resource_id += </span><span class="s5">1</span>


<span class="s0"># This is really a Dict[AxisName, int], but we don't define a</span>
<span class="s0"># pytree instance for it, so that it is treated as a leaf.</span>
<span class="s2">class </span><span class="s1">AxisNamePos(FrozenDict):</span>
  <span class="s1">user_repr: str</span>
  <span class="s1">expected_rank: Optional[int] = </span><span class="s2">None</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">user_repr</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s1">super().__init__(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s1">self.user_repr = user_repr</span>

<span class="s2">class </span><span class="s1">AxisNamePosWithRank(AxisNamePos):</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">expected_rank</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s1">super().__init__(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s1">self.expected_rank = expected_rank</span>


<span class="s0"># str(...) == 'Ellipsis' which is really annoying</span>
<span class="s2">class </span><span class="s1">DotDotDotRepr:</span>
  <span class="s2">def </span><span class="s1">__repr__(self): </span><span class="s2">return </span><span class="s3">'...'</span>


<span class="s2">def </span><span class="s1">_parse_entry(arg_name</span><span class="s2">, </span><span class="s1">entry):</span>
  <span class="s0"># Dictionaries mapping axis names to positional axes</span>
  <span class="s2">if </span><span class="s1">isinstance(entry</span><span class="s2">, </span><span class="s1">dict) </span><span class="s2">and </span><span class="s1">all(isinstance(v</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">entry.keys()):</span>
    <span class="s1">result = AxisNamePos(((name</span><span class="s2">, </span><span class="s1">axis) </span><span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">entry.items())</span><span class="s2">,</span>
                         <span class="s1">user_repr=str(entry))</span>
    <span class="s1">num_mapped_dims = len(entry)</span>
  <span class="s0"># Non-empty lists or tuples that optionally terminate with an ellipsis</span>
  <span class="s2">elif </span><span class="s1">isinstance(entry</span><span class="s2">, </span><span class="s1">(tuple</span><span class="s2">, </span><span class="s1">list)):</span>
    <span class="s2">if </span><span class="s1">entry </span><span class="s2">and </span><span class="s1">entry[-</span><span class="s5">1</span><span class="s1">] == ...:</span>
      <span class="s1">constr = AxisNamePos</span>
      <span class="s1">entry = entry[:-</span><span class="s5">1</span><span class="s1">]</span>
      <span class="s1">tail = [DotDotDotRepr()] </span><span class="s2">if </span><span class="s1">isinstance(entry</span><span class="s2">, </span><span class="s1">list) </span><span class="s2">else </span><span class="s1">(DotDotDotRepr()</span><span class="s2">,</span><span class="s1">)</span>
      <span class="s1">user_repr = str(entry + tail)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">constr = partial(AxisNamePosWithRank</span><span class="s2">, </span><span class="s1">expected_rank=len(entry))</span>
      <span class="s1">user_repr = str(entry)</span>
    <span class="s1">result = constr(((name</span><span class="s2">, </span><span class="s1">axis) </span><span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enumerate(entry)</span>
                     <span class="s2">if </span><span class="s1">name </span><span class="s2">is not None</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">user_repr=user_repr)</span>
    <span class="s1">num_mapped_dims = sum(name </span><span class="s2">is not None for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">entry)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">Value mapping specification in xmap </span><span class="s2">{</span><span class="s1">arg_name</span><span class="s2">} </span><span class="s3">pytree can be either:</span>
<span class="s3">- lists of axis names (possibly ending with the ellipsis object: ...)</span>
<span class="s3">- dictionaries that map positional axes (integers) to axis names (e.g. </span><span class="s2">{{</span><span class="s3">2: 'name'</span><span class="s2">}}</span><span class="s3">)</span>
<span class="s3">but got: </span><span class="s2">{</span><span class="s1">entry</span><span class="s2">}</span><span class="s3">&quot;&quot;&quot;</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s1">len(result) != num_mapped_dims:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Named axes should be unique within each </span><span class="s2">{</span><span class="s1">arg_name</span><span class="s2">} </span><span class="s3">argument &quot;</span>
                     <span class="s3">f&quot;specification, but one them is: </span><span class="s2">{</span><span class="s1">entry</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
  <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">result.values():</span>
    <span class="s2">if </span><span class="s1">axis &lt; </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;xmap doesn't support negative axes in </span><span class="s2">{</span><span class="s1">arg_name</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
  <span class="s2">return </span><span class="s1">result</span>

<span class="s2">def </span><span class="s1">_is_axes_leaf(entry):</span>
  <span class="s2">if </span><span class="s1">isinstance(entry</span><span class="s2">, </span><span class="s1">dict) </span><span class="s2">and </span><span class="s1">all_leaves(entry.values()):</span>
    <span class="s2">return True</span>
  <span class="s0"># NOTE: `None`s are not considered leaves by `all_leaves`</span>
  <span class="s2">if </span><span class="s1">isinstance(entry</span><span class="s2">, </span><span class="s1">(tuple</span><span class="s2">, </span><span class="s1">list)) </span><span class="s2">and </span><span class="s1">all_leaves(v </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">entry </span><span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s1">):</span>
    <span class="s2">return True</span>
  <span class="s2">return False</span>

<span class="s2">def </span><span class="s1">_prepare_axes(axes</span><span class="s2">, </span><span class="s1">arg_name):</span>
  <span class="s1">entries</span><span class="s2">, </span><span class="s1">treedef = tree_flatten(axes</span><span class="s2">, </span><span class="s1">is_leaf=_is_axes_leaf)</span>
  <span class="s1">entries = map(partial(_parse_entry</span><span class="s2">, </span><span class="s1">arg_name)</span><span class="s2">, </span><span class="s1">entries)</span>
  <span class="s2">return </span><span class="s1">tree_unflatten(treedef</span><span class="s2">, </span><span class="s1">entries)</span><span class="s2">, </span><span class="s1">entries</span><span class="s2">, </span><span class="s1">treedef</span>

<span class="s1">Resource = Union[ResourceAxisName</span><span class="s2">, </span><span class="s1">SerialLoop]</span>
<span class="s1">ResourceSet = Union[Resource</span><span class="s2">, </span><span class="s1">Tuple[Resource</span><span class="s2">, </span><span class="s1">...]]</span>

<span class="s0"># TODO: Some syntactic sugar to make the API more usable in a single-axis case?</span>
<span class="s0"># TODO: Are the resource axes scoped lexically or dynamically? Dynamically for now!</span>
<span class="s2">def </span><span class="s1">xmap(fun: Callable</span><span class="s2">,</span>
         <span class="s1">in_axes</span><span class="s2">,</span>
         <span class="s1">out_axes</span><span class="s2">,</span>
         <span class="s1">*</span><span class="s2">,</span>
         <span class="s1">axis_sizes: Optional[Mapping[AxisName</span><span class="s2">, </span><span class="s1">int]] = </span><span class="s2">None,</span>
         <span class="s1">axis_resources: Optional[Mapping[AxisName</span><span class="s2">, </span><span class="s1">ResourceSet]] = </span><span class="s2">None,</span>
         <span class="s1">donate_argnums: Union[int</span><span class="s2">, </span><span class="s1">Sequence[int]] = ()</span><span class="s2">,</span>
         <span class="s1">backend: Optional[str] = </span><span class="s2">None</span><span class="s1">) -&gt; stages.Wrapped:</span>
  <span class="s4">&quot;&quot;&quot;Assign a positional signature to a program that uses named array axes. 
 
  .. warning:: 
    This is an experimental feature and the details can change at 
    any time. Use at your own risk! 
 
  .. warning:: 
    This docstring is aspirational. Not all features of the named axis 
    programming model have been implemented just yet. 
 
  The usual programming model of JAX (or really NumPy) associates each array 
  with two pieces of metadata describing its type: the element type (``dtype``) 
  and the ``shape``. :py:func:`xmap` extends this model by adding support for 
  *named axes*.  In particular, each array used in a function wrapped by 
  :py:func:`xmap` can additionally have a non-empty ``named_shape`` attribute, 
  which can be used to query the set of named axes (introduced by 
  :py:func:`xmap`) appearing in that value along with their shapes. 
  Furthermore, in most places where positional axis indices are allowed (for 
  example the `axes` arguments in :py:func:`sum`), bound axis names are also 
  accepted. The :py:func:`einsum` language is extended inside :py:func:`xmap` 
  to additionally allow contractions that involve named axes.  Broadcasting of 
  named axes happens *by name*, i.e. all axes with equal names are expected to 
  have equal shapes in all arguments of a broadcasting operation, while the 
  result has a (set) union of all named axes.  The positional semantics of the 
  program remain unchanged, and broadcasting still implicitly right-aligns 
  positional axes for unification. For an extended description of the 
  :py:func:`xmap` programming model, please refer to the :py:func:`xmap` 
  tutorial notebook in main JAX documentation. 
 
  Note that since all top-level JAX expressions are interpreted in the NumPy 
  programming model, :py:func:`xmap` can also be seen as an adapter that 
  converts a function that uses named axes (including in arguments and returned 
  values) into one that takes and returns values that only have positional 
  axes. 
 
  The default lowering strategy of :py:func:`xmap` converts all named axes into 
  positional axes, working similarly to multiple applications of 
  :py:func:`vmap`. However, this behavior can be further customized by the 
  ``axis_resources`` argument.  When specified, each axis introduced by 
  :py:func:`xmap` can be assigned to one or more *resource axes*. Those include 
  the axes of the hardware mesh, as defined by the :py:class:`Mesh` context 
  manager. Each value that has a named axis in its ``named_shape`` will be 
  partitioned over all mesh axes that axis is assigned to. Hence, 
  :py:func:`xmap` can be seen as an alternative to :py:func:`pmap` that also 
  exposes a way to automatically partition the computation over multiple 
  devices. 
 
  .. warning:: 
    While it is possible to assign multiple axis names to a single resource axis, 
    care has to be taken to ensure that none of those named axes co-occur in a 
    ``named_shape`` of any value in the named program. At the moment this is 
    **completely unchecked** and will result in **undefined behavior**. The 
    final release of :py:func:`xmap` will enforce this invariant, but it is a 
    work in progress. 
 
    Note that you do not have to worry about any of this for as long as no 
    resource axis is repeated in ``axis_resources.values()``. 
 
  Note that any assignment of ``axis_resources`` doesn't ever change the 
  results of the computation, but only how it is carried out (e.g. how many 
  devices are used).  This makes it easy to try out various ways of 
  partitioning a single program in many distributed scenarios (both small- and 
  large-scale), to maximize the performance.  As such, :py:func:`xmap` can be 
  seen as a way to seamlessly interpolate between :py:func:`vmap` and 
  :py:func:`pmap`-style execution. 
 
  Args: 
    fun: Function that uses named axes. Its arguments and return 
      value should be arrays, scalars, or (nested) standard Python containers 
      (tuple/list/dict) thereof (in general: valid pytrees). 
    in_axes: A Python object with the same container (pytree) structure as the 
      signature of arguments to ``fun``, but with a positional-to-named axis 
      mapping in place of every array argument. The valid positional-to-named 
      mappings are: (1) a ``Dict[int, AxisName]`` specifying that a positional 
      dimensions given by dictionary keys are to be converted to named axes 
      of given names (2) a list of axis names that ends with the Ellipsis object 
      (``...``) in which case a number of leading positional axes of the argument 
      will be converted into named axes inside the function. Note that ``in_axes`` 
      can also be a prefix of the argument container structure, in which case the 
      mapping is repeated for all arrays in the collapsed subtree. 
    out_axes: A Python object with the same container (pytree) structure as the 
      returns of ``fun``, but with a positional-to-named axis mapping in place 
      of every returned array. The valid positional-to-named mappings are the same 
      as in ``in_axes``. Note that ``out_axes`` can also be a prefix of the return 
      container structure, in which case the mapping is repeated for all arrays 
      in the collapsed subtree. 
    axis_sizes: A dict mapping axis names to their sizes. All axes defined by xmap 
      have to appear either in ``in_axes`` or ``axis_sizes``. Sizes of axes 
      that appear in ``in_axes`` are inferred from arguments whenever possible. 
      In multi-host scenarios, the user-specified sizes are expected to be the 
      global axis sizes (and might not match the expected size of local inputs). 
    axis_resources: A dictionary mapping the axes introduced in this 
      :py:func:`xmap` to one or more resource axes. Any array that has in its 
      shape an axis with some resources assigned will be partitioned over the 
      resources associated with the respective resource axes. 
    donate_argnums: Specify which argument buffers are &quot;donated&quot; to the computation. 
      It is safe to donate argument buffers if you no longer need them once the 
      computation has finished. In some cases XLA can make use of donated 
      buffers to reduce the amount of memory needed to perform a computation, 
      for example recycling one of your input buffers to store a result. You 
      should not reuse buffers that you donate to a computation, JAX will raise 
      an error if you try to. 
 
      For more details on buffer donation see the `FAQ &lt;https://jax.readthedocs.io/en/latest/faq.html#buffer-donation&gt;`_. 
 
    backend: This is an experimental feature and the API is likely to change. 
      Optional, a string representing the XLA backend. 'cpu', 'gpu', or 'tpu'. 
 
  Returns: 
    A version of ``fun`` that takes in arrays with positional axes in place of 
    named axes bound in this :py:func:`xmap` call, and results with all named 
    axes converted to positional axes. If ``axis_resources`` is specified, 
    ``fun`` can additionally execute in parallel on multiple devices. 
 
  For example, :py:func:`xmap` makes it very easy to convert a function that 
  computes the vector inner product (such as :py:func:`jax.numpy.vdot`) into 
  one that computes a matrix multiplication: 
 
  &gt;&gt;&gt; import jax.numpy as jnp 
  &gt;&gt;&gt; x = jnp.arange(10).reshape((2, 5)) 
  &gt;&gt;&gt; xmap(jnp.vdot, 
  ...      in_axes=({0: 'left'}, {1: 'right'}), 
  ...      out_axes=['left', 'right', ...])(x, x.T) 
  Array([[ 30,  80], 
         [ 80, 255]], dtype=int32) 
 
  Note that the contraction in the program is performed over the positional axes, 
  while named axes are just a convenient way to achieve batching. While this 
  might seem like a silly example at first, it might turn out to be useful in 
  practice, since with conjunction with ``axis_resources`` this makes it possible 
  to implement a distributed matrix-multiplication in just a few lines of code:: 
 
    devices = np.array(jax.devices())[:4].reshape((2, 2)) 
    with Mesh(devices, ('x', 'y')):  # declare a 2D mesh with axes 'x' and 'y' 
      distributed_out = xmap( 
        jnp.vdot, 
        in_axes=({0: 'left'}, {1: 'right'}), 
        out_axes=['left', 'right', ...], 
        axis_resources={'left': 'x', 'right': 'y'})(x, x.T) 
 
  Still, the above examples are quite simple. After all, the xmapped 
  computation was a simple NumPy function that didn't use the axis names at all! 
  So, let's explore a slightly larger example which is linear regression:: 
 
    def regression_loss(x, y, w, b): 
      # Contract over in_features. Batch and out_features are present in 
      # both inputs and output, so they don't need to be mentioned 
      y_pred = jnp.einsum('{in_features},{in_features}-&gt;{}', x, w) + b 
      error = jnp.sum((y - y_pred) ** 2, axis='out_features') 
      return jnp.mean(error, axis='batch') 
 
    xmap(regression_loss, 
         in_axes=(['batch', 'in_features', ...], 
                  ['batch', 'out_features', ...], 
                  ['in_features', 'out_features', ...], 
                  ['out_features', ...]), 
         out_axes={})  # Loss is reduced over all axes, including batch! 
 
  .. note:: 
    When using ``axis_resources`` along with a mesh that is controlled by 
    multiple JAX hosts, keep in mind that in any given process :py:func:`xmap` 
    only expects the data slice that corresponds to its local devices to be 
    specified. This is in line with the current multi-host :py:func:`pmap` 
    programming model. 
  &quot;&quot;&quot;</span>
  <span class="s1">check_callable(fun)</span>

  <span class="s2">if </span><span class="s1">isinstance(in_axes</span><span class="s2">, </span><span class="s1">list) </span><span class="s2">and not </span><span class="s1">_is_axes_leaf(in_axes):</span>
    <span class="s0"># To be a tree prefix of the positional args tuple, in_axes can never be a</span>
    <span class="s0"># list: if in_axes is not a leaf, it must be a tuple of trees. However,</span>
    <span class="s0"># in cases like these users expect tuples and lists to be treated</span>
    <span class="s0"># essentially interchangeably, so we canonicalize lists to tuples here</span>
    <span class="s0"># rather than raising an error. https://github.com/google/jax/issues/2367</span>
    <span class="s1">in_axes = tuple(in_axes)</span>

  <span class="s2">if </span><span class="s1">in_axes == ():  </span><span class="s0"># Allow empty argument lists</span>
    <span class="s1">in_axes</span><span class="s2">, </span><span class="s1">in_axes_entries = ()</span><span class="s2">, </span><span class="s1">[]</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">in_axes</span><span class="s2">, </span><span class="s1">in_axes_entries</span><span class="s2">, </span><span class="s1">_ = _prepare_axes(in_axes</span><span class="s2">, </span><span class="s3">&quot;in_axes&quot;</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s1">out_axes == ():</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;xmapped functions cannot have no return values&quot;</span><span class="s1">)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">out_axes</span><span class="s2">, </span><span class="s1">out_axes_entries</span><span class="s2">, </span><span class="s1">out_axes_treedef = _prepare_axes(out_axes</span><span class="s2">, </span><span class="s3">&quot;out_axes&quot;</span><span class="s1">)</span>
    <span class="s1">out_axes_entries = tuple(out_axes_entries)  </span><span class="s0"># Make entries hashable</span>

  <span class="s1">axis_sizes = {} </span><span class="s2">if </span><span class="s1">axis_sizes </span><span class="s2">is None else </span><span class="s1">axis_sizes</span>
  <span class="s1">axis_resources = {} </span><span class="s2">if </span><span class="s1">axis_resources </span><span class="s2">is None else </span><span class="s1">axis_resources</span>

  <span class="s1">axis_sizes_names = set(axis_sizes.keys())</span>
  <span class="s1">in_axes_names = set(it.chain(*(spec.keys() </span><span class="s2">for </span><span class="s1">spec </span><span class="s2">in </span><span class="s1">in_axes_entries)))</span>
  <span class="s1">defined_names = axis_sizes_names | in_axes_names</span>
  <span class="s1">out_axes_names = set(it.chain(*(spec.keys() </span><span class="s2">for </span><span class="s1">spec </span><span class="s2">in </span><span class="s1">out_axes_entries)))</span>

  <span class="s1">anon_serial_loops = []</span>
  <span class="s2">def </span><span class="s1">normalize_resource(r) -&gt; ResourceAxisName:</span>
    <span class="s2">if </span><span class="s1">isinstance(r</span><span class="s2">, </span><span class="s1">SerialLoop):</span>
      <span class="s1">name = fresh_resource_name()</span>
      <span class="s1">anon_serial_loops.append((name</span><span class="s2">, </span><span class="s1">r.length))</span>
      <span class="s2">return </span><span class="s1">name</span>
    <span class="s2">return </span><span class="s1">r</span>

  <span class="s1">axes_with_resources = set(axis_resources.keys())</span>
  <span class="s2">if </span><span class="s1">axes_with_resources - defined_names:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;All axes that were assigned resources have to appear in &quot;</span>
                     <span class="s3">f&quot;in_axes or axis_sizes, but the following are missing: &quot;</span>
                     <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">axes_with_resources - defined_names</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s1">out_axes_names - defined_names:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;All axis names appearing in out_axes must also appear in &quot;</span>
                     <span class="s3">f&quot;in_axes or axis_sizes, but the following are missing: &quot;</span>
                     <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">out_axes_names - defined_names</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s1">normalized_axis_resources: Dict[AxisName</span><span class="s2">, </span><span class="s1">Tuple[ResourceAxisName</span><span class="s2">, </span><span class="s1">...]] = {}</span>
  <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">defined_names:</span>
    <span class="s1">resources = axis_resources.get(axis</span><span class="s2">, </span><span class="s1">())</span>
    <span class="s2">if not </span><span class="s1">isinstance(resources</span><span class="s2">, </span><span class="s1">tuple):</span>
      <span class="s1">resources = (resources</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">normalized_axis_resources[axis] = tuple(unsafe_map(normalize_resource</span><span class="s2">, </span><span class="s1">resources))</span>
  <span class="s1">frozen_axis_resources = FrozenDict(normalized_axis_resources)</span>
  <span class="s1">necessary_resources = set(it.chain(*frozen_axis_resources.values()))</span>

  <span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">resources </span><span class="s2">in </span><span class="s1">frozen_axis_resources.items():</span>
    <span class="s2">if </span><span class="s1">len(set(resources)) != len(resources):  </span><span class="s0"># type: ignore</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Resource assignment of a single axis must be a tuple of &quot;</span>
                       <span class="s3">f&quot;distinct resources, but specified </span><span class="s2">{</span><span class="s1">resources</span><span class="s2">} </span><span class="s3">for axis </span><span class="s2">{</span><span class="s1">axis</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s1">donate_argnums = _ensure_index_tuple(donate_argnums)</span>

  <span class="s0"># A little performance optimization to avoid iterating over all args unnecessarily</span>
  <span class="s1">has_input_rank_assertions = any(spec.expected_rank </span><span class="s2">is not None for </span><span class="s1">spec </span><span class="s2">in </span><span class="s1">in_axes_entries)</span>
  <span class="s1">has_output_rank_assertions = any(spec.expected_rank </span><span class="s2">is not None for </span><span class="s1">spec </span><span class="s2">in </span><span class="s1">out_axes_entries)</span>

  <span class="s2">def </span><span class="s1">infer_params(*args):</span>
    <span class="s0"># Putting this outside of fun_mapped would make resources lexically scoped</span>
    <span class="s1">resource_env = thread_resources.env</span>
    <span class="s1">available_resources = set(resource_env.shape.keys())</span>

    <span class="s2">if </span><span class="s1">necessary_resources - available_resources:</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;In-scope resources are insufficient to execute the &quot;</span>
                       <span class="s3">f&quot;xmapped function. The missing resources are: &quot;</span>
                       <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">necessary_resources - available_resources</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s1">args_flat</span><span class="s2">, </span><span class="s1">in_tree = tree_flatten(args)</span>
    <span class="s1">fun_flat</span><span class="s2">, </span><span class="s1">out_tree = flatten_fun_nokwargs(lu.wrap_init(fun)</span><span class="s2">, </span><span class="s1">in_tree)</span>
    <span class="s2">if </span><span class="s1">donate_argnums:</span>
      <span class="s1">donated_invars = donation_vector(donate_argnums</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">())</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">donated_invars = (</span><span class="s2">False,</span><span class="s1">) * len(args_flat)</span>
    <span class="s1">in_axes_flat = _flatten_axes(</span><span class="s3">&quot;xmap in_axes&quot;</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">tupled_args=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s0"># Some pytree containers might be unhashable, so we flatten the out_axes</span>
    <span class="s0"># pytree into a treedef and entries which are guaranteed to be hashable.</span>
    <span class="s1">out_axes_thunk = HashableFunction(</span>
      <span class="s2">lambda</span><span class="s1">: tuple(_flatten_axes(</span><span class="s3">&quot;xmap out_axes&quot;</span><span class="s2">, </span><span class="s1">out_tree()</span><span class="s2">, </span><span class="s1">out_axes</span><span class="s2">, </span><span class="s1">tupled_args=</span><span class="s2">False</span><span class="s1">))</span><span class="s2">,</span>
      <span class="s1">closure=(out_axes_entries</span><span class="s2">, </span><span class="s1">out_axes_treedef))</span>

    <span class="s1">axis_resource_count = _get_axis_resource_count(</span>
        <span class="s1">frozen_axis_resources</span><span class="s2">, </span><span class="s1">resource_env)</span>

    <span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">size </span><span class="s2">in </span><span class="s1">axis_sizes.items():</span>
      <span class="s1">resources = axis_resource_count[axis]</span>
      <span class="s2">if </span><span class="s1">size % resources.nglobal != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">global_size = </span><span class="s3">&quot;Global size&quot; </span><span class="s2">if </span><span class="s1">resources.distributed </span><span class="s2">else </span><span class="s3">&quot;Size&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">global_size</span><span class="s2">} </span><span class="s3">of axis </span><span class="s2">{</span><span class="s1">axis</span><span class="s2">} </span><span class="s3">(</span><span class="s2">{</span><span class="s1">size</span><span class="s2">}</span><span class="s3">) is not divisible &quot;</span>
                         <span class="s3">f&quot;by the total number of resources assigned to this axis &quot;</span>
                         <span class="s3">f&quot;(</span><span class="s2">{</span><span class="s1">frozen_axis_resources[axis]</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">resources.nglobal</span><span class="s2">} </span><span class="s3">in total)&quot;</span><span class="s1">)</span>
    <span class="s1">frozen_global_axis_sizes = _get_axis_sizes(</span>
        <span class="s1">args_flat</span><span class="s2">, </span><span class="s1">in_axes_flat</span><span class="s2">, </span><span class="s1">axis_sizes</span><span class="s2">, </span><span class="s1">axis_resource_count)</span>

    <span class="s1">missing_sizes = defined_names - set(frozen_global_axis_sizes.keys())</span>
    <span class="s2">if </span><span class="s1">missing_sizes:</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Failed to infer size of axes: </span><span class="s2">{</span><span class="s3">', '</span><span class="s1">.join(unsafe_map(str</span><span class="s2">, </span><span class="s1">missing_sizes))</span><span class="s2">}</span><span class="s3">. &quot;</span>
                       <span class="s3">f&quot;You've probably passed in empty containers in place of arguments that had &quot;</span>
                       <span class="s3">f&quot;those axes in their in_axes. Provide the sizes of missing axes explicitly &quot;</span>
                       <span class="s3">f&quot;via axis_sizes to fix this error.&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">has_input_rank_assertions:</span>
      <span class="s2">for </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">spec </span><span class="s2">in </span><span class="s1">zip(args_flat</span><span class="s2">, </span><span class="s1">in_axes_flat):</span>
        <span class="s2">if </span><span class="s1">spec.expected_rank </span><span class="s2">is not None and </span><span class="s1">spec.expected_rank != arg.ndim:</span>
          <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;xmap argument has an in_axes specification of </span><span class="s2">{</span><span class="s1">spec.user_repr</span><span class="s2">}</span><span class="s3">, &quot;</span>
                           <span class="s3">f&quot;which asserts that it should be of rank </span><span class="s2">{</span><span class="s1">spec.expected_rank</span><span class="s2">}</span><span class="s3">, &quot;</span>
                           <span class="s3">f&quot;but the argument has rank </span><span class="s2">{</span><span class="s1">arg.ndim</span><span class="s2">} </span><span class="s3">(and shape </span><span class="s2">{</span><span class="s1">arg.shape</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">)</span>

    <span class="s1">_check_gda_or_array_xmap_partitioning(</span>
        <span class="s1">frozen_axis_resources</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">frozen_global_axis_sizes</span><span class="s2">,</span>
        <span class="s1">in_axes_flat</span><span class="s2">, </span><span class="s1">args_flat)</span>

    <span class="s1">params = dict(</span>
      <span class="s1">name=getattr(fun</span><span class="s2">, </span><span class="s3">'__name__'</span><span class="s2">, </span><span class="s3">'&lt;unnamed function&gt;'</span><span class="s1">)</span><span class="s2">,</span>
      <span class="s1">in_axes=tuple(in_axes_flat)</span><span class="s2">,</span>
      <span class="s1">out_axes_thunk=out_axes_thunk</span><span class="s2">,</span>
      <span class="s1">donated_invars=donated_invars</span><span class="s2">,</span>
      <span class="s1">global_axis_sizes=frozen_global_axis_sizes</span><span class="s2">,</span>
      <span class="s1">axis_resources=frozen_axis_resources</span><span class="s2">,</span>
      <span class="s1">resource_env=resource_env</span><span class="s2">,</span>
      <span class="s1">backend=backend</span><span class="s2">,</span>
      <span class="s1">spmd_in_axes=</span><span class="s2">None,</span>
      <span class="s1">spmd_out_axes_thunk=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">fun_flat</span><span class="s2">, </span><span class="s1">args_flat</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">out_tree</span>

  <span class="s2">def </span><span class="s1">verify_outputs(out_flat</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s2">if </span><span class="s1">has_output_rank_assertions:</span>
      <span class="s2">for </span><span class="s1">out</span><span class="s2">, </span><span class="s1">spec </span><span class="s2">in </span><span class="s1">zip(out_flat</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'out_axes_thunk'</span><span class="s1">]()):</span>
        <span class="s2">if </span><span class="s1">spec.expected_rank </span><span class="s2">is not None and </span><span class="s1">spec.expected_rank != out.ndim:</span>
          <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;xmap output has an out_axes specification of </span><span class="s2">{</span><span class="s1">spec.user_repr</span><span class="s2">}</span><span class="s3">, &quot;</span>
                           <span class="s3">f&quot;which asserts that it should be of rank </span><span class="s2">{</span><span class="s1">spec.expected_rank</span><span class="s2">}</span><span class="s3">, &quot;</span>
                           <span class="s3">f&quot;but the output has rank </span><span class="s2">{</span><span class="s1">out.ndim</span><span class="s2">} </span><span class="s3">(and shape </span><span class="s2">{</span><span class="s1">out.shape</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">tree_unflatten(out_tree()</span><span class="s2">, </span><span class="s1">out_flat)</span>

  <span class="s2">def </span><span class="s1">decorate_serial(f):</span>
    <span class="s2">for </span><span class="s1">loop_params </span><span class="s2">in </span><span class="s1">reversed(anon_serial_loops):</span>
      <span class="s1">f = serial_loop(*loop_params)(f)</span>
    <span class="s2">return </span><span class="s1">f</span>

  <span class="s1">@wraps(fun)</span>
  <span class="s1">@decorate_serial</span>
  <span class="s2">def </span><span class="s1">fun_mapped(*args):</span>
    <span class="s1">tree_map(dispatch.check_arg</span><span class="s2">, </span><span class="s1">args)</span>
    <span class="s1">fun_flat</span><span class="s2">, </span><span class="s1">args_flat</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">out_tree = infer_params(*args)</span>
    <span class="s1">out_flat = xmap_p.bind(fun_flat</span><span class="s2">, </span><span class="s1">*args_flat</span><span class="s2">, </span><span class="s1">**params)</span>
    <span class="s2">return </span><span class="s1">verify_outputs(out_flat</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">, </span><span class="s1">params)</span>

  <span class="s1">@decorate_serial</span>
  <span class="s2">def </span><span class="s1">lower(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s1">_experimental_lowering_platform = kwargs.pop(</span>
        <span class="s3">'_experimental_lowering_platform'</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s1">fun_flat</span><span class="s2">, </span><span class="s1">args_flat</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">out_tree = infer_params(*args)</span>
    <span class="s1">avals_flat = [shaped_abstractify(arg) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args_flat]</span>
    <span class="s1">computation = make_xmap_callable(</span>
        <span class="s1">fun_flat</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'name'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'in_axes'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'out_axes_thunk'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">params[</span><span class="s3">'donated_invars'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'global_axis_sizes'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'axis_resources'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">params[</span><span class="s3">'resource_env'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'backend'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'spmd_in_axes'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">params[</span><span class="s3">'spmd_out_axes_thunk'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">_experimental_lowering_platform</span><span class="s2">, </span><span class="s1">*avals_flat)</span>

    <span class="s1">in_tree = treedef_tuple([in_tree</span><span class="s2">, </span><span class="s1">tree_flatten({})[</span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">in_avals = in_tree.unflatten(avals_flat)</span>
    <span class="s2">return </span><span class="s1">stages.Lowered.from_flat_info(</span>
        <span class="s1">computation</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">in_avals</span><span class="s2">, </span><span class="s1">donate_argnums</span><span class="s2">, </span><span class="s1">out_tree()</span><span class="s2">,  </span><span class="s0"># type: ignore</span>
        <span class="s1">no_kwargs=</span><span class="s2">True</span><span class="s1">)</span>

  <span class="s1">fun_mapped.lower = lower</span>
  <span class="s2">return </span><span class="s1">fun_mapped</span>

<span class="s2">def </span><span class="s1">xmap_impl(fun: lu.WrappedFun</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes_thunk</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">,</span>
              <span class="s1">global_axis_sizes</span><span class="s2">, </span><span class="s1">axis_resources</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">,</span>
              <span class="s1">spmd_in_axes</span><span class="s2">, </span><span class="s1">spmd_out_axes_thunk):</span>
  <span class="s1">in_avals = [core.raise_to_shaped(core.get_aval(arg)) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args]</span>
  <span class="s1">xmap_callable = make_xmap_callable(</span>
      <span class="s1">fun</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes_thunk</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">, </span><span class="s1">global_axis_sizes</span><span class="s2">,</span>
      <span class="s1">axis_resources</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">,</span>
      <span class="s1">spmd_in_axes</span><span class="s2">, </span><span class="s1">spmd_out_axes_thunk</span><span class="s2">,</span>
      <span class="s2">None, </span><span class="s1">*in_avals).compile().unsafe_call</span>
  <span class="s1">distributed_debug_log((</span><span class="s3">&quot;Running xmapped function&quot;</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s3">&quot;python function&quot;</span><span class="s2">, </span><span class="s1">fun.f)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s3">&quot;mesh&quot;</span><span class="s2">, </span><span class="s1">resource_env.physical_mesh)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s3">&quot;abstract args&quot;</span><span class="s2">, </span><span class="s1">in_avals))</span>
  <span class="s2">return </span><span class="s1">xmap_callable(*args)</span>

<span class="s1">@lu.cache</span>
<span class="s2">def </span><span class="s1">make_xmap_callable(fun: lu.WrappedFun</span><span class="s2">,</span>
                       <span class="s1">name</span><span class="s2">,</span>
                       <span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes_thunk</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">,</span>
                       <span class="s1">global_axis_sizes</span><span class="s2">, </span><span class="s1">axis_resources</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">,</span>
                       <span class="s1">spmd_in_axes</span><span class="s2">, </span><span class="s1">spmd_out_axes_thunk</span><span class="s2">,</span>
                       <span class="s1">lowering_platform: Optional[str]</span><span class="s2">,</span>
                       <span class="s1">*in_avals):</span>
  <span class="s1">plan = EvaluationPlan.from_axis_resources(</span>
      <span class="s1">axis_resources</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">global_axis_sizes)</span>

  <span class="s0"># TODO: Making axis substitution final style would allow us to avoid</span>
  <span class="s0">#       tracing to jaxpr here</span>
  <span class="s1">mapped_in_avals = [_delete_aval_axes(aval</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">global_axis_sizes)</span>
                     <span class="s2">for </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">in_axes </span><span class="s2">in </span><span class="s1">zip(in_avals</span><span class="s2">, </span><span class="s1">in_axes)]</span>
  <span class="s2">with </span><span class="s1">core.extend_axis_env_nd(global_axis_sizes.items()):</span>
    <span class="s2">with </span><span class="s1">dispatch.log_elapsed_time(</span>
        <span class="s3">&quot;Finished tracing + transforming {fun_name} for xmap in {elapsed_time} sec&quot;</span><span class="s2">,</span>
        <span class="s1">fun_name=fun.__name__</span><span class="s2">, </span><span class="s1">event=dispatch.JAXPR_TRACE_EVENT):</span>
      <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">out_avals</span><span class="s2">, </span><span class="s1">consts = pe.trace_to_jaxpr_final(fun</span><span class="s2">, </span><span class="s1">mapped_in_avals)</span>
  <span class="s1">out_axes = out_axes_thunk()</span>
  <span class="s1">_check_out_avals_vs_out_axes(out_avals</span><span class="s2">, </span><span class="s1">out_axes</span><span class="s2">, </span><span class="s1">global_axis_sizes)</span>
  <span class="s0"># NOTE: We don't use avals and all params, so only pass in the relevant parts (too lazy...)</span>
  <span class="s1">_resource_typing_xmap([]</span><span class="s2">, </span><span class="s1">dict(axis_resources=axis_resources</span><span class="s2">,</span>
                                 <span class="s1">out_axes=out_axes</span><span class="s2">,</span>
                                 <span class="s1">call_jaxpr=jaxpr</span><span class="s2">,</span>
                                 <span class="s1">resource_env=resource_env</span><span class="s2">,</span>
                                 <span class="s1">name=name)</span><span class="s2">,</span>
                        <span class="s1">source_info_util.new_source_info()</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">{})</span>
  <span class="s1">jaxpr = plan.subst_axes_with_resources(jaxpr)</span>
  <span class="s1">use_spmd_lowering = config.experimental_xmap_spmd_lowering</span>
  <span class="s1">ensure_fixed_sharding = config.experimental_xmap_ensure_fixed_sharding</span>
  <span class="s2">if </span><span class="s1">use_spmd_lowering </span><span class="s2">and </span><span class="s1">ensure_fixed_sharding:</span>
    <span class="s1">jaxpr = _fix_inferred_spmd_sharding(jaxpr</span><span class="s2">, </span><span class="s1">resource_env)</span>

  <span class="s1">f = lu.wrap_init(core.jaxpr_as_fun(core.ClosedJaxpr(jaxpr</span><span class="s2">, </span><span class="s1">consts)))</span>
  <span class="s1">f = hide_mapped_axes(f</span><span class="s2">, </span><span class="s1">tuple(in_axes)</span><span class="s2">, </span><span class="s1">tuple(out_axes))</span>
  <span class="s1">f = plan.vectorize_and_loop(f</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes)</span>

  <span class="s1">used_resources = _jaxpr_resources(jaxpr</span><span class="s2">, </span><span class="s1">resource_env) | set(it.chain(*axis_resources.values()))</span>
  <span class="s1">used_mesh_axes = used_resources &amp; resource_env.physical_resource_axes</span>
  <span class="s2">if </span><span class="s1">used_mesh_axes:</span>
    <span class="s2">assert </span><span class="s1">spmd_in_axes </span><span class="s2">is None and </span><span class="s1">spmd_out_axes_thunk </span><span class="s2">is None  </span><span class="s0"># No outer xmaps, so should be None</span>
    <span class="s1">mesh_in_axes</span><span class="s2">, </span><span class="s1">mesh_out_axes = plan.to_mesh_axes(in_axes</span><span class="s2">, </span><span class="s1">out_axes)</span>
    <span class="s1">mesh = resource_env.physical_mesh</span>
    <span class="s1">tiling_method: pxla.TilingMethod</span>
    <span class="s2">if </span><span class="s1">config.experimental_xmap_spmd_lowering_manual:</span>
      <span class="s1">manual_mesh_axes = frozenset(it.chain.from_iterable(plan.physical_axis_resources.values()))</span>
      <span class="s1">tiling_method = pxla.TileManual(manual_mesh_axes)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">tiling_method = pxla.TileVectorize()</span>
    <span class="s1">in_shardings = [NamedSharding(mesh</span><span class="s2">, </span><span class="s1">array_mapping_to_axis_resources(i))</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">mesh_in_axes]</span>
    <span class="s1">out_shardings = [NamedSharding(mesh</span><span class="s2">, </span><span class="s1">array_mapping_to_axis_resources(o))</span>
                     <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">mesh_out_axes]</span>
    <span class="s2">return </span><span class="s1">pxla.lower_mesh_computation(</span>
        <span class="s1">f</span><span class="s2">, </span><span class="s3">'xmap'</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">mesh</span><span class="s2">,</span>
        <span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">,</span>
        <span class="s1">use_spmd_lowering</span><span class="s2">, </span><span class="s1">in_avals</span><span class="s2">,</span>
        <span class="s1">tiling_method=tiling_method</span><span class="s2">,</span>
        <span class="s1">lowering_platform=lowering_platform)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">dispatch.sharded_lowering(</span>
        <span class="s1">f</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">, True, False, </span><span class="s1">in_avals</span><span class="s2">, </span><span class="s1">(</span><span class="s2">None,</span><span class="s1">) * len(in_avals)</span><span class="s2">,</span>
        <span class="s1">lowering_platform=lowering_platform)</span>


<span class="s2">class </span><span class="s1">EvaluationPlan(NamedTuple):</span>
  <span class="s4">&quot;&quot;&quot;Encapsulates preprocessing common to top-level xmap invocations and its translation rule.&quot;&quot;&quot;</span>
  <span class="s1">resource_env: ResourceEnv</span>
  <span class="s1">physical_axis_resources: Dict[AxisName</span><span class="s2">, </span><span class="s1">Tuple[ResourceAxisName</span><span class="s2">, </span><span class="s1">...]]</span>
  <span class="s1">loop_axis_resources: Dict[AxisName</span><span class="s2">, </span><span class="s1">Tuple[ResourceAxisName</span><span class="s2">, </span><span class="s1">...]]</span>
  <span class="s1">axis_subst_dict: Dict[AxisName</span><span class="s2">, </span><span class="s1">Tuple[ResourceAxisName</span><span class="s2">, </span><span class="s1">...]]</span>
  <span class="s1">axis_vmap_size: Dict[AxisName</span><span class="s2">, </span><span class="s1">Optional[int]]</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">axis_subst(self) -&gt; core.AxisSubst:</span>
    <span class="s2">return lambda </span><span class="s1">name: self.axis_subst_dict.get(name</span><span class="s2">, </span><span class="s1">(name</span><span class="s2">,</span><span class="s1">))</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">resource_axis_env(self):</span>
    <span class="s1">env = dict(self.resource_env.shape)</span>
    <span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">size </span><span class="s2">in </span><span class="s1">self.axis_vmap_size.items():</span>
      <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">continue</span>
      <span class="s1">vmap_axis = self.axis_subst_dict[axis][-</span><span class="s5">1</span><span class="s1">]</span>
      <span class="s1">env[vmap_axis] = size</span>
    <span class="s2">return </span><span class="s1">env</span>

  <span class="s1">@classmethod</span>
  <span class="s2">def </span><span class="s1">from_axis_resources(cls</span><span class="s2">,</span>
                          <span class="s1">axis_resources: Dict[AxisName</span><span class="s2">, </span><span class="s1">Tuple[ResourceAxisName</span><span class="s2">, </span><span class="s1">...]]</span><span class="s2">,</span>
                          <span class="s1">resource_env: ResourceEnv</span><span class="s2">,</span>
                          <span class="s1">global_axis_sizes: Dict[AxisName</span><span class="s2">, </span><span class="s1">int]):</span>
    <span class="s1">physical_axis_resources</span><span class="s2">, </span><span class="s1">loop_axis_resources = _unzip_axis_resources(</span>
            <span class="s1">axis_resources</span><span class="s2">, </span><span class="s1">resource_env)</span>
    <span class="s1">axis_resource_count = _get_axis_resource_count(</span>
        <span class="s1">axis_resources</span><span class="s2">, </span><span class="s1">resource_env)</span>
    <span class="s1">axis_subst_dict = dict(axis_resources)</span>
    <span class="s1">axis_vmap_size: Dict[AxisName</span><span class="s2">, </span><span class="s1">Optional[int]] = {}</span>
    <span class="s2">for </span><span class="s1">naxis</span><span class="s2">, </span><span class="s1">raxes </span><span class="s2">in </span><span class="s1">sorted(axis_resources.items()</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">x: str(x[</span><span class="s5">0</span><span class="s1">])):</span>
      <span class="s1">num_resources = axis_resource_count[naxis]</span>
      <span class="s2">assert </span><span class="s1">global_axis_sizes[naxis] % num_resources.nglobal == </span><span class="s5">0</span>
      <span class="s1">local_tile_size = global_axis_sizes[naxis] // num_resources.nglobal</span>
      <span class="s0"># We have to vmap when there are no resources (to handle the axis name!) or</span>
      <span class="s0"># when every resource gets chunks of values.</span>
      <span class="s2">if not </span><span class="s1">raxes </span><span class="s2">or </span><span class="s1">local_tile_size &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">axis_vmap_size[naxis] = local_tile_size</span>
        <span class="s1">axis_subst_dict[naxis] += (fresh_resource_name(naxis)</span><span class="s2">,</span><span class="s1">)</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">axis_vmap_size[naxis] = </span><span class="s2">None</span>
    <span class="s2">return </span><span class="s1">cls(resource_env</span><span class="s2">,</span>
               <span class="s1">physical_axis_resources</span><span class="s2">, </span><span class="s1">loop_axis_resources</span><span class="s2">,</span>
               <span class="s1">axis_subst_dict</span><span class="s2">, </span><span class="s1">axis_vmap_size)</span>

  <span class="s2">def </span><span class="s1">subst_axes_with_resources(self</span><span class="s2">, </span><span class="s1">jaxpr):</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s2">if </span><span class="s1">any(self.loop_axis_resources.values()):</span>
        <span class="s1">_check_no_loop_collectives(jaxpr</span><span class="s2">, </span><span class="s1">self.loop_axis_resources)</span>
      <span class="s2">with </span><span class="s1">core.extend_axis_env_nd(self.resource_axis_env.items()):</span>
        <span class="s2">return </span><span class="s1">core.subst_axis_names_jaxpr(jaxpr</span><span class="s2">, </span><span class="s1">self.axis_subst)</span>
    <span class="s2">except </span><span class="s1">core.DuplicateAxisNameError:</span>
      <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s3">&quot;Incomplete resource type-checking? Please open a bug report!&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">vectorize_and_loop(self</span><span class="s2">, </span><span class="s1">f: lu.WrappedFun</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes) -&gt; lu.WrappedFun:</span>
    <span class="s1">vmap_axes = {</span>
        <span class="s1">naxis: raxes[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">naxis</span><span class="s2">, </span><span class="s1">raxes </span><span class="s2">in </span><span class="s1">self.axis_subst_dict.items()</span>
        <span class="s2">if </span><span class="s1">self.axis_vmap_size[naxis] </span><span class="s2">is not None</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">naxis</span><span class="s2">, </span><span class="s1">vaxis </span><span class="s2">in </span><span class="s1">sorted(vmap_axes.items()</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">x: x[</span><span class="s5">1</span><span class="s1">].uid):</span>
      <span class="s1">local_tile_size = self.axis_vmap_size[naxis]</span>
      <span class="s1">map_in_axes = tuple(unsafe_map(</span><span class="s2">lambda </span><span class="s1">spec: spec.get(naxis</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">in_axes))</span>
      <span class="s1">map_out_axes = tuple(unsafe_map(</span><span class="s2">lambda </span><span class="s1">spec: spec.get(naxis</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">out_axes))</span>
      <span class="s1">f = batching.vtile(f</span><span class="s2">, </span><span class="s1">map_in_axes</span><span class="s2">, </span><span class="s1">map_out_axes</span><span class="s2">, </span><span class="s1">tile_size=local_tile_size</span><span class="s2">, </span><span class="s1">axis_name=vaxis)</span>

    <span class="s1">used_loops = set(it.chain.from_iterable(self.loop_axis_resources.values()))</span>
    <span class="s2">if not </span><span class="s1">used_loops:</span>
      <span class="s2">return </span><span class="s1">f</span>

    <span class="s2">if </span><span class="s1">len(used_loops) &gt; </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s0"># TODO: Support multiple loops</span>
      <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;Only one loop per xmap is supported&quot;</span><span class="s1">)</span>
    <span class="s1">loop_in_axes = _to_resource_axes(in_axes</span><span class="s2">, </span><span class="s1">self.loop_axis_resources)</span>
    <span class="s1">loop_out_axes = _to_resource_axes(out_axes</span><span class="s2">, </span><span class="s1">self.loop_axis_resources)</span>
    <span class="s1">loop_name</span><span class="s2">, </span><span class="s1">= used_loops</span>
    <span class="s1">loop_length = self.resource_env.shape[loop_name]</span>
    <span class="s2">def </span><span class="s1">looped_f(*args):</span>
      <span class="s2">def </span><span class="s1">body(i</span><span class="s2">, </span><span class="s1">_):</span>
        <span class="s0"># XXX: This call_wrapped is only valid under the assumption that scan</span>
        <span class="s0">#      only ever traces the body once (which it does at the moment).</span>
        <span class="s1">result = f.call_wrapped(</span>
            <span class="s1">*(_slice_tile(arg</span><span class="s2">, </span><span class="s1">spec.get(loop_name</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">loop_length)</span>
              <span class="s2">for </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">spec </span><span class="s2">in </span><span class="s1">zip(args</span><span class="s2">, </span><span class="s1">loop_in_axes)))</span>
        <span class="s2">return </span><span class="s1">i + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">result</span>
      <span class="s1">_</span><span class="s2">, </span><span class="s1">stacked_results = lax.scan(body</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">()</span><span class="s2">, </span><span class="s1">length=loop_length)</span>
      <span class="s2">return </span><span class="s1">[_merge_leading_axis(sresult</span><span class="s2">, </span><span class="s1">spec.get(loop_name</span><span class="s2">, None</span><span class="s1">))</span>
              <span class="s2">for </span><span class="s1">sresult</span><span class="s2">, </span><span class="s1">spec </span><span class="s2">in </span><span class="s1">zip(stacked_results</span><span class="s2">, </span><span class="s1">loop_out_axes)]</span>
    <span class="s2">return </span><span class="s1">lu.wrap_init(looped_f)</span>

  <span class="s2">def </span><span class="s1">to_mesh_axes(self</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Convert in/out_axes parameters ranging over logical dimensions to 
    in/out_axes that range over the mesh dimensions. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">out_axes </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">_to_resource_axes(in_axes</span><span class="s2">, </span><span class="s1">self.physical_axis_resources)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">(_to_resource_axes(in_axes</span><span class="s2">, </span><span class="s1">self.physical_axis_resources)</span><span class="s2">,</span>
              <span class="s1">_to_resource_axes(out_axes</span><span class="s2">, </span><span class="s1">self.physical_axis_resources))</span>

<span class="s0"># -------- xmap primitive and its transforms --------</span>

<span class="s0"># xmap has a different set of parameters than pmap, so we make it its own primitive type</span>
<span class="s2">class </span><span class="s1">XMapPrimitive(core.MapPrimitive):</span>
  <span class="s2">def </span><span class="s1">__init__(self):</span>
    <span class="s1">super().__init__(</span><span class="s3">'xmap'</span><span class="s1">)</span>
    <span class="s1">self.def_impl(xmap_impl)</span>
    <span class="s1">self.def_custom_bind(self.bind)</span>

  <span class="s2">def </span><span class="s1">bind(self</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">**params):</span>
    <span class="s2">assert </span><span class="s1">len(in_axes) == len(args)</span><span class="s2">, </span><span class="s1">(in_axes</span><span class="s2">, </span><span class="s1">args)</span>
    <span class="s2">return </span><span class="s1">core.map_bind(self</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">in_axes=in_axes</span><span class="s2">, </span><span class="s1">**params)</span>

  <span class="s2">def </span><span class="s1">process(self</span><span class="s2">, </span><span class="s1">trace</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s2">return </span><span class="s1">trace.process_xmap(self</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params)</span>

  <span class="s2">def </span><span class="s1">post_process(self</span><span class="s2">, </span><span class="s1">trace</span><span class="s2">, </span><span class="s1">out_tracers</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s1">post_process = getattr(trace</span><span class="s2">, </span><span class="s3">'post_process_xmap'</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">post_process </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">NotImplementedError</span>
    <span class="s2">return </span><span class="s1">post_process(self</span><span class="s2">, </span><span class="s1">out_tracers</span><span class="s2">, </span><span class="s1">params)</span>

  <span class="s2">def </span><span class="s1">get_bind_params(self</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s1">new_params = dict(params)</span>
    <span class="s1">jaxpr = new_params.pop(</span><span class="s3">'call_jaxpr'</span><span class="s1">)</span>
    <span class="s1">subfun = lu.hashable_partial(lu.wrap_init(core.eval_jaxpr)</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">())</span>
    <span class="s1">axes = new_params.pop(</span><span class="s3">'out_axes'</span><span class="s1">)</span>
    <span class="s1">new_params[</span><span class="s3">'out_axes_thunk'</span><span class="s1">] = HashableFunction(</span><span class="s2">lambda</span><span class="s1">: axes</span><span class="s2">, </span><span class="s1">closure=axes)</span>
    <span class="s1">spmd_axes = new_params.pop(</span><span class="s3">'spmd_out_axes'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">spmd_axes </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s1">new_params[</span><span class="s3">'spmd_out_axes_thunk'</span><span class="s1">] = \</span>
          <span class="s1">HashableFunction(</span><span class="s2">lambda</span><span class="s1">: spmd_axes</span><span class="s2">, </span><span class="s1">closure=spmd_axes)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">new_params[</span><span class="s3">'spmd_out_axes_thunk'</span><span class="s1">] = </span><span class="s2">None</span>
    <span class="s2">return </span><span class="s1">[subfun]</span><span class="s2">, </span><span class="s1">new_params</span>

<span class="s1">xmap_p = XMapPrimitive()</span>
<span class="s1">core.EvalTrace.process_xmap = core.EvalTrace.process_call  </span><span class="s0"># type: ignore</span>
<span class="s2">def </span><span class="s1">_process_xmap_default(self</span><span class="s2">, </span><span class="s1">call_primitive</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params):</span>
  <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(self)</span><span class="s2">} </span><span class="s3">must override process_xmap to handle xmap&quot;</span><span class="s1">)</span>
<span class="s1">core.Trace.process_xmap = _process_xmap_default  </span><span class="s0"># type: ignore</span>

<span class="s2">def </span><span class="s1">_xmap_axis_subst(params</span><span class="s2">, </span><span class="s1">subst</span><span class="s2">, </span><span class="s1">traverse):</span>
  <span class="s2">if </span><span class="s3">'call_jaxpr' </span><span class="s2">not in </span><span class="s1">params:  </span><span class="s0"># TODO(apaszke): This feels sketchy, but I'm not sure why</span>
    <span class="s2">return </span><span class="s1">params</span>
  <span class="s2">if not </span><span class="s1">traverse:</span>
    <span class="s2">return </span><span class="s1">params</span>
  <span class="s2">def </span><span class="s1">shadowed_subst(name):</span>
    <span class="s2">return </span><span class="s1">(name</span><span class="s2">,</span><span class="s1">) </span><span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">params[</span><span class="s3">'global_axis_sizes'</span><span class="s1">] </span><span class="s2">else </span><span class="s1">subst(name)</span>
  <span class="s2">with </span><span class="s1">core.extend_axis_env_nd(params[</span><span class="s3">'global_axis_sizes'</span><span class="s1">].items()):</span>
    <span class="s1">new_jaxpr = core.subst_axis_names_jaxpr(params[</span><span class="s3">'call_jaxpr'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">shadowed_subst)</span>
  <span class="s2">return </span><span class="s1">dict(params</span><span class="s2">, </span><span class="s1">call_jaxpr=new_jaxpr)</span>
<span class="s1">core.axis_substitution_rules[xmap_p] = _xmap_axis_subst</span>

<span class="s0"># NOTE: We don't have to handle spmd_{in|out}_axes here, because</span>
<span class="s0"># SPMD batching always gets involved as the last transform before XLA translation</span>
<span class="s1">ad.JVPTrace.process_xmap = ad.JVPTrace.process_call  </span><span class="s0"># type: ignore</span>
<span class="s1">ad.call_param_updaters[xmap_p] = xla.xla_call_jvp_update_params</span>

<span class="s2">def </span><span class="s1">_xmap_transpose(params</span><span class="s2">, </span><span class="s1">call_jaxpr</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">cts_in</span><span class="s2">, </span><span class="s1">cts_in_avals</span><span class="s2">, </span><span class="s1">reduce_axes):</span>
  <span class="s1">all_args</span><span class="s2">, </span><span class="s1">in_tree_def = tree_flatten((()</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">cts_in))  </span><span class="s0"># empty consts</span>
  <span class="s1">fun = lu.hashable_partial(</span>
      <span class="s1">lu.wrap_init(ad.backward_pass)</span><span class="s2">,</span>
      <span class="s1">call_jaxpr</span><span class="s2">, </span><span class="s1">reduce_axes + tuple(params[</span><span class="s3">'global_axis_sizes'</span><span class="s1">].keys())</span><span class="s2">, False</span><span class="s1">)</span>
  <span class="s1">fun</span><span class="s2">, </span><span class="s1">nz_arg_cts = ad.nonzero_outputs(fun)</span>
  <span class="s1">fun</span><span class="s2">, </span><span class="s1">out_tree = flatten_fun_nokwargs(fun</span><span class="s2">, </span><span class="s1">in_tree_def)</span>
  <span class="s0"># Preserve axis for primal arguments, skip tangents (represented as undefined primals).</span>
  <span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes = params[</span><span class="s3">'in_axes'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'out_axes'</span><span class="s1">]</span>
  <span class="s1">new_in_axes = (*(axis </span><span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">zip(in_axes</span><span class="s2">, </span><span class="s1">args) </span><span class="s2">if not </span><span class="s1">ad.is_undefined_primal(x))</span><span class="s2">,</span>
                 <span class="s1">*(axis </span><span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">zip(out_axes</span><span class="s2">, </span><span class="s1">cts_in) </span><span class="s2">if </span><span class="s1">type(x) </span><span class="s2">is not </span><span class="s1">ad.Zero))</span>
  <span class="s0"># NOTE: This assumes that the output cotangents being zero is a deterministic</span>
  <span class="s0">#       function of which input cotangents were zero.</span>
  <span class="s1">@as_hashable_function(closure=(in_axes</span><span class="s2">, </span><span class="s1">tuple(type(c) </span><span class="s2">is </span><span class="s1">ad.Zero </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">cts_in)))</span>
  <span class="s2">def </span><span class="s1">out_axes_thunk():</span>
    <span class="s2">return </span><span class="s1">tuple(axis </span><span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">nz </span><span class="s2">in </span><span class="s1">zip(in_axes</span><span class="s2">, </span><span class="s1">nz_arg_cts()) </span><span class="s2">if </span><span class="s1">nz)</span>
  <span class="s1">new_params = dict(params</span><span class="s2">,</span>
                    <span class="s1">name=wrap_name(params[</span><span class="s3">'name'</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'transpose'</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">in_axes=new_in_axes</span><span class="s2">,</span>
                    <span class="s1">out_axes_thunk=out_axes_thunk</span><span class="s2">,</span>
                    <span class="s1">donated_invars=(</span><span class="s2">False,</span><span class="s1">) * len(new_in_axes)</span><span class="s2">,</span>
                    <span class="s1">spmd_out_axes_thunk=</span><span class="s2">None</span><span class="s1">)</span>
  <span class="s2">del </span><span class="s1">new_params[</span><span class="s3">'out_axes'</span><span class="s1">]</span>
  <span class="s2">del </span><span class="s1">new_params[</span><span class="s3">'spmd_out_axes'</span><span class="s1">]</span>
  <span class="s1">out_flat = xmap_p.bind(fun</span><span class="s2">, </span><span class="s1">*all_args</span><span class="s2">, </span><span class="s1">**new_params)</span>
  <span class="s1">arg_cts = tree_unflatten(out_tree()</span><span class="s2">, </span><span class="s1">out_flat)</span>

  <span class="s1">axis_resource_count = _get_axis_resource_count(</span>
      <span class="s1">params[</span><span class="s3">'axis_resources'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'resource_env'</span><span class="s1">])</span>
  <span class="s1">local_axis_sizes = {</span>
      <span class="s1">axis: axis_resource_count[axis].to_local(global_size)</span>
      <span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">global_size </span><span class="s2">in </span><span class="s1">params[</span><span class="s3">'global_axis_sizes'</span><span class="s1">].items()</span>
  <span class="s1">}</span>
  <span class="s2">def </span><span class="s1">unmap_zero(zero</span><span class="s2">, </span><span class="s1">axes):</span>
    <span class="s2">return </span><span class="s1">ad.Zero(_insert_aval_axes(zero.aval</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">local_axis_sizes))</span>
  <span class="s2">return </span><span class="s1">tuple(unmap_zero(arg_ct</span><span class="s2">, </span><span class="s1">in_axis) </span><span class="s2">if </span><span class="s1">type(arg_ct) </span><span class="s2">is </span><span class="s1">ad.Zero </span><span class="s2">else </span><span class="s1">arg_ct</span>
               <span class="s2">for </span><span class="s1">arg_ct</span><span class="s2">, </span><span class="s1">in_axis </span><span class="s2">in </span><span class="s1">zip(arg_cts</span><span class="s2">, </span><span class="s1">in_axes))</span>
<span class="s1">ad.primitive_transposes[xmap_p] = _xmap_transpose</span>


<span class="s2">def </span><span class="s1">_typecheck_xmap(</span>
    <span class="s1">_</span><span class="s2">, </span><span class="s1">*in_atoms</span><span class="s2">, </span><span class="s1">call_jaxpr</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">,</span>
    <span class="s1">global_axis_sizes</span><span class="s2">, </span><span class="s1">axis_resources</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">,</span>
    <span class="s1">spmd_in_axes</span><span class="s2">, </span><span class="s1">spmd_out_axes):</span>
  <span class="s1">in_avals = [x.aval </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">in_atoms]</span>
  <span class="s1">axis_resource_count = _get_axis_resource_count(</span>
      <span class="s1">axis_resources</span><span class="s2">, </span><span class="s1">resource_env)</span>
  <span class="s1">local_axis_sizes = {</span>
      <span class="s1">axis: axis_resource_count[axis].to_local(global_size)</span>
      <span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">global_size </span><span class="s2">in </span><span class="s1">global_axis_sizes.items()</span>
  <span class="s1">}</span>
  <span class="s1">binder_in_avals = [_insert_aval_axes(v.aval</span><span class="s2">, </span><span class="s1">a_in_axes</span><span class="s2">, </span><span class="s1">local_axis_sizes)</span>
                     <span class="s2">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">a_in_axes </span><span class="s2">in </span><span class="s1">zip(call_jaxpr.invars</span><span class="s2">, </span><span class="s1">in_axes)]</span>
  <span class="s2">for </span><span class="s1">binder_in_aval</span><span class="s2">, </span><span class="s1">in_aval </span><span class="s2">in </span><span class="s1">zip(binder_in_avals</span><span class="s2">, </span><span class="s1">in_avals):</span>
    <span class="s2">if not </span><span class="s1">core.typecompat(binder_in_aval</span><span class="s2">, </span><span class="s1">in_aval):</span>
      <span class="s2">raise </span><span class="s1">core.JaxprTypeError(</span>
        <span class="s3">f&quot;xmap passes operand </span><span class="s2">{</span><span class="s1">in_aval</span><span class="s2">} </span><span class="s3">to jaxpr expecting </span><span class="s2">{</span><span class="s1">binder_in_aval</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s2">with </span><span class="s1">core.extend_axis_env_nd(global_axis_sizes.items()):</span>
    <span class="s1">core._check_jaxpr(</span><span class="s2">lambda</span><span class="s1">: core.JaxprPpContext()</span><span class="s2">, </span><span class="s1">call_jaxpr)</span>

  <span class="s1">mapped_out_avals = [v.aval </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">call_jaxpr.outvars]</span>
  <span class="s1">out_avals = [_insert_aval_axes(a</span><span class="s2">, </span><span class="s1">a_out_axes</span><span class="s2">, </span><span class="s1">local_axis_sizes)</span>
               <span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">a_out_axes </span><span class="s2">in </span><span class="s1">zip(mapped_out_avals</span><span class="s2">, </span><span class="s1">out_axes)]</span>
  <span class="s2">return </span><span class="s1">out_avals</span><span class="s2">, </span><span class="s1">call_jaxpr.effects</span>
<span class="s1">core.custom_typechecks[xmap_p] = _typecheck_xmap</span>


<span class="s2">def </span><span class="s1">_resource_typing_xmap(avals</span><span class="s2">,</span>
                          <span class="s1">params</span><span class="s2">,</span>
                          <span class="s1">source_info: source_info_util.SourceInfo</span><span class="s2">,</span>
                          <span class="s1">resource_env</span><span class="s2">,</span>
                          <span class="s1">outer_axis_resources):</span>
  <span class="s1">axis_resources = params[</span><span class="s3">'axis_resources'</span><span class="s1">]</span>
  <span class="s1">inner_axis_resources = dict(outer_axis_resources)</span>
  <span class="s1">inner_axis_resources.update(axis_resources)</span>
  <span class="s2">if </span><span class="s1">len(inner_axis_resources) &lt; len(outer_axis_resources) + len(axis_resources):</span>
    <span class="s1">overlap = set(outer_axis_resources) &amp; set(axis_resources)</span>
    <span class="s2">raise </span><span class="s1">JAXTypeError(</span>
        <span class="s3">f&quot;Detected disallowed xmap axis name shadowing at &quot;</span>
        <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">source_info_util.summarize(source_info)</span><span class="s2">} </span><span class="s3">&quot;</span>
        <span class="s3">f&quot;(shadowed axes: </span><span class="s2">{</span><span class="s1">mesh_lib.show_axes(overlap)</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">)</span>

  <span class="s2">if </span><span class="s1">resource_env.physical_mesh != params[</span><span class="s3">'resource_env'</span><span class="s1">].physical_mesh:</span>
    <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Changing the physical mesh is not allowed inside xmap.&quot;</span><span class="s1">)</span>

  <span class="s1">call_jaxpr = params[</span><span class="s3">'call_jaxpr'</span><span class="s1">]</span>
  <span class="s1">pxla.resource_typecheck(</span>
      <span class="s1">params[</span><span class="s3">'call_jaxpr'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">inner_axis_resources</span><span class="s2">,</span>
      <span class="s2">lambda</span><span class="s1">: (</span><span class="s3">f&quot;an xmapped function </span><span class="s2">{</span><span class="s1">params[</span><span class="s3">'name'</span><span class="s1">]</span><span class="s2">} </span><span class="s3">&quot; </span><span class="s1">+</span>
               <span class="s1">(</span><span class="s3">f&quot;(xmap called at </span><span class="s2">{</span><span class="s1">source_info_util.summarize(source_info)</span><span class="s2">}</span><span class="s3">)&quot;</span>
                <span class="s2">if </span><span class="s1">source_info </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s1">)))</span>

  <span class="s2">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">axes </span><span class="s2">in </span><span class="s1">zip(call_jaxpr.outvars</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'out_axes'</span><span class="s1">]):</span>
    <span class="s1">broadcast_axes = set(axes) - set(v.aval.named_shape)</span>
    <span class="s1">used_resources = set(it.chain.from_iterable(</span>
        <span class="s1">inner_axis_resources[a] </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">v.aval.named_shape))</span>
    <span class="s2">for </span><span class="s1">baxis </span><span class="s2">in </span><span class="s1">broadcast_axes:</span>
      <span class="s1">baxis_resources = set(inner_axis_resources[baxis])</span>
      <span class="s1">overlap = baxis_resources &amp; used_resources</span>
      <span class="s2">if </span><span class="s1">overlap:</span>
        <span class="s1">resource_to_axis = {}</span>
        <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">v.aval.named_shape:</span>
          <span class="s2">for </span><span class="s1">raxis </span><span class="s2">in </span><span class="s1">inner_axis_resources[axis]:</span>
            <span class="s1">resource_to_axis[raxis] = axis</span>
        <span class="s1">partitioning_axes = {resource_to_axis[raxis] </span><span class="s2">for </span><span class="s1">raxis </span><span class="s2">in </span><span class="s1">overlap}</span>
        <span class="s2">raise </span><span class="s1">JAXTypeError(</span>
            <span class="s3">f&quot;One of xmapped function (</span><span class="s2">{</span><span class="s1">params[</span><span class="s3">'name'</span><span class="s1">]</span><span class="s2">}</span><span class="s3">) outputs is broadcast &quot;</span>
            <span class="s3">f&quot;along axis `</span><span class="s2">{</span><span class="s1">baxis</span><span class="s2">}</span><span class="s3">` which is assigned to resources &quot;</span>
            <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">mesh_lib.show_axes(baxis_resources)</span><span class="s2">}</span><span class="s3">, but the output is already &quot;</span>
            <span class="s3">f&quot;partitioned along </span><span class="s2">{</span><span class="s1">mesh_lib.show_axes(overlap)</span><span class="s2">}</span><span class="s3">, because its &quot;</span>
            <span class="s3">f&quot;named shape contains </span><span class="s2">{</span><span class="s1">mesh_lib.show_axes(partitioning_axes)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
<span class="s1">pxla.custom_resource_typing_rules[xmap_p] = _resource_typing_xmap</span>


<span class="s0"># This is DynamicJaxprTrace.process_map with some very minor modifications</span>
<span class="s2">def </span><span class="s1">_dynamic_jaxpr_process_xmap(self</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params):</span>
  <span class="s2">assert </span><span class="s1">primitive </span><span class="s2">is </span><span class="s1">xmap_p</span>
  <span class="s1">in_avals = [t.aval </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">tracers]</span>
  <span class="s1">global_axis_sizes = params[</span><span class="s3">'global_axis_sizes'</span><span class="s1">]</span>
  <span class="s1">mapped_in_avals = [_delete_aval_axes(a</span><span class="s2">, </span><span class="s1">a_in_axes</span><span class="s2">, </span><span class="s1">global_axis_sizes)</span>
                     <span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">a_in_axes </span><span class="s2">in </span><span class="s1">zip(in_avals</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'in_axes'</span><span class="s1">])]</span>
  <span class="s2">with </span><span class="s1">core.extend_axis_env_nd(global_axis_sizes.items()):</span>
    <span class="s2">with </span><span class="s1">core.new_sublevel():</span>
      <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">mapped_out_avals</span><span class="s2">, </span><span class="s1">consts = trace_to_subjaxpr_dynamic(</span>
          <span class="s1">f</span><span class="s2">, </span><span class="s1">self.main</span><span class="s2">, </span><span class="s1">mapped_in_avals)</span>
  <span class="s1">out_axes = params[</span><span class="s3">'out_axes_thunk'</span><span class="s1">]()</span>
  <span class="s2">if </span><span class="s1">params[</span><span class="s3">'spmd_out_axes_thunk'</span><span class="s1">] </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s1">spmd_out_axes = params[</span><span class="s3">'spmd_out_axes_thunk'</span><span class="s1">]()</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">spmd_out_axes = </span><span class="s2">None</span>
  <span class="s1">axis_resource_count = _get_axis_resource_count(</span>
      <span class="s1">params[</span><span class="s3">'axis_resources'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'resource_env'</span><span class="s1">])</span>
  <span class="s1">local_axis_sizes = {</span>
      <span class="s1">axis: axis_resource_count[axis].to_local(global_size)</span>
      <span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">global_size </span><span class="s2">in </span><span class="s1">global_axis_sizes.items()</span>
  <span class="s1">}</span>
  <span class="s1">out_avals = [_insert_aval_axes(a</span><span class="s2">, </span><span class="s1">a_out_axes</span><span class="s2">, </span><span class="s1">local_axis_sizes)</span>
               <span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">a_out_axes </span><span class="s2">in </span><span class="s1">zip(mapped_out_avals</span><span class="s2">, </span><span class="s1">out_axes)]</span>
  <span class="s1">_check_out_avals_vs_out_axes(out_avals</span><span class="s2">, </span><span class="s1">out_axes</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'global_axis_sizes'</span><span class="s1">])</span>
  <span class="s1">source_info = source_info_util.current()</span>
  <span class="s1">out_tracers = [DynamicJaxprTracer(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">source_info) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">out_avals]</span>
  <span class="s1">invars = map(self.getvar</span><span class="s2">, </span><span class="s1">tracers)</span>
  <span class="s1">constvars = map(self.getvar</span><span class="s2">, </span><span class="s1">map(self.instantiate_const</span><span class="s2">, </span><span class="s1">consts))</span>
  <span class="s1">outvars = map(self.makevar</span><span class="s2">, </span><span class="s1">out_tracers)</span>
  <span class="s1">new_in_axes = (AxisNamePos(user_repr=</span><span class="s3">'{}'</span><span class="s1">)</span><span class="s2">,</span><span class="s1">) * len(consts) + params[</span><span class="s3">'in_axes'</span><span class="s1">]</span>
  <span class="s2">if </span><span class="s1">params[</span><span class="s3">'spmd_in_axes'</span><span class="s1">] </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">new_spmd_in_axes = </span><span class="s2">None</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">new_spmd_in_axes = (</span><span class="s2">None,</span><span class="s1">) * len(consts) + params[</span><span class="s3">'spmd_in_axes'</span><span class="s1">]</span>
  <span class="s1">new_donated_invars = (</span><span class="s2">False,</span><span class="s1">) * len(consts) + params[</span><span class="s3">'donated_invars'</span><span class="s1">]</span>
  <span class="s2">with </span><span class="s1">core.extend_axis_env_nd(global_axis_sizes.items()):</span>
    <span class="s1">call_jaxpr = convert_constvars_jaxpr(jaxpr)</span>
  <span class="s1">new_params = dict(params</span><span class="s2">, </span><span class="s1">in_axes=new_in_axes</span><span class="s2">, </span><span class="s1">out_axes=out_axes</span><span class="s2">,</span>
                    <span class="s1">donated_invars=new_donated_invars</span><span class="s2">,</span>
                    <span class="s1">spmd_in_axes=new_spmd_in_axes</span><span class="s2">,</span>
                    <span class="s1">spmd_out_axes=spmd_out_axes</span><span class="s2">,</span>
                    <span class="s1">call_jaxpr=call_jaxpr)</span>
  <span class="s2">del </span><span class="s1">new_params[</span><span class="s3">'out_axes_thunk'</span><span class="s1">]</span>
  <span class="s2">del </span><span class="s1">new_params[</span><span class="s3">'spmd_out_axes_thunk'</span><span class="s1">]</span>
  <span class="s1">eqn = new_jaxpr_eqn([*constvars</span><span class="s2">, </span><span class="s1">*invars]</span><span class="s2">, </span><span class="s1">outvars</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">,</span>
                      <span class="s1">new_params</span><span class="s2">, </span><span class="s1">call_jaxpr.effects</span><span class="s2">, </span><span class="s1">source_info)</span>
  <span class="s1">self.frame.add_eqn(eqn)</span>
  <span class="s2">return </span><span class="s1">out_tracers</span>
<span class="s1">pe.DynamicJaxprTrace.process_xmap = _dynamic_jaxpr_process_xmap  </span><span class="s0"># type: ignore</span>

<span class="s2">def </span><span class="s1">_xmap_partial_eval_custom_params_updater(</span>
    <span class="s1">unks_in: Sequence[bool]</span><span class="s2">, </span><span class="s1">inst_in: Sequence[bool]</span><span class="s2">,</span>
    <span class="s1">kept_outs_known: Sequence[bool]</span><span class="s2">, </span><span class="s1">kept_outs_staged: Sequence[bool]</span><span class="s2">,</span>
    <span class="s1">num_res: int</span><span class="s2">, </span><span class="s1">params_known: dict</span><span class="s2">, </span><span class="s1">params_staged: dict</span>
  <span class="s1">) -&gt; Tuple[dict</span><span class="s2">, </span><span class="s1">dict]:</span>
  <span class="s2">assert </span><span class="s1">params_known[</span><span class="s3">'spmd_in_axes'</span><span class="s1">] </span><span class="s2">is None is </span><span class="s1">params_known[</span><span class="s3">'spmd_out_axes'</span><span class="s1">]</span>
  <span class="s2">assert </span><span class="s1">params_staged[</span><span class="s3">'spmd_in_axes'</span><span class="s1">] </span><span class="s2">is None is </span><span class="s1">params_staged[</span><span class="s3">'spmd_out_axes'</span><span class="s1">]</span>

  <span class="s0"># prune inputs to jaxpr_known according to unks_in</span>
  <span class="s1">donated_invars_known</span><span class="s2">, </span><span class="s1">_ = pe.partition_list(unks_in</span><span class="s2">, </span><span class="s1">params_known[</span><span class="s3">'donated_invars'</span><span class="s1">])</span>
  <span class="s1">in_axes_known</span><span class="s2">, </span><span class="s1">_ = pe.partition_list(unks_in</span><span class="s2">, </span><span class="s1">params_known[</span><span class="s3">'in_axes'</span><span class="s1">])</span>
  <span class="s2">if </span><span class="s1">num_res == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s1">residual_axes = []</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">residual_axes = [</span>
      <span class="s1">AxisNamePos(zip(sort_named_shape</span><span class="s2">, </span><span class="s1">range(len(sort_named_shape)))</span><span class="s2">,</span>
                  <span class="s1">user_repr=</span><span class="s3">f'&lt;internal: </span><span class="s2">{</span><span class="s1">sort_named_shape</span><span class="s2">}</span><span class="s3">&gt;'</span><span class="s1">)</span>
      <span class="s2">for </span><span class="s1">named_shape </span><span class="s2">in </span><span class="s1">(v.aval.named_shape </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">params_known[</span><span class="s3">'call_jaxpr'</span><span class="s1">].outvars[:-num_res])</span>
      <span class="s0"># We sort here to make the iteration order deterministic</span>
      <span class="s2">for </span><span class="s1">sort_named_shape </span><span class="s2">in </span><span class="s1">[sorted(named_shape</span><span class="s2">, </span><span class="s1">key=str)]</span>
    <span class="s1">]</span>
  <span class="s1">_</span><span class="s2">, </span><span class="s1">out_axes_known = pe.partition_list(kept_outs_known</span><span class="s2">, </span><span class="s1">params_known[</span><span class="s3">'out_axes'</span><span class="s1">])</span>
  <span class="s1">new_params_known = dict(params_known</span><span class="s2">,</span>
                          <span class="s1">in_axes=tuple(in_axes_known)</span><span class="s2">,</span>
                          <span class="s1">out_axes=(*out_axes_known</span><span class="s2">, </span><span class="s1">*residual_axes)</span><span class="s2">,</span>
                          <span class="s1">donated_invars=tuple(donated_invars_known))</span>
  <span class="s2">assert </span><span class="s1">len(new_params_known[</span><span class="s3">'in_axes'</span><span class="s1">]) == len(params_known[</span><span class="s3">'call_jaxpr'</span><span class="s1">].invars)</span>
  <span class="s2">assert </span><span class="s1">len(new_params_known[</span><span class="s3">'out_axes'</span><span class="s1">]) == len(params_known[</span><span class="s3">'call_jaxpr'</span><span class="s1">].outvars)</span>

  <span class="s0"># added num_res new inputs to jaxpr_staged, and pruning according to inst_in</span>
  <span class="s1">_</span><span class="s2">, </span><span class="s1">donated_invars_staged = pe.partition_list(inst_in</span><span class="s2">, </span><span class="s1">params_staged[</span><span class="s3">'donated_invars'</span><span class="s1">])</span>
  <span class="s1">donated_invars_staged = [</span><span class="s2">False</span><span class="s1">] * num_res + donated_invars_staged</span>
  <span class="s1">_</span><span class="s2">, </span><span class="s1">in_axes_staged = pe.partition_list(inst_in</span><span class="s2">, </span><span class="s1">params_staged[</span><span class="s3">'in_axes'</span><span class="s1">])</span>
  <span class="s1">in_axes_staged = [*residual_axes</span><span class="s2">, </span><span class="s1">*in_axes_staged]</span>
  <span class="s1">_</span><span class="s2">, </span><span class="s1">out_axes_staged = pe.partition_list(kept_outs_staged</span><span class="s2">, </span><span class="s1">params_staged[</span><span class="s3">'out_axes'</span><span class="s1">])</span>
  <span class="s1">new_params_staged = dict(params_staged</span><span class="s2">, </span><span class="s1">in_axes=tuple(in_axes_staged)</span><span class="s2">,</span>
                           <span class="s1">out_axes=tuple(out_axes_staged)</span><span class="s2">,</span>
                           <span class="s1">donated_invars=tuple(donated_invars_staged))</span>
  <span class="s2">assert </span><span class="s1">len(new_params_staged[</span><span class="s3">'in_axes'</span><span class="s1">]) == len(params_staged[</span><span class="s3">'call_jaxpr'</span><span class="s1">].invars)</span>
  <span class="s2">assert </span><span class="s1">len(new_params_staged[</span><span class="s3">'out_axes'</span><span class="s1">]) == len(params_staged[</span><span class="s3">'call_jaxpr'</span><span class="s1">].outvars)</span>
  <span class="s2">return </span><span class="s1">new_params_known</span><span class="s2">, </span><span class="s1">new_params_staged</span>
<span class="s1">pe.partial_eval_jaxpr_custom_rules[xmap_p] = \</span>
    <span class="s1">partial(pe.call_partial_eval_custom_rule</span><span class="s2">, </span><span class="s3">'call_jaxpr'</span><span class="s2">,</span>
            <span class="s1">_xmap_partial_eval_custom_params_updater)</span>


<span class="s1">@lu.transformation_with_aux</span>
<span class="s2">def </span><span class="s1">out_local_named_shapes(local_axes</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
  <span class="s1">ans = </span><span class="s2">yield </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span>
  <span class="s1">ans_axes = [frozenset(a.aval.named_shape) &amp; local_axes </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">ans]</span>
  <span class="s2">yield </span><span class="s1">ans</span><span class="s2">, </span><span class="s1">ans_axes</span>


<span class="s2">def </span><span class="s1">_jaxpr_trace_process_xmap(self</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">f: lu.WrappedFun</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params):</span>
  <span class="s2">assert </span><span class="s1">primitive </span><span class="s2">is </span><span class="s1">xmap_p</span>
  <span class="s2">assert </span><span class="s1">params[</span><span class="s3">'spmd_out_axes_thunk'</span><span class="s1">] </span><span class="s2">is </span><span class="s1">params[</span><span class="s3">'spmd_in_axes'</span><span class="s1">] </span><span class="s2">is None</span>
  <span class="s1">in_axes = params[</span><span class="s3">'in_axes'</span><span class="s1">]</span>
  <span class="s1">donated_invars = params[</span><span class="s3">'donated_invars'</span><span class="s1">]</span>
  <span class="s1">global_axis_sizes = params[</span><span class="s3">'global_axis_sizes'</span><span class="s1">]</span>
  <span class="s1">out_axes_thunk = params[</span><span class="s3">'out_axes_thunk'</span><span class="s1">]</span>

  <span class="s0"># Adjust input tracers' pvals for mapped axes, and unpack.</span>
  <span class="s1">in_pvals = [t.pval </span><span class="s2">if </span><span class="s1">t.pval.is_known() </span><span class="s2">else</span>
              <span class="s1">pe.PartialVal.unknown(</span>
                  <span class="s1">_delete_aval_axes(t.pval.get_aval()</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">global_axis_sizes))</span>
              <span class="s2">for </span><span class="s1">t</span><span class="s2">, </span><span class="s1">axes </span><span class="s2">in </span><span class="s1">zip(tracers</span><span class="s2">, </span><span class="s1">in_axes)]</span>
  <span class="s1">in_knowns</span><span class="s2">, </span><span class="s1">in_avals</span><span class="s2">, </span><span class="s1">in_consts = pe.partition_pvals(in_pvals)</span>

  <span class="s0"># Wrap f to perform partial evaluation, and plumb out aux data.</span>
  <span class="s1">f = pe.trace_to_subjaxpr_nounits(f</span><span class="s2">, </span><span class="s1">self.main</span><span class="s2">, False</span><span class="s1">)</span>
  <span class="s1">f</span><span class="s2">, </span><span class="s1">aux = pe.partial_eval_wrapper_nounits(f</span><span class="s2">, </span><span class="s1">tuple(in_knowns)</span><span class="s2">, </span><span class="s1">tuple(in_avals))</span>
  <span class="s0"># Also grab the local named shapes of the output (known and res).</span>
  <span class="s1">f</span><span class="s2">, </span><span class="s1">out_named_shapes = out_local_named_shapes(f</span><span class="s2">, </span><span class="s1">frozenset(global_axis_sizes))</span>

  <span class="s0"># Adjust params for knowns (donated_invars, in_axes, out_axes_thunk).</span>
  <span class="s1">out_axes = </span><span class="s2">None  </span><span class="s0"># cache this to avoid calling out_axes_thunk() more than once</span>

  <span class="s1">@as_hashable_function(closure=out_axes_thunk)</span>
  <span class="s2">def </span><span class="s1">new_out_axes_thunk():</span>
    <span class="s2">nonlocal </span><span class="s1">out_axes</span>
    <span class="s1">out_axes = out_axes_thunk()</span>
    <span class="s1">out_knowns</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = aux()</span>
    <span class="s1">_</span><span class="s2">, </span><span class="s1">out_axes_known = partition_list(out_knowns</span><span class="s2">, </span><span class="s1">out_axes)</span>
    <span class="s2">return </span><span class="s1">(*out_axes_known</span><span class="s2">, </span><span class="s1">*res_axes())</span>
  <span class="s2">def </span><span class="s1">res_axes():</span>
    <span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">jaxpr_unknown</span><span class="s2">, </span><span class="s1">_ = aux()</span>
    <span class="s1">num_res = len(jaxpr_unknown.constvars)</span>
    <span class="s1">res_named_shapes = out_named_shapes()[-num_res:] </span><span class="s2">if </span><span class="s1">num_res </span><span class="s2">else </span><span class="s1">[]</span>
    <span class="s1">sorted_named_shapes = [sorted(ns</span><span class="s2">, </span><span class="s1">key=str) </span><span class="s2">for </span><span class="s1">ns </span><span class="s2">in </span><span class="s1">res_named_shapes]</span>
    <span class="s2">return </span><span class="s1">[AxisNamePos(zip(named_shape</span><span class="s2">, </span><span class="s1">range(len(named_shape)))</span><span class="s2">,</span>
                        <span class="s1">user_repr=</span><span class="s3">f'&lt;internal: </span><span class="s2">{</span><span class="s1">named_shape</span><span class="s2">}</span><span class="s3">&gt;'</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">named_shape </span><span class="s2">in </span><span class="s1">sorted_named_shapes]</span>
  <span class="s1">known_params = dict(</span>
      <span class="s1">params</span><span class="s2">, </span><span class="s1">in_axes=tuple(a </span><span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">k </span><span class="s2">in </span><span class="s1">zip(in_axes</span><span class="s2">, </span><span class="s1">in_knowns) </span><span class="s2">if </span><span class="s1">k)</span><span class="s2">,</span>
      <span class="s1">donated_invars=tuple(d </span><span class="s2">for </span><span class="s1">d</span><span class="s2">, </span><span class="s1">k </span><span class="s2">in </span><span class="s1">zip(donated_invars</span><span class="s2">, </span><span class="s1">in_knowns) </span><span class="s2">if </span><span class="s1">k)</span><span class="s2">,</span>
      <span class="s1">out_axes_thunk=new_out_axes_thunk)</span>

  <span class="s0"># Run the known part.</span>
  <span class="s1">out = primitive.bind(f</span><span class="s2">, </span><span class="s1">*in_consts</span><span class="s2">, </span><span class="s1">**known_params)</span>
  <span class="s1">out_knowns</span><span class="s2">, </span><span class="s1">out_avals</span><span class="s2">, </span><span class="s1">jaxpr_unknown</span><span class="s2">, </span><span class="s1">env = aux()</span>
  <span class="s1">known_outvals</span><span class="s2">, </span><span class="s1">res = split_list(out</span><span class="s2">, </span><span class="s1">[len(out)-len(jaxpr_unknown.constvars)])</span>
  <span class="s2">with </span><span class="s1">core.extend_axis_env_nd(global_axis_sizes.items()):</span>
    <span class="s1">jaxpr_unknown = pe.convert_constvars_jaxpr(jaxpr_unknown)</span>

  <span class="s0"># Set up new params.</span>
  <span class="s2">if </span><span class="s1">out_axes </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">out_axes = out_axes_thunk()  </span><span class="s0"># new_out_axes_thunk may have set during bind</span>
  <span class="s1">out_axes_unknown = [a </span><span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">k </span><span class="s2">in </span><span class="s1">zip(out_axes</span><span class="s2">, </span><span class="s1">out_knowns) </span><span class="s2">if not </span><span class="s1">k]</span>
  <span class="s1">unknown_params = dict(</span>
      <span class="s1">params</span><span class="s2">, </span><span class="s1">call_jaxpr=jaxpr_unknown</span><span class="s2">, </span><span class="s1">out_axes=tuple(out_axes_unknown)</span><span class="s2">,</span>
      <span class="s1">spmd_out_axes=</span><span class="s2">None,</span>
      <span class="s1">donated_invars=(*(</span><span class="s2">False for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">res)</span><span class="s2">,</span>
                      <span class="s1">*(d </span><span class="s2">for </span><span class="s1">d</span><span class="s2">, </span><span class="s1">k </span><span class="s2">in </span><span class="s1">zip(donated_invars</span><span class="s2">, </span><span class="s1">in_knowns) </span><span class="s2">if not </span><span class="s1">k))</span><span class="s2">,</span>
      <span class="s1">in_axes=(*res_axes()</span><span class="s2">, </span><span class="s1">*(</span><span class="s2">None for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">env)</span><span class="s2">,</span>
               <span class="s1">*(a </span><span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">k </span><span class="s2">in </span><span class="s1">zip(in_axes</span><span class="s2">, </span><span class="s1">in_knowns) </span><span class="s2">if not </span><span class="s1">k)))</span>
  <span class="s2">del </span><span class="s1">unknown_params[</span><span class="s3">'out_axes_thunk'</span><span class="s1">]</span>
  <span class="s2">del </span><span class="s1">unknown_params[</span><span class="s3">'spmd_out_axes_thunk'</span><span class="s1">]</span>
  <span class="s0"># Create input tracers for unknown part.</span>
  <span class="s1">res_tracers = map(self.new_instantiated_const</span><span class="s2">, </span><span class="s1">res)</span>
  <span class="s1">env_tracers = map(self.full_raise</span><span class="s2">, </span><span class="s1">env)</span>
  <span class="s1">unknown_arg_tracers = [t </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">tracers </span><span class="s2">if not </span><span class="s1">t.pval.is_known()]</span>
  <span class="s0"># Create output tracers for unknown part, adjusting avals.</span>
  <span class="s1">axis_resource_count = _get_axis_resource_count(</span>
      <span class="s1">params[</span><span class="s3">'axis_resources'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'resource_env'</span><span class="s1">])</span>
  <span class="s1">local_axis_sizes = {</span>
      <span class="s1">ax: axis_resource_count[ax].to_local(global_size)</span>
      <span class="s2">for </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">global_size </span><span class="s2">in </span><span class="s1">global_axis_sizes.items()}</span>
  <span class="s1">out_pvals = [pe.PartialVal.unknown(_insert_aval_axes(a</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">local_axis_sizes))</span>
               <span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">zip(out_avals</span><span class="s2">, </span><span class="s1">out_axes_unknown)]</span>
  <span class="s1">unknown_tracers_out = [pe.JaxprTracer(self</span><span class="s2">, </span><span class="s1">pval</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">for </span><span class="s1">pval </span><span class="s2">in </span><span class="s1">out_pvals]</span>
  <span class="s0"># Build eqn to be staged out and attach it to unknown output tracers.</span>
  <span class="s1">eqn = pe.new_eqn_recipe((*res_tracers</span><span class="s2">, </span><span class="s1">*env_tracers</span><span class="s2">, </span><span class="s1">*unknown_arg_tracers)</span><span class="s2">,</span>
                          <span class="s1">unknown_tracers_out</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">unknown_params</span><span class="s2">,</span>
                          <span class="s1">jaxpr_unknown.effects</span><span class="s2">, </span><span class="s1">source_info_util.current())</span>
  <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">unknown_tracers_out: t.recipe = eqn</span>
  <span class="s2">return </span><span class="s1">merge_lists(out_knowns</span><span class="s2">, </span><span class="s1">unknown_tracers_out</span><span class="s2">, </span><span class="s1">known_outvals)</span>
<span class="s1">pe.JaxprTrace.process_xmap = _jaxpr_trace_process_xmap</span>

<span class="s2">def </span><span class="s1">_batch_trace_update_spmd_axes(</span>
    <span class="s1">spmd_in_axes</span><span class="s2">, </span><span class="s1">spmd_out_axes_thunk</span><span class="s2">,</span>
    <span class="s1">axis_name</span><span class="s2">, </span><span class="s1">dims</span><span class="s2">, </span><span class="s1">dims_out_thunk):</span>
  <span class="s4">&quot;&quot;&quot;Extends spmd in and out axes with the position of the trace's batch dimension.&quot;&quot;&quot;</span>
  <span class="s1">not_mapped = batching.not_mapped</span>
  <span class="s2">def </span><span class="s1">insert_spmd_axis(axes</span><span class="s2">, </span><span class="s1">nd):</span>
    <span class="s1">too_short = nd - len(axes)</span>
    <span class="s2">if </span><span class="s1">too_short &gt; </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">axes += (</span><span class="s2">None,</span><span class="s1">) * too_short</span>
    <span class="s2">return </span><span class="s1">tuple_insert(axes</span><span class="s2">, </span><span class="s1">nd</span><span class="s2">, </span><span class="s1">axis_name)</span>

  <span class="s2">if </span><span class="s1">spmd_in_axes </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">spmd_in_axes = (()</span><span class="s2">,</span><span class="s1">) * len(dims)</span>
  <span class="s1">new_spmd_in_axes = tuple(</span>
    <span class="s1">spmd_axes </span><span class="s2">if </span><span class="s1">d </span><span class="s2">is </span><span class="s1">not_mapped </span><span class="s2">else </span><span class="s1">insert_spmd_axis(spmd_axes</span><span class="s2">, </span><span class="s1">d)</span>
    <span class="s2">for </span><span class="s1">spmd_axes</span><span class="s2">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">zip(spmd_in_axes</span><span class="s2">, </span><span class="s1">dims))</span>

  <span class="s1">@as_hashable_function(closure=spmd_out_axes_thunk)</span>
  <span class="s2">def </span><span class="s1">new_spmd_out_axes_thunk():</span>
    <span class="s1">dims_out = dims_out_thunk()</span>
    <span class="s2">if </span><span class="s1">spmd_out_axes_thunk </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s1">spmd_out_axes = (()</span><span class="s2">,</span><span class="s1">) * len(dims_out)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">spmd_out_axes = spmd_out_axes_thunk()</span>
    <span class="s2">return </span><span class="s1">tuple(</span>
      <span class="s1">spmd_out_axes </span><span class="s2">if </span><span class="s1">nd </span><span class="s2">is </span><span class="s1">not_mapped </span><span class="s2">else </span><span class="s1">insert_spmd_axis(spmd_out_axes</span><span class="s2">, </span><span class="s1">nd)</span>
      <span class="s2">for </span><span class="s1">spmd_out_axes</span><span class="s2">, </span><span class="s1">nd </span><span class="s2">in </span><span class="s1">zip(spmd_out_axes</span><span class="s2">, </span><span class="s1">dims_out))</span>

  <span class="s2">return </span><span class="s1">new_spmd_in_axes</span><span class="s2">, </span><span class="s1">new_spmd_out_axes_thunk</span>

<span class="s2">def </span><span class="s1">_axis_after_insertion(axis</span><span class="s2">, </span><span class="s1">inserted_named_axes):</span>
  <span class="s2">for </span><span class="s1">inserted_axis </span><span class="s2">in </span><span class="s1">sorted(inserted_named_axes.values()):</span>
    <span class="s2">if </span><span class="s1">inserted_axis &gt;= axis:</span>
      <span class="s2">break</span>
    <span class="s1">axis += </span><span class="s5">1</span>
  <span class="s2">return </span><span class="s1">axis</span>

<span class="s2">def </span><span class="s1">_fmap_dims(axes</span><span class="s2">, </span><span class="s1">f):</span>
  <span class="s2">return </span><span class="s1">AxisNamePos(((name</span><span class="s2">, </span><span class="s1">f(axis)) </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">axes.items())</span><span class="s2">,</span>
                     <span class="s1">user_repr=axes.user_repr)</span>

<span class="s2">def </span><span class="s1">_batch_trace_process_xmap(self</span><span class="s2">, </span><span class="s1">is_spmd</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">f: lu.WrappedFun</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params):</span>
  <span class="s1">not_mapped = batching.not_mapped</span>
  <span class="s1">vals</span><span class="s2">, </span><span class="s1">dims = unzip2((t.val</span><span class="s2">, </span><span class="s1">t.batch_dim) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">tracers)</span>
  <span class="s2">assert </span><span class="s1">primitive </span><span class="s2">is </span><span class="s1">xmap_p</span>
  <span class="s2">if not </span><span class="s1">is_spmd </span><span class="s2">and </span><span class="s1">all(dim </span><span class="s2">is </span><span class="s1">not_mapped </span><span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">dims):</span>
    <span class="s2">return </span><span class="s1">primitive.bind(f</span><span class="s2">, </span><span class="s1">*vals</span><span class="s2">, </span><span class="s1">**params)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">assert </span><span class="s1">len({x.shape[d] </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">zip(vals</span><span class="s2">, </span><span class="s1">dims) </span><span class="s2">if </span><span class="s1">d </span><span class="s2">is not </span><span class="s1">not_mapped}) == </span><span class="s5">1</span>
    <span class="s1">new_in_axes = tuple(</span>
      <span class="s1">_fmap_dims(in_axes</span><span class="s2">, lambda </span><span class="s1">a: a + (d </span><span class="s2">is not </span><span class="s1">not_mapped </span><span class="s2">and </span><span class="s1">d &lt;= a))</span>
      <span class="s2">for </span><span class="s1">d</span><span class="s2">, </span><span class="s1">in_axes </span><span class="s2">in </span><span class="s1">zip(dims</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'in_axes'</span><span class="s1">]))</span>
    <span class="s1">mapped_dims_in = tuple(</span>
      <span class="s1">d </span><span class="s2">if </span><span class="s1">d </span><span class="s2">is </span><span class="s1">not_mapped </span><span class="s2">else </span><span class="s1">d - sum(a &lt; d </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">in_axis.values())</span>
      <span class="s2">for </span><span class="s1">d</span><span class="s2">, </span><span class="s1">in_axis </span><span class="s2">in </span><span class="s1">zip(dims</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'in_axes'</span><span class="s1">]))</span>
    <span class="s1">f</span><span class="s2">, </span><span class="s1">mapped_dims_out = batching.batch_subtrace(f</span><span class="s2">, </span><span class="s1">self.main</span><span class="s2">, </span><span class="s1">mapped_dims_in)</span>
    <span class="s1">out_axes_thunk: Callable[[]</span><span class="s2">, </span><span class="s1">Sequence[AxisNamePos]] = params[</span><span class="s3">'out_axes_thunk'</span><span class="s1">]</span>
    <span class="s1">dims_out_thunk = </span><span class="s2">lambda</span><span class="s1">: tuple(d </span><span class="s2">if </span><span class="s1">d </span><span class="s2">is </span><span class="s1">not_mapped </span><span class="s2">else </span><span class="s1">_axis_after_insertion(d</span><span class="s2">, </span><span class="s1">out_axes)</span>
                                   <span class="s2">for </span><span class="s1">d</span><span class="s2">, </span><span class="s1">out_axes </span><span class="s2">in </span><span class="s1">zip(mapped_dims_out()</span><span class="s2">, </span><span class="s1">out_axes_thunk()))</span>
    <span class="s0"># NOTE: This assumes that the choice of the dimensions over which outputs</span>
    <span class="s0">#       are batched is entirely dependent on the function and not e.g. on the</span>
    <span class="s0">#       data or its shapes.</span>
    <span class="s1">@as_hashable_function(closure=out_axes_thunk)</span>
    <span class="s2">def </span><span class="s1">new_out_axes_thunk():</span>
      <span class="s2">return </span><span class="s1">tuple(</span>
        <span class="s1">out_axes </span><span class="s2">if </span><span class="s1">d </span><span class="s2">is </span><span class="s1">not_mapped </span><span class="s2">else</span>
        <span class="s1">_fmap_dims(out_axes</span><span class="s2">, lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">nd=_axis_after_insertion(d</span><span class="s2">, </span><span class="s1">out_axes): a + (nd &lt;= a))</span>
        <span class="s2">for </span><span class="s1">out_axes</span><span class="s2">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">zip(out_axes_thunk()</span><span class="s2">, </span><span class="s1">mapped_dims_out()))</span>

    <span class="s2">if not </span><span class="s1">is_spmd:</span>
      <span class="s2">assert </span><span class="s1">params[</span><span class="s3">'spmd_in_axes'</span><span class="s1">] </span><span class="s2">is None and </span><span class="s1">params[</span><span class="s3">'spmd_out_axes_thunk'</span><span class="s1">] </span><span class="s2">is None</span>
      <span class="s1">new_spmd_in_axes = </span><span class="s2">None</span>
      <span class="s1">new_spmd_out_axes_thunk = </span><span class="s2">None</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">new_spmd_in_axes</span><span class="s2">, </span><span class="s1">new_spmd_out_axes_thunk = _batch_trace_update_spmd_axes(</span>
        <span class="s1">params[</span><span class="s3">'spmd_in_axes'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'spmd_out_axes_thunk'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">self.axis_name</span><span class="s2">, </span><span class="s1">dims</span><span class="s2">, </span><span class="s1">dims_out_thunk)</span>

    <span class="s1">new_params = dict(params</span><span class="s2">,</span>
                      <span class="s1">in_axes=new_in_axes</span><span class="s2">, </span><span class="s1">out_axes_thunk=new_out_axes_thunk</span><span class="s2">,</span>
                      <span class="s1">spmd_in_axes=new_spmd_in_axes</span><span class="s2">,</span>
                      <span class="s1">spmd_out_axes_thunk=new_spmd_out_axes_thunk)</span>
    <span class="s1">vals_out = primitive.bind(f</span><span class="s2">, </span><span class="s1">*vals</span><span class="s2">, </span><span class="s1">**new_params)</span>
    <span class="s1">dims_out = dims_out_thunk()</span>
    <span class="s2">return </span><span class="s1">[batching.BatchTracer(self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">d) </span><span class="s2">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">zip(vals_out</span><span class="s2">, </span><span class="s1">dims_out)]</span>
<span class="s1">batching.BatchTrace.process_xmap = partialmethod(_batch_trace_process_xmap</span><span class="s2">, False</span><span class="s1">)  </span><span class="s0"># type: ignore</span>
<span class="s1">pxla.SPMDBatchTrace.process_xmap = partialmethod(_batch_trace_process_xmap</span><span class="s2">, True</span><span class="s1">)  </span><span class="s0"># type: ignore</span>


<span class="s2">def </span><span class="s1">_batch_trace_post_process_xmap(self</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">out_tracers</span><span class="s2">, </span><span class="s1">params):</span>
  <span class="s1">not_mapped = batching.not_mapped</span>
  <span class="s1">BT = batching.BatchTracer</span>
  <span class="s1">vals</span><span class="s2">, </span><span class="s1">dims</span><span class="s2">, </span><span class="s1">srcs = unzip3((t.val</span><span class="s2">, </span><span class="s1">t.batch_dim</span><span class="s2">, </span><span class="s1">t.source_info) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">out_tracers)</span>
  <span class="s1">main = self.main</span>
  <span class="s2">def </span><span class="s1">todo(vals):</span>
    <span class="s1">trace = main.with_cur_sublevel()</span>
    <span class="s2">return </span><span class="s1">[BT(trace</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">d </span><span class="s2">if </span><span class="s1">d </span><span class="s2">is </span><span class="s1">not_mapped </span><span class="s2">else </span><span class="s1">_axis_after_insertion(d</span><span class="s2">, </span><span class="s1">oa)</span><span class="s2">, </span><span class="s1">s)</span>
            <span class="s2">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">oa</span><span class="s2">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">zip(vals</span><span class="s2">, </span><span class="s1">dims</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'out_axes_thunk'</span><span class="s1">]()</span><span class="s2">, </span><span class="s1">srcs)]</span>
  <span class="s2">def </span><span class="s1">out_axes_transform(out_axes):</span>
    <span class="s2">return </span><span class="s1">tuple(oa </span><span class="s2">if </span><span class="s1">d </span><span class="s2">is </span><span class="s1">not_mapped </span><span class="s2">else</span>
                 <span class="s1">_fmap_dims(oa</span><span class="s2">, lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">nd=_axis_after_insertion(d</span><span class="s2">, </span><span class="s1">oa): a + (nd &lt;= a))</span>
                 <span class="s2">for </span><span class="s1">oa</span><span class="s2">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">zip(out_axes</span><span class="s2">, </span><span class="s1">dims))</span>
  <span class="s2">return </span><span class="s1">vals</span><span class="s2">, </span><span class="s1">(todo</span><span class="s2">, </span><span class="s1">out_axes_transform)</span>
<span class="s1">batching.BatchTrace.post_process_xmap = _batch_trace_post_process_xmap</span>


<span class="s0"># -------- nested xmap handling --------</span>

<span class="s2">def </span><span class="s1">_xmap_lowering_rule(ctx</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
  <span class="s2">if </span><span class="s1">isinstance(ctx.module_context.axis_context</span><span class="s2">, </span><span class="s1">sharding_impls.SPMDAxisContext):</span>
    <span class="s2">if </span><span class="s1">config.experimental_xmap_spmd_lowering_manual:</span>
      <span class="s2">return </span><span class="s1">_xmap_lowering_rule_spmd_manual(ctx</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">_xmap_lowering_rule_spmd(ctx</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
  <span class="s0"># Here ShardingContext is used in place of ReplicaAxisContext because when</span>
  <span class="s0"># axis_resources and mesh is not used with xmap, `make_xmap_callable` will</span>
  <span class="s0"># go via `dispatch.sharded_lowering` path which sets the context to</span>
  <span class="s0"># ShardingContext. sharding_impls.ShardingContext is not used for SPMD.</span>
  <span class="s2">elif </span><span class="s1">isinstance(ctx.module_context.axis_context</span><span class="s2">,</span>
                  <span class="s1">(sharding_impls.ReplicaAxisContext</span><span class="s2">, </span><span class="s1">sharding_impls.ShardingContext)):</span>
    <span class="s2">return </span><span class="s1">_xmap_lowering_rule_replica(ctx</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s3">&quot;Unrecognized axis context type!&quot;</span><span class="s1">)</span>
<span class="s1">mlir.register_lowering(xmap_p</span><span class="s2">, </span><span class="s1">_xmap_lowering_rule)</span>

<span class="s2">def </span><span class="s1">_xmap_lowering_rule_replica(ctx</span><span class="s2">, </span><span class="s1">*in_nodes</span><span class="s2">,</span>
                                <span class="s1">call_jaxpr</span><span class="s2">, </span><span class="s1">name</span><span class="s2">,</span>
                                <span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">,</span>
                                <span class="s1">global_axis_sizes</span><span class="s2">,</span>
                                <span class="s1">spmd_in_axes</span><span class="s2">, </span><span class="s1">spmd_out_axes</span><span class="s2">,</span>
                                <span class="s1">axis_resources</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">backend):</span>
  <span class="s1">xla.check_backend_matches(backend</span><span class="s2">, </span><span class="s1">ctx.module_context.platform)</span>
  <span class="s0"># The only way for any of those two assertions to be violated is when xmap</span>
  <span class="s0"># is using the SPMD lowering, but then this rule shouldn't even trigger.</span>
  <span class="s2">assert </span><span class="s1">spmd_in_axes </span><span class="s2">is None and </span><span class="s1">spmd_out_axes </span><span class="s2">is None</span>
  <span class="s1">plan = EvaluationPlan.from_axis_resources(</span>
      <span class="s1">axis_resources</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">global_axis_sizes)</span>

  <span class="s1">axis_resource_count = _get_axis_resource_count(</span>
      <span class="s1">axis_resources</span><span class="s2">, </span><span class="s1">resource_env)</span>
  <span class="s2">if </span><span class="s1">any(resource_count.distributed </span><span class="s2">for </span><span class="s1">resource_count </span><span class="s2">in </span><span class="s1">axis_resource_count.values()):</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError</span>

  <span class="s1">mesh = resource_env.physical_mesh</span>
  <span class="s1">mesh_in_axes</span><span class="s2">, </span><span class="s1">mesh_out_axes = plan.to_mesh_axes(in_axes</span><span class="s2">, </span><span class="s1">out_axes)</span>

  <span class="s1">local_avals = [pxla.tile_aval_nd(</span>
                    <span class="s1">mesh.shape</span><span class="s2">, </span><span class="s1">aval_mesh_in_axes</span><span class="s2">,</span>
                    <span class="s1">_insert_aval_axes(v.aval</span><span class="s2">, </span><span class="s1">aval_in_axes</span><span class="s2">, </span><span class="s1">global_axis_sizes))</span>
                 <span class="s2">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">aval_in_axes</span><span class="s2">, </span><span class="s1">aval_mesh_in_axes</span>
                 <span class="s2">in </span><span class="s1">zip(call_jaxpr.invars</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">mesh_in_axes)]</span>
  <span class="s0"># We have to substitute before tracing, because we want the vectorized</span>
  <span class="s0"># axes to be used in the jaxpr.</span>
  <span class="s1">resource_call_jaxpr = plan.subst_axes_with_resources(call_jaxpr)</span>
  <span class="s1">f = lu.wrap_init(core.jaxpr_as_fun(core.ClosedJaxpr(resource_call_jaxpr</span><span class="s2">, </span><span class="s1">())))</span>
  <span class="s1">f = hide_mapped_axes(f</span><span class="s2">, </span><span class="s1">tuple(in_axes)</span><span class="s2">, </span><span class="s1">tuple(out_axes))</span>
  <span class="s1">f = plan.vectorize_and_loop(f</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes)</span>
  <span class="s0"># NOTE: We don't extend the resource env with the mesh shape, because those</span>
  <span class="s0">#       resources are already in scope! It's the outermost xmap that introduces</span>
  <span class="s0">#       them!</span>
  <span class="s1">vectorized_jaxpr</span><span class="s2">, </span><span class="s1">out_avals</span><span class="s2">, </span><span class="s1">consts = pe.trace_to_jaxpr_dynamic(f</span><span class="s2">, </span><span class="s1">local_avals)</span>
  <span class="s1">_check_out_avals_vs_out_axes(out_avals</span><span class="s2">, </span><span class="s1">out_axes</span><span class="s2">, </span><span class="s1">global_axis_sizes)</span>
  <span class="s1">const_nodes = map(mlir.ir_constants</span><span class="s2">, </span><span class="s1">consts)</span>

  <span class="s1">local_mesh_shape = mesh.local_mesh.shape</span>
  <span class="s1">tiled_ins = (</span>
    <span class="s1">mlir.lower_fun(partial(_tile</span><span class="s2">, </span><span class="s1">in_axes=arg_in_axes</span><span class="s2">,</span>
                           <span class="s1">axis_sizes=local_mesh_shape)</span><span class="s2">,</span>
                   <span class="s1">multiple_results=</span><span class="s2">False</span><span class="s1">)(</span>
          <span class="s1">ctx.replace(primitive=</span><span class="s2">None,</span>
                      <span class="s1">avals_in=[aval]</span><span class="s2">, </span><span class="s1">avals_out=</span><span class="s2">None</span><span class="s1">)</span><span class="s2">,</span>
          <span class="s1">in_node)[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">in_node</span><span class="s2">, </span><span class="s1">arg_in_axes</span>
    <span class="s2">in </span><span class="s1">zip(call_jaxpr.invars</span><span class="s2">, </span><span class="s1">ctx.avals_in</span><span class="s2">, </span><span class="s1">in_nodes</span><span class="s2">, </span><span class="s1">mesh_in_axes))</span>

  <span class="s0"># NOTE: We don't extend the resource env with the mesh shape, because those</span>
  <span class="s0">#       resources are already in scope! It's the outermost xmap that introduces</span>
  <span class="s0">#       them!</span>
  <span class="s0"># We in-line here rather than generating a Call HLO as in the xla_call</span>
  <span class="s0"># translation rule just because the extra tuple stuff is a pain.</span>
  <span class="s1">sub_ctx = ctx.module_context.replace(</span>
      <span class="s1">name_stack=ctx.module_context.name_stack.extend(wrap_name(name</span><span class="s2">, </span><span class="s3">'xmap'</span><span class="s1">)))</span>
  <span class="s2">if </span><span class="s1">any(effects.ordered_effects.contains(eff) </span><span class="s2">for </span><span class="s1">eff</span>
         <span class="s2">in </span><span class="s1">vectorized_jaxpr.effects):</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">'Cannot lower `xmap` with ordered effects.'</span><span class="s1">)</span>
  <span class="s1">tiled_outs</span><span class="s2">, </span><span class="s1">_ = mlir.jaxpr_subcomp(sub_ctx</span><span class="s2">, </span><span class="s1">vectorized_jaxpr</span><span class="s2">, </span><span class="s1">mlir.TokenSet()</span><span class="s2">,</span>
                                     <span class="s1">const_nodes</span><span class="s2">, </span><span class="s1">*tiled_ins</span><span class="s2">,</span>
                                     <span class="s1">dim_var_values=ctx.dim_var_values)</span>

  <span class="s1">outs = [</span>
      <span class="s1">mlir.lower_fun(</span>
          <span class="s1">partial(_untile</span><span class="s2">, </span><span class="s1">out_axes=ans_out_axes</span><span class="s2">, </span><span class="s1">axis_sizes=local_mesh_shape</span><span class="s2">,</span>
                  <span class="s1">platform=ctx.module_context.platform)</span><span class="s2">,</span>
          <span class="s1">multiple_results=</span><span class="s2">False</span><span class="s1">)(</span>
              <span class="s1">ctx.replace(primitive=</span><span class="s2">None,</span>
                          <span class="s1">avals_in=[vectorized_outvar.aval]</span><span class="s2">,</span>
                          <span class="s1">avals_out=</span><span class="s2">None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">tiled_out)[</span><span class="s5">0</span><span class="s1">]</span>
      <span class="s2">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">vectorized_outvar</span><span class="s2">, </span><span class="s1">tiled_out</span><span class="s2">, </span><span class="s1">ans_out_axes</span>
      <span class="s2">in </span><span class="s1">zip(call_jaxpr.outvars</span><span class="s2">, </span><span class="s1">vectorized_jaxpr.outvars</span><span class="s2">, </span><span class="s1">tiled_outs</span><span class="s2">,</span>
             <span class="s1">mesh_out_axes)]</span>
  <span class="s2">return </span><span class="s1">outs</span>


<span class="s2">def </span><span class="s1">_xmap_lowering_rule_spmd(ctx</span><span class="s2">, </span><span class="s1">*global_in_nodes</span><span class="s2">,</span>
                             <span class="s1">call_jaxpr</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes</span><span class="s2">,</span>
                             <span class="s1">donated_invars</span><span class="s2">, </span><span class="s1">global_axis_sizes</span><span class="s2">, </span><span class="s1">spmd_in_axes</span><span class="s2">,</span>
                             <span class="s1">spmd_out_axes</span><span class="s2">, </span><span class="s1">axis_resources</span><span class="s2">,</span>
                             <span class="s1">resource_env</span><span class="s2">, </span><span class="s1">backend):</span>
  <span class="s1">xla.check_backend_matches(backend</span><span class="s2">, </span><span class="s1">ctx.module_context.platform)</span>
  <span class="s1">plan = EvaluationPlan.from_axis_resources(</span>
      <span class="s1">axis_resources</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">global_axis_sizes)</span>

  <span class="s1">resource_call_jaxpr = plan.subst_axes_with_resources(call_jaxpr)</span>
  <span class="s1">f = lu.wrap_init(core.jaxpr_as_fun(core.ClosedJaxpr(resource_call_jaxpr</span><span class="s2">, </span><span class="s1">())))</span>
  <span class="s1">f = hide_mapped_axes(f</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes)</span>
  <span class="s1">f = plan.vectorize_and_loop(f</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes)</span>
  <span class="s1">mesh_in_axes</span><span class="s2">, </span><span class="s1">mesh_out_axes = plan.to_mesh_axes(in_axes</span><span class="s2">, </span><span class="s1">out_axes)</span>
  <span class="s1">mesh = resource_env.physical_mesh</span>
  <span class="s1">f = pxla.vtile_by_mesh(f</span><span class="s2">, </span><span class="s1">mesh</span><span class="s2">, </span><span class="s1">mesh_in_axes</span><span class="s2">, </span><span class="s1">mesh_out_axes)</span>

  <span class="s0"># XXX: We modify mesh_in_axes and mesh_out_axes here</span>
  <span class="s2">def </span><span class="s1">add_spmd_axes(</span>
      <span class="s1">flat_mesh_axes: Sequence[ArrayMapping]</span><span class="s2">,</span>
      <span class="s1">flat_extra_axes: Optional[Sequence[Sequence[Sequence[MeshAxisName]]]]):</span>
    <span class="s2">if </span><span class="s1">flat_extra_axes </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s2">return</span>
    <span class="s2">for </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">extra </span><span class="s2">in </span><span class="s1">zip(flat_mesh_axes</span><span class="s2">, </span><span class="s1">flat_extra_axes):</span>
      <span class="s2">for </span><span class="s1">dim</span><span class="s2">, </span><span class="s1">dim_extra_axis </span><span class="s2">in </span><span class="s1">enumerate(extra):</span>
        <span class="s2">if </span><span class="s1">dim_extra_axis </span><span class="s2">is None</span><span class="s1">: </span><span class="s2">continue</span>
        <span class="s2">assert </span><span class="s1">dim_extra_axis </span><span class="s2">not in </span><span class="s1">axes</span>
        <span class="s2">assert not </span><span class="s1">config.jax_enable_checks </span><span class="s2">or </span><span class="s1">all(v != dim </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">axes.values())</span>
        <span class="s1">axes[dim_extra_axis] = dim</span>
  <span class="s1">add_spmd_axes(mesh_in_axes</span><span class="s2">, </span><span class="s1">spmd_in_axes)</span>
  <span class="s1">add_spmd_axes(mesh_out_axes</span><span class="s2">, </span><span class="s1">spmd_out_axes)</span>
  <span class="s1">global_in_avals = ctx.avals_in</span>
  <span class="s1">vectorized_jaxpr</span><span class="s2">, </span><span class="s1">global_out_avals</span><span class="s2">, </span><span class="s1">consts = pe.trace_to_jaxpr_dynamic(f</span><span class="s2">, </span><span class="s1">global_in_avals)</span>

  <span class="s1">global_sharding_spec = pxla.mesh_sharding_specs(mesh.shape</span><span class="s2">, </span><span class="s1">mesh.axis_names)</span>
  <span class="s1">sharded_global_in_nodes = [</span>
    <span class="s1">[mlir.wrap_with_sharding_op(</span>
        <span class="s1">ctx</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">aval</span><span class="s2">,</span>
        <span class="s1">global_sharding_spec(aval</span><span class="s2">, </span><span class="s1">aval_axes).sharding_proto().to_proto())]</span>
    <span class="s2">if </span><span class="s1">aval_axes </span><span class="s2">else </span><span class="s1">[node]</span>
    <span class="s2">for </span><span class="s1">node</span><span class="s2">, </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">aval_axes </span><span class="s2">in </span><span class="s1">zip(global_in_nodes</span><span class="s2">, </span><span class="s1">global_in_avals</span><span class="s2">, </span><span class="s1">mesh_in_axes)</span>
  <span class="s1">]</span>
  <span class="s1">const_nodes = map(mlir.ir_constants</span><span class="s2">, </span><span class="s1">consts)</span>

  <span class="s0"># We in-line here rather than generating a Call HLO as in the xla_call</span>
  <span class="s0"># translation rule just because the extra tuple stuff is a pain.</span>
  <span class="s1">sub_ctx = ctx.module_context.replace(</span>
      <span class="s1">name_stack=ctx.module_context.name_stack.extend(wrap_name(name</span><span class="s2">, </span><span class="s3">'xmap'</span><span class="s1">)))</span>
  <span class="s2">if </span><span class="s1">any(effects.ordered_effects.contains(eff) </span><span class="s2">for </span><span class="s1">eff</span>
         <span class="s2">in </span><span class="s1">vectorized_jaxpr.effects):</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">'Cannot lower `xmap` with ordered effects.'</span><span class="s1">)</span>
  <span class="s1">global_out_nodes</span><span class="s2">, </span><span class="s1">_ = mlir.jaxpr_subcomp(sub_ctx</span><span class="s2">, </span><span class="s1">vectorized_jaxpr</span><span class="s2">,</span>
      <span class="s1">mlir.TokenSet()</span><span class="s2">, </span><span class="s1">const_nodes</span><span class="s2">, </span><span class="s1">*sharded_global_in_nodes</span><span class="s2">,</span>
      <span class="s1">dim_var_values=ctx.dim_var_values)</span>

  <span class="s1">sharded_global_out_nodes = [</span>
    <span class="s1">mlir.wrap_with_sharding_op(</span>
        <span class="s1">ctx</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">aval</span><span class="s2">,</span>
        <span class="s1">global_sharding_spec(aval</span><span class="s2">, </span><span class="s1">aval_axes).sharding_proto().to_proto())</span>
    <span class="s2">if </span><span class="s1">aval_axes </span><span class="s2">else </span><span class="s1">node</span>
    <span class="s2">for </span><span class="s1">(node</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">aval_axes </span><span class="s2">in </span><span class="s1">zip(global_out_nodes</span><span class="s2">, </span><span class="s1">global_out_avals</span><span class="s2">, </span><span class="s1">mesh_out_axes)</span>
  <span class="s1">]</span>

  <span class="s2">return </span><span class="s1">sharded_global_out_nodes</span>


<span class="s2">def </span><span class="s1">_xmap_lowering_rule_spmd_manual(ctx</span><span class="s2">, </span><span class="s1">*global_in_nodes</span><span class="s2">,</span>
                                    <span class="s1">call_jaxpr</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes</span><span class="s2">,</span>
                                    <span class="s1">donated_invars</span><span class="s2">, </span><span class="s1">global_axis_sizes</span><span class="s2">, </span><span class="s1">spmd_in_axes</span><span class="s2">,</span>
                                    <span class="s1">spmd_out_axes</span><span class="s2">, </span><span class="s1">axis_resources</span><span class="s2">,</span>
                                    <span class="s1">resource_env</span><span class="s2">, </span><span class="s1">backend):</span>
  <span class="s2">assert </span><span class="s1">spmd_in_axes </span><span class="s2">is None and </span><span class="s1">spmd_out_axes </span><span class="s2">is None</span>
  <span class="s0"># This first part (up to vtile_manual) is shared with non-MANUAL SPMD rule.</span>
  <span class="s1">xla.check_backend_matches(backend</span><span class="s2">, </span><span class="s1">ctx.module_context.platform)</span>
  <span class="s1">plan = EvaluationPlan.from_axis_resources(</span>
      <span class="s1">axis_resources</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">global_axis_sizes)</span>
  <span class="s1">manual_mesh_axes = frozenset(it.chain.from_iterable(plan.physical_axis_resources.values()))</span>

  <span class="s1">resource_call_jaxpr = plan.subst_axes_with_resources(call_jaxpr)</span>
  <span class="s1">f = lu.wrap_init(core.jaxpr_as_fun(core.ClosedJaxpr(resource_call_jaxpr</span><span class="s2">, </span><span class="s1">())))</span>
  <span class="s1">f = hide_mapped_axes(f</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes)</span>
  <span class="s1">f = plan.vectorize_and_loop(f</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">out_axes)</span>

  <span class="s0"># NOTE: Sharding constraints are handled entirely by vtile_manual!</span>
  <span class="s1">mesh_in_axes</span><span class="s2">, </span><span class="s1">mesh_out_axes = plan.to_mesh_axes(in_axes</span><span class="s2">, </span><span class="s1">out_axes)</span>
  <span class="s1">mesh = resource_env.physical_mesh</span>
  <span class="s1">f = pxla.vtile_manual(f</span><span class="s2">, </span><span class="s1">tuple(manual_mesh_axes)</span><span class="s2">, </span><span class="s1">mesh</span><span class="s2">, </span><span class="s1">mesh_in_axes</span><span class="s2">, </span><span class="s1">mesh_out_axes)</span>

  <span class="s0"># NOTE: We don't extend the resource env with the mesh shape, because those</span>
  <span class="s0">#       resources are already in scope! It's the outermost xmap that introduces</span>
  <span class="s0">#       them!</span>
  <span class="s1">global_in_avals = ctx.avals_in</span>
  <span class="s1">vectorized_jaxpr</span><span class="s2">, </span><span class="s1">global_out_avals</span><span class="s2">, </span><span class="s1">consts = pe.trace_to_jaxpr_dynamic(f</span><span class="s2">, </span><span class="s1">global_in_avals)</span>
  <span class="s1">const_nodes = map(mlir.ir_constants</span><span class="s2">, </span><span class="s1">consts)</span>

  <span class="s0"># We in-line here rather than generating a Call HLO as in the xla_call</span>
  <span class="s0"># translation rule just because the extra tuple stuff is a pain.</span>
  <span class="s2">assert </span><span class="s1">isinstance(ctx.module_context.axis_context</span><span class="s2">,</span>
                    <span class="s1">sharding_impls.SPMDAxisContext)</span>
  <span class="s1">sub_ctx = ctx.module_context.replace(</span>
      <span class="s1">name_stack=ctx.module_context.name_stack.extend(wrap_name(name</span><span class="s2">, </span><span class="s3">'xmap'</span><span class="s1">))</span><span class="s2">,</span>
      <span class="s1">axis_context=ctx.module_context.axis_context.extend_manual(manual_mesh_axes))</span>
  <span class="s2">if </span><span class="s1">any(effects.ordered_effects.contains(eff) </span><span class="s2">for </span><span class="s1">eff</span>
         <span class="s2">in </span><span class="s1">vectorized_jaxpr.effects):</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">'Cannot lower `xmap` with ordered effects.'</span><span class="s1">)</span>
  <span class="s1">global_out_nodes</span><span class="s2">, </span><span class="s1">_ = mlir.jaxpr_subcomp(sub_ctx</span><span class="s2">, </span><span class="s1">vectorized_jaxpr</span><span class="s2">,</span>
      <span class="s1">mlir.TokenSet()</span><span class="s2">, </span><span class="s1">const_nodes</span><span class="s2">, </span><span class="s1">*([n] </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">global_in_nodes)</span><span class="s2">,</span>
      <span class="s1">dim_var_values=ctx.dim_var_values)</span>

  <span class="s2">return </span><span class="s1">global_out_nodes</span>


<span class="s2">def </span><span class="s1">_tile_base_indices(tile_shape</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">axis_sizes):</span>
  <span class="s1">zero = np.zeros(()</span><span class="s2">, </span><span class="s1">dtype=np.int32)</span>
  <span class="s1">linear_idxs = [zero] * len(tile_shape)</span>
  <span class="s1">strides = [</span><span class="s5">1</span><span class="s1">] * len(tile_shape)</span>
  <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">reversed(axes.items()):</span>
    <span class="s1">axis_index = lax.axis_index(name)</span>
    <span class="s1">stride_c = np.array(strides[axis]</span><span class="s2">, </span><span class="s1">np.int32)</span>
    <span class="s2">if </span><span class="s1">linear_idxs[axis] </span><span class="s2">is </span><span class="s1">zero </span><span class="s2">and </span><span class="s1">strides[axis] == </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s1">linear_idxs[axis] = axis_index</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">linear_idxs[axis] = lax.add(linear_idxs[axis]</span><span class="s2">,</span>
                                  <span class="s1">lax.mul(axis_index</span><span class="s2">, </span><span class="s1">stride_c))</span>
    <span class="s1">strides[axis] *= axis_sizes[name]</span>
  <span class="s2">return </span><span class="s1">[zero </span><span class="s2">if </span><span class="s1">linear_idx </span><span class="s2">is </span><span class="s1">zero </span><span class="s2">else</span>
          <span class="s1">lax.mul(linear_idx</span><span class="s2">, </span><span class="s1">np.array(tile_dim_size</span><span class="s2">, </span><span class="s1">np.int32))</span>
          <span class="s2">for </span><span class="s1">linear_idx</span><span class="s2">, </span><span class="s1">tile_dim_size </span><span class="s2">in </span><span class="s1">zip(linear_idxs</span><span class="s2">, </span><span class="s1">tile_shape)]</span>


<span class="s2">def </span><span class="s1">_tile(x</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">axis_sizes):</span>
  <span class="s2">if not </span><span class="s1">in_axes:</span>
    <span class="s2">return </span><span class="s1">x</span>
  <span class="s1">tile_shape = list(x.shape)</span>
  <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">in_axes.items():</span>
    <span class="s1">axis_size = axis_sizes[name]</span>
    <span class="s2">assert </span><span class="s1">tile_shape[axis] % axis_size == </span><span class="s5">0</span>
    <span class="s1">tile_shape[axis] //= axis_size</span>
  <span class="s1">base_idxs = _tile_base_indices(tile_shape</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">axis_sizes)</span>
  <span class="s2">return </span><span class="s1">lax.dynamic_slice(x</span><span class="s2">, </span><span class="s1">base_idxs</span><span class="s2">, </span><span class="s1">tile_shape)</span>


<span class="s0"># TODO(b/110096942): more efficient gather</span>
<span class="s2">def </span><span class="s1">_untile(x</span><span class="s2">, </span><span class="s1">out_axes</span><span class="s2">, </span><span class="s1">axis_sizes</span><span class="s2">, </span><span class="s1">platform):</span>
  <span class="s0"># TODO(mattjj): remove this logic when AllReduce PRED supported on CPU / GPU</span>
  <span class="s1">convert_bool = (np.issubdtype(x.dtype</span><span class="s2">, </span><span class="s1">np.bool_)</span>
                  <span class="s2">and </span><span class="s1">platform </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'cpu'</span><span class="s2">, </span><span class="s3">'gpu'</span><span class="s1">))</span>
  <span class="s2">if </span><span class="s1">convert_bool:</span>
    <span class="s1">x = lax.convert_element_type(x</span><span class="s2">, </span><span class="s1">np.dtype(np.float32))</span>

  <span class="s1">tile_shape = list(x.shape)</span>
  <span class="s1">shape = list(tile_shape)</span>
  <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">out_axes.items():</span>
    <span class="s1">shape[axis] *= axis_sizes[name]</span>
  <span class="s1">base_idxs = _tile_base_indices(tile_shape</span><span class="s2">, </span><span class="s1">out_axes</span><span class="s2">, </span><span class="s1">axis_sizes)</span>

  <span class="s1">padded = lax.broadcast(np.array(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">x.dtype)</span><span class="s2">, </span><span class="s1">shape)</span>
  <span class="s1">padded = lax.dynamic_update_slice(padded</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">base_idxs)</span>
  <span class="s1">out = lax.psum(padded</span><span class="s2">, </span><span class="s1">tuple(out_axes.keys()))</span>

  <span class="s0"># TODO(mattjj): remove this logic when AllReduce PRED supported on CPU / GPU</span>
  <span class="s2">if </span><span class="s1">convert_bool:</span>
    <span class="s1">nonzero = lax.ne(out</span><span class="s2">, </span><span class="s1">np.array(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dtype=np.float32))</span>
    <span class="s1">out = lax.convert_element_type(nonzero</span><span class="s2">, </span><span class="s1">np.dtype(np.bool_))</span>
  <span class="s2">return </span><span class="s1">out</span>


<span class="s0"># -------- helper functions --------</span>

<span class="s2">def </span><span class="s1">_delete_aval_axes(aval</span><span class="s2">, </span><span class="s1">axes: AxisNamePos</span><span class="s2">, </span><span class="s1">global_axis_sizes):</span>
  <span class="s2">assert </span><span class="s1">isinstance(aval</span><span class="s2">, </span><span class="s1">core.ShapedArray)</span>
  <span class="s1">shape = list(aval.shape)</span>
  <span class="s1">named_shape = dict(aval.named_shape)</span>
  <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">sorted(axes.items()</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">x: x[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s1">named_shape[name] = global_axis_sizes[name]</span>
    <span class="s2">del </span><span class="s1">shape[dim]</span>
  <span class="s2">return </span><span class="s1">aval.update(shape=tuple(shape)</span><span class="s2">, </span><span class="s1">named_shape=named_shape)</span>

<span class="s2">def </span><span class="s1">_insert_aval_axes(aval</span><span class="s2">, </span><span class="s1">axes: AxisNamePos</span><span class="s2">, </span><span class="s1">local_axis_sizes):</span>
  <span class="s2">assert </span><span class="s1">isinstance(aval</span><span class="s2">, </span><span class="s1">core.ShapedArray)</span>
  <span class="s1">shape = list(aval.shape)</span>
  <span class="s1">named_shape = dict(aval.named_shape)</span>
  <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">sorted(axes.items()</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">x: x[</span><span class="s5">1</span><span class="s1">]):</span>
    <span class="s1">shape.insert(dim</span><span class="s2">, </span><span class="s1">local_axis_sizes[name])</span>
    <span class="s1">named_shape.pop(name</span><span class="s2">, None</span><span class="s1">)  </span><span class="s0"># The name might be missing --- it's a broadcast.</span>
  <span class="s2">return </span><span class="s1">aval.update(shape=tuple(shape)</span><span class="s2">, </span><span class="s1">named_shape=named_shape)</span>


<span class="s2">class </span><span class="s1">ResourceCount(NamedTuple):</span>
  <span class="s1">nglobal: int</span>
  <span class="s1">nlocal: Optional[int]</span>
  <span class="s1">distributed: bool</span>

  <span class="s2">def </span><span class="s1">to_local(self</span><span class="s2">, </span><span class="s1">global_size):</span>
    <span class="s2">return </span><span class="s1">global_size</span>


<span class="s2">def </span><span class="s1">_get_axis_resource_count(</span>
    <span class="s1">axis_resources</span><span class="s2">, </span><span class="s1">resource_env) -&gt; Dict[ResourceAxisName</span><span class="s2">, </span><span class="s1">ResourceCount]:</span>
  <span class="s1">global_res_shape = resource_env.shape</span>
  <span class="s1">local_res_shape = </span><span class="s2">None</span>

  <span class="s1">distributed = (</span><span class="s2">False if </span><span class="s1">resource_env.physical_mesh.empty </span><span class="s2">else</span>
                 <span class="s1">resource_env.physical_mesh.size != len(resource_env.physical_mesh.local_devices))</span>
  <span class="s1">resource_count_map = {}</span>
  <span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">resources </span><span class="s2">in </span><span class="s1">axis_resources.items():</span>
    <span class="s2">if </span><span class="s1">local_res_shape </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s1">nlocal = </span><span class="s2">None</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">nlocal = math.prod(map(local_res_shape.get</span><span class="s2">, </span><span class="s1">resources))</span>
    <span class="s1">resource_count_map[axis] = ResourceCount(</span>
        <span class="s1">math.prod(map(global_res_shape.get</span><span class="s2">, </span><span class="s1">resources))</span><span class="s2">,</span>
        <span class="s1">nlocal</span><span class="s2">, </span><span class="s1">distributed)</span>
  <span class="s2">return </span><span class="s1">resource_count_map</span>


<span class="s2">def </span><span class="s1">_get_axis_sizes(args_flat: Iterable[Any]</span><span class="s2">,</span>
                    <span class="s1">in_axes_flat: Iterable[AxisNamePos]</span><span class="s2">,</span>
                    <span class="s1">global_axis_sizes: Dict[AxisName</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">,</span>
                    <span class="s1">axis_resource_count: Dict[AxisName</span><span class="s2">, </span><span class="s1">ResourceCount]):</span>
  <span class="s1">global_axis_sizes = dict(global_axis_sizes)</span>
  <span class="s2">for </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">in_axes </span><span class="s2">in </span><span class="s1">zip(args_flat</span><span class="s2">, </span><span class="s1">in_axes_flat):</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">in_axes.items():</span>
      <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">dim_size = arg.shape[dim]</span>
      <span class="s2">except </span><span class="s1">IndexError:</span>
        <span class="s0"># TODO(apaszke): Handle negative indices. Check for overlap too!</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;One of xmap arguments has an in_axes specification of &quot;</span>
                         <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">in_axes.user_repr</span><span class="s2">}</span><span class="s3">, which implies that it has at least &quot;</span>
                         <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">max(in_axes.values()) + </span><span class="s5">1</span><span class="s2">} </span><span class="s3">dimensions, but the argument &quot;</span>
                         <span class="s3">f&quot;has rank </span><span class="s2">{</span><span class="s1">arg.ndim</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
      <span class="s1">global_dim_size = dim_size</span>
      <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">global_axis_sizes:</span>
        <span class="s1">expected_global_dim_size = global_axis_sizes[name]</span>
        <span class="s2">if </span><span class="s1">global_dim_size != expected_global_dim_size:</span>
          <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;The size of axis </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">was previously inferred to be &quot;</span>
                            <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">expected_global_dim_size</span><span class="s2">}</span><span class="s3">, but found an argument of shape </span><span class="s2">{</span><span class="s1">arg.shape</span><span class="s2">} </span><span class="s3">&quot;</span>
                            <span class="s3">f&quot;with in_axes specification </span><span class="s2">{</span><span class="s1">in_axes.user_repr</span><span class="s2">}</span><span class="s3">. Shape mismatch &quot;</span>
                            <span class="s3">f&quot;occurs in dimension </span><span class="s2">{</span><span class="s1">dim</span><span class="s2">}</span><span class="s3">: </span><span class="s2">{</span><span class="s1">global_dim_size</span><span class="s2">} </span><span class="s3">!= </span><span class="s2">{</span><span class="s1">expected_global_dim_size</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
      <span class="s1">global_axis_sizes[name] = global_dim_size</span>
  <span class="s2">return </span><span class="s1">FrozenDict(global_axis_sizes)</span>


<span class="s1">@lu.transformation</span>
<span class="s2">def </span><span class="s1">hide_mapped_axes(flat_in_axes</span><span class="s2">, </span><span class="s1">flat_out_axes</span><span class="s2">, </span><span class="s1">*flat_args):</span>
  <span class="s2">def </span><span class="s1">_squeeze_mapped_axes(arg</span><span class="s2">, </span><span class="s1">axes: AxisNamePos):</span>
    <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">sorted(axes.values()</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">):</span>
      <span class="s1">arg = arg.squeeze(dim)</span>
    <span class="s2">return </span><span class="s1">arg</span>

  <span class="s2">def </span><span class="s1">_unsqueeze_mapped_axes(out</span><span class="s2">, </span><span class="s1">axes: AxisNamePos):</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">jnp.expand_dims(out</span><span class="s2">, </span><span class="s1">tuple(axes.values()))</span>
    <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
      <span class="s0"># Improve the axis out of bounds errors</span>
      <span class="s0"># TODO(apaszke): Handle negative indices. Check for overlap too!</span>
      <span class="s2">if </span><span class="s1">e.args[</span><span class="s5">0</span><span class="s1">].startswith(</span><span class="s3">'axis'</span><span class="s1">) </span><span class="s2">and </span><span class="s3">'out of bounds' </span><span class="s2">in </span><span class="s1">e.args[</span><span class="s5">0</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;One of xmap outputs has an out_axes specification of &quot;</span>
                         <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">axes.user_repr</span><span class="s2">}</span><span class="s3">, which requires the result of the xmapped &quot;</span>
                         <span class="s3">f&quot;function to have at least </span><span class="s2">{</span><span class="s1">max(axes.values()) - len(axes) + </span><span class="s5">1</span><span class="s2">} </span><span class="s3">&quot;</span>
                         <span class="s3">f&quot;positional dimensions, but it only has </span><span class="s2">{</span><span class="s1">out.ndim</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
      <span class="s2">raise</span>

  <span class="s1">squeezed_args = map(_squeeze_mapped_axes</span><span class="s2">, </span><span class="s1">flat_args</span><span class="s2">, </span><span class="s1">flat_in_axes)</span>
  <span class="s1">flat_outputs = </span><span class="s2">yield </span><span class="s1">squeezed_args</span><span class="s2">, </span><span class="s1">{}</span>
  <span class="s2">yield </span><span class="s1">map(_unsqueeze_mapped_axes</span><span class="s2">, </span><span class="s1">flat_outputs</span><span class="s2">, </span><span class="s1">flat_out_axes)</span>


<span class="s2">def </span><span class="s1">_jaxpr_resources(jaxpr</span><span class="s2">, </span><span class="s1">resource_env) -&gt; Set[ResourceAxisName]:</span>
  <span class="s2">if </span><span class="s1">isinstance(jaxpr</span><span class="s2">, </span><span class="s1">core.ClosedJaxpr):</span>
    <span class="s1">jaxpr = jaxpr.jaxpr</span>
  <span class="s2">assert </span><span class="s1">isinstance(jaxpr</span><span class="s2">, </span><span class="s1">core.Jaxpr)</span>
  <span class="s1">used_resources = set()</span>
  <span class="s2">for </span><span class="s1">eqn </span><span class="s2">in </span><span class="s1">jaxpr.eqns:</span>
    <span class="s2">if </span><span class="s1">eqn.primitive </span><span class="s2">is </span><span class="s1">xmap_p:</span>
      <span class="s2">if </span><span class="s1">eqn.params[</span><span class="s3">'resource_env'</span><span class="s1">].physical_mesh != resource_env.physical_mesh:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Changing the physical mesh is not allowed inside xmap.&quot;</span><span class="s1">)</span>
      <span class="s1">used_resources |= set(it.chain(*eqn.params[</span><span class="s3">'axis_resources'</span><span class="s1">].values()))</span>
    <span class="s1">updates = core.traverse_jaxpr_params(</span>
        <span class="s1">partial(_jaxpr_resources</span><span class="s2">, </span><span class="s1">resource_env=resource_env)</span><span class="s2">, </span><span class="s1">eqn.params).values()</span>
    <span class="s2">for </span><span class="s1">update </span><span class="s2">in </span><span class="s1">updates:</span>
      <span class="s1">used_resources |= update</span>
  <span class="s2">return </span><span class="s1">used_resources</span>


<span class="s2">def </span><span class="s1">_to_resource_axes(axes_specs: Sequence[AxisNamePos]</span><span class="s2">,</span>
                      <span class="s1">axis_resources: Dict[AxisName</span><span class="s2">, </span><span class="s1">Tuple[ResourceAxisName</span><span class="s2">, </span><span class="s1">...]]):</span>
  <span class="s4">&quot;&quot;&quot; 
  Convert in/out_axes parameters ranging over logical dimensions to 
  ones that range over resource dimensions. 
 
  Note that values no longer have to be distinct, as multiple resource 
  axes can tile a single positional axes. This is why the result is 
  an OrderedDict with an implicit major-to-minor ordering. 
  &quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">tuple(OrderedDict((resource_axis</span><span class="s2">, </span><span class="s1">pos_axis)</span>
                           <span class="s2">for </span><span class="s1">logical_axis</span><span class="s2">, </span><span class="s1">pos_axis </span><span class="s2">in </span><span class="s1">axes.items()</span>
                           <span class="s2">for </span><span class="s1">resource_axis </span><span class="s2">in </span><span class="s1">axis_resources[logical_axis])</span>
               <span class="s2">for </span><span class="s1">axes </span><span class="s2">in </span><span class="s1">axes_specs)</span>


<span class="s2">def </span><span class="s1">_merge_leading_axis(x</span><span class="s2">, </span><span class="s1">axis: Optional[int]):</span>
  <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s0"># We assume that the output does not vary along the leading axis</span>
    <span class="s2">return </span><span class="s1">lax.index_in_dim(x</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">keepdims=</span><span class="s2">False</span><span class="s1">)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">x_moved = moveaxis(x</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">axis)</span>
    <span class="s1">shape = list(x_moved.shape)</span>
    <span class="s1">shape[axis:axis + </span><span class="s5">2</span><span class="s1">] = [shape[axis] * shape[axis + </span><span class="s5">1</span><span class="s1">]]</span>
    <span class="s2">return </span><span class="s1">x_moved.reshape(shape)</span>


<span class="s2">def </span><span class="s1">_slice_tile(x</span><span class="s2">, </span><span class="s1">dim: Optional[int]</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">n: int):</span>
  <span class="s4">&quot;&quot;&quot;Selects an `i`th (out of `n`) tiles of `x` along `dim`.&quot;&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">dim </span><span class="s2">is None</span><span class="s1">: </span><span class="s2">return </span><span class="s1">x</span>
  <span class="s1">(tile_size</span><span class="s2">, </span><span class="s1">rem) = divmod(x.shape[dim]</span><span class="s2">, </span><span class="s1">n)</span>
  <span class="s2">assert </span><span class="s1">rem == </span><span class="s5">0</span><span class="s2">, </span><span class="s3">&quot;Please open a bug report!&quot;</span>
  <span class="s2">return </span><span class="s1">lax.dynamic_slice_in_dim(x</span><span class="s2">, </span><span class="s1">i * tile_size</span><span class="s2">, </span><span class="s1">slice_size=tile_size</span><span class="s2">, </span><span class="s1">axis=dim)</span>


<span class="s2">def </span><span class="s1">_unzip_axis_resources(axis_resources: Dict[AxisName</span><span class="s2">, </span><span class="s1">Tuple[ResourceAxisName</span><span class="s2">, </span><span class="s1">...]]</span><span class="s2">,</span>
                          <span class="s1">resource_env: ResourceEnv):</span>
  <span class="s4">&quot;&quot;&quot;Splits axis_resources into separate dicts for physical and loop resources.&quot;&quot;&quot;</span>
  <span class="s1">physical_axis_resources = {}</span>
  <span class="s1">loop_axis_resources = {}</span>
  <span class="s1">loop_resource_axes = resource_env.loop_resource_axes</span>
  <span class="s2">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">raxes </span><span class="s2">in </span><span class="s1">axis_resources.items():</span>
    <span class="s1">first_loop = </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">raxis </span><span class="s2">in </span><span class="s1">raxes:</span>
      <span class="s2">if </span><span class="s1">raxis </span><span class="s2">in </span><span class="s1">loop_resource_axes:</span>
        <span class="s2">break</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">first_loop += </span><span class="s5">1</span>
    <span class="s1">physical_axis_resources[axis] = raxes[:first_loop]</span>
    <span class="s1">loop_resources = loop_axis_resources[axis] = raxes[first_loop:]</span>
    <span class="s2">if not </span><span class="s1">all(name </span><span class="s2">in </span><span class="s1">loop_resource_axes </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">loop_resources):</span>
      <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;Loop resources cannot appear before mesh axes &quot;</span>
                                <span class="s3">&quot;in the resource_axis argument&quot;</span><span class="s1">)</span>
  <span class="s2">return </span><span class="s1">physical_axis_resources</span><span class="s2">, </span><span class="s1">loop_axis_resources</span>


<span class="s2">def </span><span class="s1">_check_out_avals_vs_out_axes(out_avals: Sequence[core.AbstractValue]</span><span class="s2">,</span>
                                 <span class="s1">out_axes: Sequence[AxisNamePos]</span><span class="s2">,</span>
                                 <span class="s1">global_axis_sizes: Dict[AxisName</span><span class="s2">, </span><span class="s1">int]):</span>
  <span class="s1">defined_axes = set(global_axis_sizes)</span>
  <span class="s2">for </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">axes </span><span class="s2">in </span><span class="s1">zip(out_avals</span><span class="s2">, </span><span class="s1">out_axes):</span>
    <span class="s2">if not </span><span class="s1">isinstance(aval</span><span class="s2">, </span><span class="s1">core.ShapedArray):</span>
      <span class="s2">if </span><span class="s1">axes:</span>
        <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s3">f&quot;Only array abstract values can have non-empty &quot;</span>
                             <span class="s3">f&quot;out_axes, but </span><span class="s2">{</span><span class="s1">aval</span><span class="s2">} </span><span class="s3">has </span><span class="s2">{</span><span class="s1">axes</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
      <span class="s2">continue</span>
    <span class="s1">undeclared_axes = (set(aval.named_shape) - set(axes)) &amp; defined_axes</span>
    <span class="s2">if </span><span class="s1">undeclared_axes:</span>
      <span class="s1">undeclared_axes_str = sorted(str(axis) </span><span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">undeclared_axes)</span>
      <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;One of xmap results has an out_axes specification of &quot;</span>
                      <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">axes.user_repr</span><span class="s2">}</span><span class="s3">, but is actually mapped along more axes &quot;</span>
                      <span class="s3">f&quot;defined by this xmap call: </span><span class="s2">{</span><span class="s3">', '</span><span class="s1">.join(undeclared_axes_str)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_check_gda_or_array_xmap_partitioning(axis_resources</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">,</span>
                                          <span class="s1">global_axis_sizes</span><span class="s2">, </span><span class="s1">in_axes_flat</span><span class="s2">,</span>
                                          <span class="s1">args_flat):</span>
  <span class="s1">@lru_cache()</span>
  <span class="s2">def </span><span class="s1">_check_sharding(in_sharding</span><span class="s2">, </span><span class="s1">xmap_sharding</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">arr_flavor):</span>
    <span class="s2">if not </span><span class="s1">op_shardings.are_op_shardings_equal(</span>
        <span class="s1">in_sharding._to_xla_hlo_sharding(ndim)</span><span class="s2">,</span>
        <span class="s1">xmap_sharding._to_xla_hlo_sharding(ndim)):</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span>
          <span class="s3">f&quot;Got an input </span><span class="s2">{</span><span class="s1">arr_flavor</span><span class="s2">} </span><span class="s3">to xmap with different partitioning than &quot;</span>
          <span class="s3">&quot;specified in xmap. The partitioning must match. &quot;</span>
          <span class="s3">f&quot;Got </span><span class="s2">{</span><span class="s1">arr_flavor</span><span class="s2">} </span><span class="s3">spec: </span><span class="s2">{</span><span class="s1">in_sharding.spec</span><span class="s2">} </span><span class="s3">and &quot;</span>
          <span class="s3">f&quot;xmap spec: </span><span class="s2">{</span><span class="s1">xmap_sharding.spec</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s1">mesh_in_axes = EvaluationPlan.from_axis_resources(  </span><span class="s0"># pytype: disable=wrong-arg-types  # always-use-return-annotations</span>
      <span class="s1">axis_resources</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">global_axis_sizes).to_mesh_axes(in_axes_flat)</span>
  <span class="s2">for </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">xmap_array_mapping </span><span class="s2">in </span><span class="s1">safe_zip(args_flat</span><span class="s2">, </span><span class="s1">mesh_in_axes):</span>
    <span class="s2">if </span><span class="s1">isinstance(arg</span><span class="s2">, </span><span class="s1">ArrayImpl):</span>
      <span class="s2">if not </span><span class="s1">isinstance(arg.sharding</span><span class="s2">, </span><span class="s1">NamedSharding):</span>
        <span class="s2">continue</span>
      <span class="s1">mesh = arg.sharding.mesh</span>
      <span class="s2">if </span><span class="s1">mesh != resource_env.physical_mesh:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;xmap's mesh and Array's mesh should be equal. &quot;</span>
                         <span class="s3">f&quot;Got xmap mesh: </span><span class="s2">{</span><span class="s1">resource_env.physical_mesh</span><span class="s2">}</span><span class="s3">,</span><span class="s2">\n</span><span class="s3">&quot;</span>
                         <span class="s3">f&quot;Array mesh: </span><span class="s2">{</span><span class="s1">mesh</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

      <span class="s1">s = arg.sharding</span>
      <span class="s1">xmap_sharding = pxla.create_mesh_pspec_sharding(</span>
          <span class="s1">mesh</span><span class="s2">, </span><span class="s1">array_mapping_to_axis_resources(xmap_array_mapping))</span>
      <span class="s0"># This check is cached because comparing OpSharding is expensive during</span>
      <span class="s0"># dispatch and if the shardings are the same, then there is no need to</span>
      <span class="s0"># compare twice.</span>
      <span class="s1">_check_sharding(s</span><span class="s2">, </span><span class="s1">xmap_sharding</span><span class="s2">, </span><span class="s1">arg.ndim</span><span class="s2">, </span><span class="s3">'Array'</span><span class="s1">)</span>


<span class="s0"># TODO: We should relax this at least for &quot;constructor primitives&quot;</span>
<span class="s0">#       such as axis_index or zeros.</span>
<span class="s2">def </span><span class="s1">_check_no_loop_collectives(jaxpr</span><span class="s2">, </span><span class="s1">loop_axis_resources):</span>
  <span class="s2">if </span><span class="s1">isinstance(jaxpr</span><span class="s2">, </span><span class="s1">core.ClosedJaxpr):</span>
    <span class="s1">jaxpr = jaxpr.jaxpr</span>
  <span class="s2">def </span><span class="s1">subst_no_loop(name):</span>
    <span class="s2">if </span><span class="s1">loop_axis_resources.get(name</span><span class="s2">, </span><span class="s1">()):</span>
      <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">f&quot;Named axes with loop resources assigned to them cannot &quot;</span>
                          <span class="s3">f&quot;be referenced inside the xmapped computation (e.g. in &quot;</span>
                          <span class="s3">f&quot;collectives), but `</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">` violates that rule&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">(name</span><span class="s2">,</span><span class="s1">)</span>
  <span class="s2">for </span><span class="s1">eqn </span><span class="s2">in </span><span class="s1">jaxpr.eqns:</span>
    <span class="s1">core.subst_axis_names(eqn.primitive</span><span class="s2">, </span><span class="s1">eqn.params</span><span class="s2">, </span><span class="s1">subst_no_loop</span><span class="s2">, </span><span class="s1">traverse=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">rec = partial(_check_no_loop_collectives</span><span class="s2">, </span><span class="s1">loop_axis_resources=loop_axis_resources)</span>
    <span class="s1">core.traverse_jaxpr_params(rec</span><span class="s2">, </span><span class="s1">eqn.params)</span>


<span class="s2">def </span><span class="s1">_fix_inferred_spmd_sharding(jaxpr</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">gen_fresh_name = </span><span class="s2">None</span><span class="s1">):</span>
  <span class="s1">rec = </span><span class="s2">lambda </span><span class="s1">jaxpr: _fix_inferred_spmd_sharding(jaxpr</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">gen_fresh_name)</span>
  <span class="s2">if </span><span class="s1">isinstance(jaxpr</span><span class="s2">, </span><span class="s1">core.ClosedJaxpr):</span>
    <span class="s2">return </span><span class="s1">jaxpr.map_jaxpr(rec)</span>
  <span class="s2">assert </span><span class="s1">isinstance(jaxpr</span><span class="s2">, </span><span class="s1">core.Jaxpr)</span>
  <span class="s2">if </span><span class="s1">gen_fresh_name </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">gen_fresh_name = core.gensym([jaxpr])</span>
  <span class="s1">new_eqns = []</span>
  <span class="s2">for </span><span class="s1">eqn </span><span class="s2">in </span><span class="s1">jaxpr.eqns:</span>
    <span class="s1">new_jaxpr_params = core.traverse_jaxpr_params(rec</span><span class="s2">, </span><span class="s1">eqn.params)</span>
    <span class="s1">tmp_outvars = [gen_fresh_name(v.aval) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">eqn.outvars]</span>
    <span class="s1">new_eqns.append(eqn.replace(</span>
      <span class="s1">outvars=tmp_outvars</span><span class="s2">, </span><span class="s1">params=dict(eqn.params</span><span class="s2">, </span><span class="s1">**new_jaxpr_params)))</span>
    <span class="s2">for </span><span class="s1">outvar</span><span class="s2">, </span><span class="s1">tmpvar </span><span class="s2">in </span><span class="s1">zip(eqn.outvars</span><span class="s2">, </span><span class="s1">tmp_outvars):</span>
      <span class="s1">mps = NamedSharding._from_parsed_pspec(</span>
          <span class="s1">resource_env.physical_mesh</span><span class="s2">, </span><span class="s1">ParsedPartitionSpec(()</span><span class="s2">, </span><span class="s1">()))</span>
      <span class="s1">unconstrained_dims = get_unconstrained_dims(mps)</span>
      <span class="s1">gspmd_sharding = GSPMDSharding.get_replicated(mps._device_assignment)</span>
      <span class="s1">new_eqns.append(core.JaxprEqn(</span>
          <span class="s1">[tmpvar]</span><span class="s2">, </span><span class="s1">[outvar]</span><span class="s2">, </span><span class="s1">sharding_constraint_p</span><span class="s2">,</span>
          <span class="s1">dict(resource_env=resource_env</span><span class="s2">,</span>
               <span class="s1">sharding=gspmd_sharding</span><span class="s2">,</span>
               <span class="s1">unconstrained_dims=unconstrained_dims)</span><span class="s2">,</span>
          <span class="s1">set()</span><span class="s2">,</span>
          <span class="s1">eqn.source_info))</span>
  <span class="s2">return </span><span class="s1">jaxpr.replace(eqns=new_eqns)</span>

<span class="s2">def </span><span class="s1">_flatten_axes(what</span><span class="s2">, </span><span class="s1">tree</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">tupled_args):</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">tuple(flatten_axes(what</span><span class="s2">, </span><span class="s1">tree</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">tupled_args=tupled_args))</span>
  <span class="s2">except </span><span class="s1">ValueError:</span>
    <span class="s2">pass</span>
  <span class="s0"># Replace axis_resources with unparsed versions to avoid revealing internal details</span>
  <span class="s1">flatten_axes(what</span><span class="s2">, </span><span class="s1">tree</span><span class="s2">, </span><span class="s1">tree_map(</span><span class="s2">lambda </span><span class="s1">parsed: NoQuotesStr(parsed.user_repr)</span><span class="s2">, </span><span class="s1">axes)</span><span class="s2">,</span>
               <span class="s1">tupled_args=tupled_args)</span>
  <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s3">&quot;Please open a bug request!&quot;</span><span class="s1">)  </span><span class="s0"># This should be unreachable</span>

<span class="s2">class </span><span class="s1">NoQuotesStr(str):</span>
  <span class="s1">__repr__ = str.__str__</span>


<span class="s0"># -------- config flags --------</span>

<span class="s2">def </span><span class="s1">_thread_local_flag_unsupported(_):</span>
  <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;thread-local xmap flags not supported!&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">_clear_compilation_cache(_):</span>
  <span class="s1">make_xmap_callable.cache_clear()  </span><span class="s0"># type: ignore</span>

<span class="s2">def </span><span class="s1">_ensure_spmd_and(f):</span>
  <span class="s2">def </span><span class="s1">update(v):</span>
    <span class="s2">if </span><span class="s1">v </span><span class="s2">and not </span><span class="s1">config.experimental_xmap_spmd_lowering:</span>
      <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;This flag requires enabling the experimental_xmap_spmd_lowering flag&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">f(v)</span>
  <span class="s2">return </span><span class="s1">update</span>


<span class="s2">try</span><span class="s1">:</span>
  <span class="s1">config.define_bool_state(</span>
      <span class="s1">name=</span><span class="s3">&quot;experimental_xmap_spmd_lowering&quot;</span><span class="s2">,</span>
      <span class="s1">default=</span><span class="s2">False,</span>
      <span class="s1">help=(</span><span class="s3">&quot;When set, multi-device xmap computations will be compiled through &quot;</span>
            <span class="s3">&quot;the XLA SPMD partitioner instead of explicit cross-replica collectives. &quot;</span>
            <span class="s3">&quot;Not supported on CPU!&quot;</span><span class="s1">)</span><span class="s2">,</span>
      <span class="s1">update_global_hook=_clear_compilation_cache</span><span class="s2">,</span>
      <span class="s1">update_thread_local_hook=_thread_local_flag_unsupported)</span>
  <span class="s1">config.define_bool_state(</span>
      <span class="s1">name=</span><span class="s3">&quot;experimental_xmap_spmd_lowering_manual&quot;</span><span class="s2">,</span>
      <span class="s1">default=</span><span class="s2">False,</span>
      <span class="s1">help=(</span><span class="s3">&quot;When set, multi-device xmap computations will be compiled using &quot;</span>
            <span class="s3">&quot;the MANUAL partitioning feature of the XLA SPMD partitioner instead of &quot;</span>
            <span class="s3">&quot;sharding constraints on vectorized code. &quot;</span>
            <span class="s3">&quot;Requires experimental_xmap_spmd_lowering!&quot;</span><span class="s1">)</span><span class="s2">,</span>
      <span class="s1">update_global_hook=_ensure_spmd_and(_clear_compilation_cache)</span><span class="s2">,</span>
      <span class="s1">update_thread_local_hook=_thread_local_flag_unsupported)</span>
  <span class="s1">config.define_bool_state(</span>
      <span class="s1">name=</span><span class="s3">&quot;experimental_xmap_ensure_fixed_sharding&quot;</span><span class="s2">,</span>
      <span class="s1">default=</span><span class="s2">False,</span>
      <span class="s1">help=(</span><span class="s3">&quot;When set and `experimental_xmap_spmd_lowering` is enabled, the lowering will &quot;</span>
            <span class="s3">&quot;try to limit the flexibility of the automated SPMD partitioner heuristics &quot;</span>
            <span class="s3">&quot;by emitting additional sharding annotations for program intermediates.&quot;</span><span class="s1">)</span><span class="s2">,</span>
      <span class="s1">update_global_hook=_ensure_spmd_and(_clear_compilation_cache)</span><span class="s2">,</span>
      <span class="s1">update_thread_local_hook=_thread_local_flag_unsupported)</span>
<span class="s2">except </span><span class="s1">Exception:</span>
  <span class="s2">raise </span><span class="s1">ImportError(</span><span class="s3">&quot;jax.experimental.maps has to be imported before JAX flags &quot;</span>
                    <span class="s3">&quot;are parsed&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>