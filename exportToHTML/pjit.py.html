<html>
<head>
<title>pjit.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pjit.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2021 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">import </span><span class="s1">dataclasses</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">weakref</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(Callable</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">Union</span><span class="s2">, </span><span class="s1">cast</span><span class="s2">, </span><span class="s1">List</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">,</span>
                    <span class="s1">Iterable</span><span class="s2">, </span><span class="s1">NamedTuple</span><span class="s2">, </span><span class="s1">Any)</span>
<span class="s2">import </span><span class="s1">itertools </span><span class="s2">as </span><span class="s1">it</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span><span class="s2">, </span><span class="s1">lru_cache</span>
<span class="s2">import </span><span class="s1">threading</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">core</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">stages</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">dispatch</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">mesh </span><span class="s2">as </span><span class="s1">mesh_lib</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">linear_util </span><span class="s2">as </span><span class="s1">lu</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">op_shardings</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">sharding_impls</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">source_info_util</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">traceback_util</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">api</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">xla_bridge </span><span class="s2">as </span><span class="s1">xb</span>
<span class="s2">from </span><span class="s1">jax._src.api_util </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">argnums_partial_except</span><span class="s2">, </span><span class="s1">flatten_axes</span><span class="s2">, </span><span class="s1">flatten_fun</span><span class="s2">, </span><span class="s1">flatten_fun_nokwargs</span><span class="s2">,</span>
    <span class="s1">donation_vector</span><span class="s2">, </span><span class="s1">shaped_abstractify</span><span class="s2">, </span><span class="s1">check_callable</span><span class="s2">, </span><span class="s1">resolve_argnums</span><span class="s2">,</span>
    <span class="s1">argnames_partial_except</span><span class="s2">, </span><span class="s1">debug_info</span><span class="s2">, </span><span class="s1">result_paths</span><span class="s2">, </span><span class="s1">jaxpr_debug_info)</span>
<span class="s2">from </span><span class="s1">jax._src.errors </span><span class="s2">import </span><span class="s1">JAXTypeError</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">partial_eval </span><span class="s2">as </span><span class="s1">pe</span>
<span class="s2">from </span><span class="s1">jax._src.partition_spec </span><span class="s2">import </span><span class="s1">PartitionSpec</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">xla</span>

<span class="s2">from </span><span class="s1">jax._src.config </span><span class="s2">import </span><span class="s1">config</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">ad</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">batching</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">mlir</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">pxla</span>
<span class="s2">from </span><span class="s1">jax._src.lib.mlir </span><span class="s2">import </span><span class="s1">ir</span>
<span class="s2">from </span><span class="s1">jax._src.lib.mlir.dialects </span><span class="s2">import </span><span class="s1">func </span><span class="s2">as </span><span class="s1">func_dialect</span>
<span class="s2">from </span><span class="s1">jax._src.lib </span><span class="s2">import </span><span class="s1">xla_client </span><span class="s2">as </span><span class="s1">xc</span>
<span class="s2">from </span><span class="s1">jax._src.sharding_impls </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">NamedSharding</span><span class="s2">, </span><span class="s1">XLACompatibleSharding</span><span class="s2">, </span><span class="s1">GSPMDSharding</span><span class="s2">,</span>
    <span class="s1">XLADeviceAssignment</span><span class="s2">, </span><span class="s1">SingleDeviceSharding</span><span class="s2">, </span><span class="s1">PmapSharding</span><span class="s2">,</span>
    <span class="s1">AUTO</span><span class="s2">, </span><span class="s1">UNSPECIFIED</span><span class="s2">, </span><span class="s1">UnspecifiedValue</span><span class="s2">,</span>
    <span class="s1">ParsedPartitionSpec</span><span class="s2">, </span><span class="s1">SpecSync</span><span class="s2">, </span><span class="s1">get_single_pspec</span><span class="s2">, </span><span class="s1">is_auto</span><span class="s2">, </span><span class="s1">is_unspecified</span><span class="s2">,</span>
    <span class="s1">is_unspecified_or_auto</span><span class="s2">, </span><span class="s1">prepare_axis_resources</span><span class="s2">, </span><span class="s1">parse_flatten_op_sharding)</span>
<span class="s2">from </span><span class="s1">jax._src.traceback_util </span><span class="s2">import </span><span class="s1">api_boundary</span>
<span class="s2">from </span><span class="s1">jax._src.tree_util </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">tree_map</span><span class="s2">, </span><span class="s1">tree_flatten</span><span class="s2">, </span><span class="s1">tree_unflatten</span><span class="s2">, </span><span class="s1">treedef_is_leaf</span><span class="s2">, </span><span class="s1">tree_structure</span><span class="s2">,</span>
    <span class="s1">treedef_tuple</span><span class="s2">, </span><span class="s1">broadcast_prefix</span><span class="s2">, </span><span class="s1">all_leaves</span><span class="s2">,</span>
    <span class="s1">prefix_errors</span><span class="s2">, </span><span class="s1">generate_key_paths)</span>
<span class="s2">from </span><span class="s1">jax._src.util </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">HashableFunction</span><span class="s2">, </span><span class="s1">safe_map</span><span class="s2">, </span><span class="s1">safe_zip</span><span class="s2">, </span><span class="s1">wraps</span><span class="s2">,</span>
    <span class="s1">distributed_debug_log</span><span class="s2">, </span><span class="s1">split_list</span><span class="s2">, </span><span class="s1">weakref_lru_cache</span><span class="s2">,</span>
    <span class="s1">merge_lists</span><span class="s2">, </span><span class="s1">flatten</span><span class="s2">, </span><span class="s1">unflatten)</span>

<span class="s1">map</span><span class="s2">, </span><span class="s1">unsafe_map = safe_map</span><span class="s2">, </span><span class="s1">map</span>
<span class="s1">zip</span><span class="s2">, </span><span class="s1">unsafe_zip = safe_zip</span><span class="s2">, </span><span class="s1">zip</span>

<span class="s1">traceback_util.register_exclusion(__file__)</span>

<span class="s1">PjitSharding = Union[GSPMDSharding</span><span class="s2">, </span><span class="s1">UnspecifiedValue</span><span class="s2">, </span><span class="s1">AUTO]</span>
<span class="s1">PjitShardingMinusUnspecified = Union[GSPMDSharding</span><span class="s2">, </span><span class="s1">AUTO]</span>
<span class="s1">MeshSharding = Union[NamedSharding</span><span class="s2">, </span><span class="s1">UnspecifiedValue</span><span class="s2">, </span><span class="s1">AUTO]</span>
<span class="s1">MeshShardingMinusUnspecified = Union[NamedSharding</span><span class="s2">, </span><span class="s1">AUTO]</span>

<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s2">def </span><span class="s1">_try_infer_args(f</span><span class="s2">, </span><span class="s1">tree):</span>
  <span class="s1">dummy_args = tree_unflatten(tree</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False</span><span class="s1">] * tree.num_leaves)</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">inspect.signature(f).bind(*dummy_args)</span>
  <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">_find_arg_mismatch(arg_list</span><span class="s2">, </span><span class="s1">fails</span><span class="s2">, </span><span class="s1">fun_name):</span>
  <span class="s1">first_err</span><span class="s2">, </span><span class="s1">second_err = fails</span>
  <span class="s1">mismatched_args_msg = []</span>
  <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">inp_da</span><span class="s2">, </span><span class="s1">aval </span><span class="s2">in </span><span class="s1">arg_list:</span>
    <span class="s2">if </span><span class="s1">first_err.m_type == pxla.MismatchType.ARG_SHARDING:</span>
      <span class="s2">if </span><span class="s1">first_err.da == inp_da:</span>
        <span class="s1">mismatched_args_msg.append(</span>
            <span class="s1">(</span><span class="s3">f&quot;argument </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">of </span><span class="s2">{</span><span class="s1">fun_name</span><span class="s2">} </span><span class="s3">with shape </span><span class="s2">{</span><span class="s1">aval.str_short()</span><span class="s2">} </span><span class="s3">and &quot;</span>
             <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">first_err._dev_ids_plat_str</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">))</span>
        <span class="s2">break</span>

  <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">inp_da</span><span class="s2">, </span><span class="s1">aval </span><span class="s2">in </span><span class="s1">arg_list:</span>
    <span class="s2">if </span><span class="s1">second_err.m_type == pxla.MismatchType.ARG_SHARDING:</span>
      <span class="s2">if </span><span class="s1">second_err.da == inp_da:</span>
        <span class="s1">mismatched_args_msg.append(</span>
            <span class="s1">(</span><span class="s3">f&quot;argument </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">of </span><span class="s2">{</span><span class="s1">fun_name</span><span class="s2">} </span><span class="s3">with shape </span><span class="s2">{</span><span class="s1">aval.str_short()</span><span class="s2">} </span><span class="s3">and &quot;</span>
             <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">second_err._dev_ids_plat_str</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">))</span>
        <span class="s2">break</span>
  <span class="s2">return </span><span class="s1">mismatched_args_msg</span>

<span class="s0"># TODO(yashkatariya): Try to use debug_info that is populated in</span>
<span class="s0"># common_infer_params.</span>
<span class="s2">def </span><span class="s1">_get_arg_names(fun</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">args_flat):</span>
  <span class="s1">sig = _try_infer_args(fun</span><span class="s2">, </span><span class="s1">in_tree)</span>
  <span class="s1">args_aug = generate_key_paths(tree_unflatten(in_tree</span><span class="s2">, </span><span class="s1">args_flat))</span>

  <span class="s1">arg_names = []</span>
  <span class="s2">for </span><span class="s1">arg_key</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">args_aug:</span>
    <span class="s1">ak</span><span class="s2">, </span><span class="s1">*rem_keys = arg_key</span>
    <span class="s2">if </span><span class="s1">sig </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s1">loc = </span><span class="s3">''</span><span class="s1">.join(str(k) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">rem_keys)</span>
      <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">arg_name = </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">list(sig.arguments.keys())[ak.idx]</span><span class="s2">}{</span><span class="s1">loc</span><span class="s2">}</span><span class="s3">'</span>
      <span class="s2">except </span><span class="s1">IndexError:</span>
        <span class="s1">arg_name = </span><span class="s3">''  </span><span class="s0"># E.g. variadic positional argument.</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">arg_name = </span><span class="s3">''</span>
    <span class="s1">arg_names.append(arg_name)</span>
  <span class="s2">return </span><span class="s1">arg_names</span>


<span class="s2">def </span><span class="s1">_device_assignment_mismatch_error(fun_name</span><span class="s2">, </span><span class="s1">fails</span><span class="s2">, </span><span class="s1">args_flat</span><span class="s2">, </span><span class="s1">api_name</span><span class="s2">,</span>
                                      <span class="s1">arg_names):</span>
  <span class="s1">arg_list = []</span>
  <span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">n </span><span class="s2">in </span><span class="s1">zip(args_flat</span><span class="s2">, </span><span class="s1">arg_names):</span>
    <span class="s1">da = a.sharding._device_assignment </span><span class="s2">if </span><span class="s1">hasattr(a</span><span class="s2">, </span><span class="s3">'sharding'</span><span class="s1">) </span><span class="s2">else None</span>
    <span class="s1">arg_list.append((n</span><span class="s2">, </span><span class="s1">da</span><span class="s2">, </span><span class="s1">shaped_abstractify(a)))</span>

  <span class="s1">mismatched_args_msg = _find_arg_mismatch(arg_list</span><span class="s2">, </span><span class="s1">fails</span><span class="s2">, </span><span class="s1">fun_name)</span>

  <span class="s2">if </span><span class="s1">len(mismatched_args_msg) == </span><span class="s4">2</span><span class="s1">:</span>
    <span class="s1">first</span><span class="s2">, </span><span class="s1">second = mismatched_args_msg  </span><span class="s0"># pylint: disable=unbalanced-tuple-unpacking</span>
    <span class="s1">extra_msg = </span><span class="s3">f&quot; Got </span><span class="s2">{</span><span class="s1">first</span><span class="s2">} </span><span class="s3">and </span><span class="s2">{</span><span class="s1">second</span><span class="s2">}</span><span class="s3">&quot;</span>
  <span class="s2">elif </span><span class="s1">len(mismatched_args_msg) == </span><span class="s4">1</span><span class="s1">:</span>
    <span class="s1">first</span><span class="s2">, </span><span class="s1">second  = fails</span>
    <span class="s0"># Choose the failure left which is not already covered by ARG_SHARDING.</span>
    <span class="s1">left = second </span><span class="s2">if </span><span class="s1">first.m_type == pxla.MismatchType.ARG_SHARDING </span><span class="s2">else </span><span class="s1">first</span>
    <span class="s1">extra_msg = </span><span class="s3">f&quot; Got </span><span class="s2">{</span><span class="s1">mismatched_args_msg[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">} </span><span class="s3">and</span><span class="s2">{</span><span class="s1">left._str(api_name)</span><span class="s2">}</span><span class="s3">&quot;</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">first</span><span class="s2">, </span><span class="s1">second = fails</span>
    <span class="s1">extra_msg = </span><span class="s3">f&quot; Got</span><span class="s2">{</span><span class="s1">first._str(api_name)</span><span class="s2">} </span><span class="s3">and</span><span class="s2">{</span><span class="s1">second._str(api_name)</span><span class="s2">}</span><span class="s3">&quot;</span>
  <span class="s1">msg = (</span><span class="s3">f&quot;Received incompatible devices for </span><span class="s2">{</span><span class="s1">api_name</span><span class="s2">}</span><span class="s3">ted computation.</span><span class="s2">{</span><span class="s1">extra_msg</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
  <span class="s2">return </span><span class="s1">msg</span>


<span class="s2">def </span><span class="s1">_python_pjit_helper(fun</span><span class="s2">, </span><span class="s1">infer_params_fn</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
  <span class="s1">args_flat</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">jaxpr = infer_params_fn(</span>
      <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
  <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args_flat:</span>
    <span class="s1">dispatch.check_arg(arg)</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s1">out_flat = pjit_p.bind(*args_flat</span><span class="s2">, </span><span class="s1">**params)</span>
  <span class="s2">except </span><span class="s1">pxla.DeviceAssignmentMismatchError </span><span class="s2">as </span><span class="s1">e:</span>
    <span class="s1">fails</span><span class="s2">, </span><span class="s1">= e.args</span>
    <span class="s1">api_name = </span><span class="s3">'jit' </span><span class="s2">if </span><span class="s1">params[</span><span class="s3">'resource_env'</span><span class="s1">] </span><span class="s2">is None else </span><span class="s3">'pjit'</span>
    <span class="s1">arg_names = _get_arg_names(fun</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">args_flat)</span>
    <span class="s1">fun_name = getattr(fun</span><span class="s2">, </span><span class="s3">'__qualname__'</span><span class="s2">, </span><span class="s1">getattr(fun</span><span class="s2">, </span><span class="s3">'__name__'</span><span class="s2">, </span><span class="s1">str(fun)))</span>
    <span class="s1">msg = _device_assignment_mismatch_error(</span>
        <span class="s1">fun_name</span><span class="s2">, </span><span class="s1">fails</span><span class="s2">, </span><span class="s1">args_flat</span><span class="s2">, </span><span class="s1">api_name</span><span class="s2">, </span><span class="s1">arg_names)</span>
    <span class="s2">raise </span><span class="s1">ValueError(msg) </span><span class="s2">from None</span>
  <span class="s1">outs = tree_unflatten(out_tree</span><span class="s2">, </span><span class="s1">out_flat)</span>
  <span class="s2">return </span><span class="s1">outs</span><span class="s2">, </span><span class="s1">out_flat</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">, </span><span class="s1">args_flat</span><span class="s2">, </span><span class="s1">jaxpr</span>


<span class="s2">def </span><span class="s1">_python_pjit(fun: Callable</span><span class="s2">, </span><span class="s1">infer_params_fn):</span>

  <span class="s1">@wraps(fun)</span>
  <span class="s1">@api_boundary</span>
  <span class="s2">def </span><span class="s1">wrapped(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s2">if </span><span class="s1">config.jax_disable_jit:</span>
      <span class="s2">return </span><span class="s1">fun(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s2">return </span><span class="s1">_python_pjit_helper(fun</span><span class="s2">, </span><span class="s1">infer_params_fn</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)[</span><span class="s4">0</span><span class="s1">]</span>

  <span class="s2">def </span><span class="s1">_python_pjit_evict_fn():</span>
    <span class="s1">_create_pjit_jaxpr.evict_function(fun)  </span><span class="s0"># type: ignore</span>
  <span class="s1">wrapped.clear_cache = _python_pjit_evict_fn</span>
  <span class="s2">return </span><span class="s1">wrapped</span>


<span class="s2">def </span><span class="s1">_get_fastpath_data(executable</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">, </span><span class="s1">args_flat</span><span class="s2">, </span><span class="s1">out_flat):</span>
  <span class="s1">use_fastpath = (</span>
      <span class="s1">executable </span><span class="s2">is not None and</span>
      <span class="s1">isinstance(executable</span><span class="s2">, </span><span class="s1">pxla.MeshExecutable) </span><span class="s2">and</span>
      <span class="s1">isinstance(executable.unsafe_call</span><span class="s2">, </span><span class="s1">pxla.ExecuteReplicated) </span><span class="s2">and</span>
      <span class="s0"># No effects in computation</span>
      <span class="s2">not </span><span class="s1">executable.unsafe_call.ordered_effects </span><span class="s2">and</span>
      <span class="s2">not </span><span class="s1">executable.unsafe_call.has_unordered_effects </span><span class="s2">and</span>
      <span class="s2">not </span><span class="s1">executable.unsafe_call.has_host_callbacks </span><span class="s2">and</span>
      <span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">xc.ArrayImpl) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">out_flat)</span>
  <span class="s1">)</span>

  <span class="s2">if </span><span class="s1">use_fastpath:</span>
    <span class="s1">out_avals = [o.aval </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">out_flat]</span>
    <span class="s1">out_committed = [o._committed </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">out_flat]</span>
    <span class="s1">kept_var_bitvec = [i </span><span class="s2">in </span><span class="s1">executable._kept_var_idx</span>
                       <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(args_flat))]</span>
    <span class="s1">fastpath_data = pxla.MeshExecutableFastpathData(</span>
        <span class="s1">executable.xla_executable</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">, </span><span class="s1">executable._in_shardings</span><span class="s2">,</span>
        <span class="s1">executable._out_shardings</span><span class="s2">, </span><span class="s1">out_avals</span><span class="s2">, </span><span class="s1">out_committed</span><span class="s2">, </span><span class="s1">kept_var_bitvec)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">fastpath_data = </span><span class="s2">None</span>
  <span class="s2">return </span><span class="s1">fastpath_data</span>


<span class="s2">class </span><span class="s1">_MostRecentPjitCallExecutable(threading.local):</span>
  <span class="s2">def </span><span class="s1">__init__(self):</span>
    <span class="s1">self.weak_key_dict = weakref.WeakKeyDictionary()</span>

<span class="s1">_most_recent_pjit_call_executable = _MostRecentPjitCallExecutable()</span>


<span class="s2">def </span><span class="s1">_read_most_recent_pjit_call_executable(jaxpr):</span>
  <span class="s2">return </span><span class="s1">_most_recent_pjit_call_executable.weak_key_dict.get(jaxpr</span><span class="s2">, None</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_cpp_pjit_evict_fn(self):</span>
  <span class="s1">self._clear_cache()</span>
  <span class="s1">_create_pjit_jaxpr.evict_function(self._fun)  </span><span class="s0"># type: ignore</span>


<span class="s0"># The entries are doubled here from the default 4096 because _pjit_call_impl</span>
<span class="s0"># also has a cpp dispatch path and that would double the number of entries in</span>
<span class="s0"># the global shared cache.</span>
<span class="s1">_cpp_pjit_cache = xc._xla.PjitFunctionCache(capacity=</span><span class="s4">8192</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_get_cpp_global_cache(pjit_has_explicit_sharding):</span>
  <span class="s2">if </span><span class="s1">pjit_has_explicit_sharding:</span>
    <span class="s2">return </span><span class="s1">xc._xla.PjitFunctionCache()</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">_cpp_pjit_cache</span>


<span class="s2">def </span><span class="s1">_cpp_pjit(fun: Callable</span><span class="s2">, </span><span class="s1">infer_params_fn</span><span class="s2">, </span><span class="s1">static_argnums</span><span class="s2">, </span><span class="s1">static_argnames</span><span class="s2">,</span>
              <span class="s1">donate_argnums</span><span class="s2">, </span><span class="s1">pjit_has_explicit_sharding):</span>

  <span class="s1">@api_boundary</span>
  <span class="s2">def </span><span class="s1">cache_miss(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s1">outs</span><span class="s2">, </span><span class="s1">out_flat</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">, </span><span class="s1">args_flat</span><span class="s2">, </span><span class="s1">jaxpr = _python_pjit_helper(</span>
        <span class="s1">fun</span><span class="s2">, </span><span class="s1">infer_params_fn</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s1">executable = _read_most_recent_pjit_call_executable(jaxpr)</span>
    <span class="s1">fastpath_data = _get_fastpath_data(executable</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">, </span><span class="s1">args_flat</span><span class="s2">, </span><span class="s1">out_flat)</span>
    <span class="s2">return </span><span class="s1">outs</span><span class="s2">, </span><span class="s1">fastpath_data</span>

  <span class="s1">cpp_pjit_f = xc._xla.pjit(  </span><span class="s0"># type: ignore</span>
      <span class="s1">getattr(fun</span><span class="s2">, </span><span class="s3">&quot;__name__&quot;</span><span class="s2">, </span><span class="s3">&quot;&lt;unnamed function&gt;&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># type: ignore</span>
      <span class="s1">fun</span><span class="s2">, </span><span class="s1">cache_miss</span><span class="s2">, </span><span class="s1">static_argnums</span><span class="s2">, </span><span class="s1">static_argnames</span><span class="s2">,  </span><span class="s0"># type: ignore</span>
      <span class="s1">donate_argnums</span><span class="s2">, </span><span class="s1">_get_cpp_global_cache(pjit_has_explicit_sharding))  </span><span class="s0"># type: ignore</span>

  <span class="s1">cpp_pjitted_f = wraps(fun)(cpp_pjit_f)</span>
  <span class="s1">cpp_pjitted_f._fun = fun</span>
  <span class="s1">type(cpp_pjitted_f).clear_cache = _cpp_pjit_evict_fn</span>
  <span class="s2">return </span><span class="s1">cpp_pjitted_f</span>


<span class="s2">def </span><span class="s1">_resolve_axis_resources_and_shardings_arg(</span>
    <span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">in_axis_resources</span><span class="s2">, </span><span class="s1">out_axis_resources):</span>
  <span class="s2">if not </span><span class="s1">is_unspecified(in_shardings) </span><span class="s2">and not </span><span class="s1">is_unspecified(in_axis_resources):</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span>
        <span class="s3">'Setting both in_shardings and in_axis_resources is not '</span>
        <span class="s3">'allowed. in_axis_resources is deprecated. Please use in_shardings.'</span><span class="s1">)</span>
  <span class="s2">if not </span><span class="s1">is_unspecified(out_shardings) </span><span class="s2">and not </span><span class="s1">is_unspecified(out_axis_resources):</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span>
        <span class="s3">'Setting both out_shardings and out_axis_resources is not '</span>
        <span class="s3">'allowed. out_axis_resources is deprecated. Please use out_shardings.'</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">is_unspecified(in_axis_resources) </span><span class="s2">or</span>
      <span class="s2">not </span><span class="s1">is_unspecified(out_axis_resources)):</span>
    <span class="s1">warnings.warn(</span>
        <span class="s3">'in_axis_resources and out_axis_resources are deprecated. Please use '</span>
        <span class="s3">'in_shardings and out_shardings as their replacement.'</span><span class="s2">,</span>
        <span class="s1">DeprecationWarning)</span>

  <span class="s2">if not </span><span class="s1">is_unspecified(in_axis_resources):</span>
    <span class="s1">final_in_shardings = in_axis_resources</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">final_in_shardings = in_shardings</span>

  <span class="s2">if not </span><span class="s1">is_unspecified(out_axis_resources):</span>
    <span class="s1">final_out_shardings = out_axis_resources</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">final_out_shardings = out_shardings</span>
  <span class="s2">return </span><span class="s1">final_in_shardings</span><span class="s2">, </span><span class="s1">final_out_shardings</span>


<span class="s2">def </span><span class="s1">pre_infer_params(fun</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">,</span>
                     <span class="s1">donate_argnums</span><span class="s2">, </span><span class="s1">static_argnums</span><span class="s2">, </span><span class="s1">static_argnames</span><span class="s2">, </span><span class="s1">device</span><span class="s2">,</span>
                     <span class="s1">backend</span><span class="s2">, </span><span class="s1">abstracted_axes):</span>
  <span class="s2">if </span><span class="s1">abstracted_axes </span><span class="s2">and not </span><span class="s1">config.jax_dynamic_shapes:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;abstracted_axes must be used with --jax_dynamic_shapes&quot;</span><span class="s1">)</span>

  <span class="s1">check_callable(fun)</span>

  <span class="s2">if </span><span class="s1">backend </span><span class="s2">is not None or </span><span class="s1">device </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s1">warnings.warn(</span>
        <span class="s3">'backend and device argument on jit is deprecated. You can use a '</span>
        <span class="s3">'`jax.sharding.Mesh` context manager or device_put the arguments '</span>
        <span class="s3">'before passing them to `jit`. Please see '</span>
        <span class="s3">'https://jax.readthedocs.io/en/latest/notebooks/Distributed_arrays_and_automatic_parallelization.html '</span>
        <span class="s3">'for more information.'</span><span class="s2">, </span><span class="s1">DeprecationWarning)</span>
    <span class="s2">if </span><span class="s1">device </span><span class="s2">is not None and </span><span class="s1">backend </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;can't specify both a device and a backend for jit, &quot;</span>
                       <span class="s3">f&quot;got </span><span class="s2">{</span><span class="s1">device=</span><span class="s2">} </span><span class="s3">and </span><span class="s2">{</span><span class="s1">backend=</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">is_unspecified(in_shardings):</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'If backend or device is specified on jit, then '</span>
                       <span class="s3">'in_shardings should not be specified.'</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">is_unspecified(out_shardings):</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'If backend or device is specified on jit, then '</span>
                       <span class="s3">'out_shardings should not be specified.'</span><span class="s1">)</span>

  <span class="s2">if </span><span class="s1">isinstance(in_shardings</span><span class="s2">, </span><span class="s1">list):</span>
    <span class="s0"># To be a tree prefix of the positional args tuple, in_axes can never be a</span>
    <span class="s0"># list: if in_axes is not a leaf, it must be a tuple of trees. However,</span>
    <span class="s0"># in cases like these users expect tuples and lists to be treated</span>
    <span class="s0"># essentially interchangeably, so we canonicalize lists to tuples here</span>
    <span class="s0"># rather than raising an error. https://github.com/google/jax/issues/2367</span>
    <span class="s1">in_shardings = tuple(in_shardings)</span>

  <span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = prepare_axis_resources(in_shardings</span><span class="s2">, </span><span class="s3">'in_shardings'</span><span class="s1">)</span>
  <span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = prepare_axis_resources(out_shardings</span><span class="s2">, </span><span class="s3">'out_shardings'</span><span class="s1">)</span>

  <span class="s1">donate_argnums</span><span class="s2">, </span><span class="s1">static_argnums</span><span class="s2">, </span><span class="s1">static_argnames = resolve_argnums(</span>
      <span class="s1">fun</span><span class="s2">, </span><span class="s1">donate_argnums</span><span class="s2">, </span><span class="s1">static_argnums</span><span class="s2">, </span><span class="s1">static_argnames)</span>

  <span class="s2">return </span><span class="s1">(in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">donate_argnums</span><span class="s2">, </span><span class="s1">static_argnums</span><span class="s2">,</span>
          <span class="s1">static_argnames)</span>


<span class="s2">def </span><span class="s1">post_infer_params(fun</span><span class="s2">, </span><span class="s1">infer_params_fn</span><span class="s2">, </span><span class="s1">static_argnums</span><span class="s2">, </span><span class="s1">static_argnames</span><span class="s2">,</span>
                      <span class="s1">donate_argnums</span><span class="s2">, </span><span class="s1">abstracted_axes</span><span class="s2">,</span>
                      <span class="s1">pjit_has_explicit_sharding):</span>
  <span class="s2">if </span><span class="s1">abstracted_axes </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">wrapped = _cpp_pjit(fun</span><span class="s2">, </span><span class="s1">infer_params_fn</span><span class="s2">, </span><span class="s1">static_argnums</span><span class="s2">, </span><span class="s1">static_argnames</span><span class="s2">,</span>
                        <span class="s1">donate_argnums</span><span class="s2">, </span><span class="s1">pjit_has_explicit_sharding)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">wrapped = _python_pjit(fun</span><span class="s2">, </span><span class="s1">infer_params_fn)</span>

  <span class="s1">@api_boundary</span>
  <span class="s2">def </span><span class="s1">lower(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s1">_experimental_lowering_platform = kwargs.pop(</span>
        <span class="s3">'_experimental_lowering_platform'</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s1">(args_flat</span><span class="s2">, </span><span class="s1">flat_global_in_avals</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">,</span>
     <span class="s1">donate_argnums</span><span class="s2">, </span><span class="s1">_) = infer_params_fn(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s1">resource_env = params[</span><span class="s3">'resource_env'</span><span class="s1">]</span>
    <span class="s1">mesh = </span><span class="s2">None if </span><span class="s1">resource_env </span><span class="s2">is None else </span><span class="s1">resource_env.physical_mesh</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s1">in_shardings = _resolve_in_shardings(</span>
          <span class="s1">args_flat</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'in_shardings'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'out_shardings'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mesh)</span>
      <span class="s1">lowering = _pjit_lower(</span>
          <span class="s1">params[</span><span class="s3">'jaxpr'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'out_shardings'</span><span class="s1">]</span><span class="s2">,</span>
          <span class="s1">params[</span><span class="s3">'resource_env'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'donated_invars'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'name'</span><span class="s1">]</span><span class="s2">,</span>
          <span class="s1">params[</span><span class="s3">'keep_unused'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'inline'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">always_lower=</span><span class="s2">True,</span>
          <span class="s1">lowering_platform=_experimental_lowering_platform)</span>
    <span class="s2">except </span><span class="s1">pxla.DeviceAssignmentMismatchError </span><span class="s2">as </span><span class="s1">e:</span>
      <span class="s1">fails</span><span class="s2">, </span><span class="s1">= e.args</span>
      <span class="s1">api_name = </span><span class="s3">'jit' </span><span class="s2">if </span><span class="s1">params[</span><span class="s3">'resource_env'</span><span class="s1">] </span><span class="s2">is None else </span><span class="s3">'pjit'</span>
      <span class="s1">arg_names = _get_arg_names(fun</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">args_flat)</span>
      <span class="s1">fun_name = getattr(fun</span><span class="s2">, </span><span class="s3">'__qualname__'</span><span class="s2">, </span><span class="s1">getattr(fun</span><span class="s2">, </span><span class="s3">'__name__'</span><span class="s2">, </span><span class="s1">str(fun)))</span>
      <span class="s1">msg = _device_assignment_mismatch_error(</span>
          <span class="s1">fun_name</span><span class="s2">, </span><span class="s1">fails</span><span class="s2">, </span><span class="s1">args_flat</span><span class="s2">, </span><span class="s1">api_name</span><span class="s2">, </span><span class="s1">arg_names)</span>
      <span class="s2">raise </span><span class="s1">ValueError(msg) </span><span class="s2">from None</span>

    <span class="s2">if </span><span class="s1">kwargs:</span>
      <span class="s1">args_kwargs_in_tree = in_tree</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">args_kwargs_in_tree = treedef_tuple([in_tree</span><span class="s2">, </span><span class="s1">tree_flatten({})[</span><span class="s4">1</span><span class="s1">]])</span>

    <span class="s2">return </span><span class="s1">stages.Lowered.from_flat_info(</span>
        <span class="s1">lowering</span><span class="s2">, </span><span class="s1">args_kwargs_in_tree</span><span class="s2">, </span><span class="s1">flat_global_in_avals</span><span class="s2">, </span><span class="s1">donate_argnums</span><span class="s2">,</span>
        <span class="s1">out_tree)</span>

  <span class="s1">wrapped.lower = lower</span>
  <span class="s2">return </span><span class="s1">wrapped</span>


<span class="s2">def </span><span class="s1">_pjit_explicit_sharding(in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">device</span><span class="s2">,</span>
                            <span class="s1">backend) -&gt; bool:</span>
  <span class="s1">in_shardings_flat</span><span class="s2">, </span><span class="s1">_ = tree_flatten(in_shardings)</span>
  <span class="s1">out_shardings_flat</span><span class="s2">, </span><span class="s1">_ = tree_flatten(out_shardings)</span>
  <span class="s2">return </span><span class="s1">(device </span><span class="s2">is not None or</span>
          <span class="s1">backend </span><span class="s2">is not None or</span>
          <span class="s1">any(</span><span class="s2">not </span><span class="s1">is_unspecified(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">in_shardings_flat) </span><span class="s2">or</span>
          <span class="s1">any(</span><span class="s2">not </span><span class="s1">is_unspecified(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">out_shardings_flat))</span>


<span class="s2">class </span><span class="s1">PjitInfo(NamedTuple):</span>
  <span class="s1">fun: Callable</span>
  <span class="s1">in_shardings: Any</span>
  <span class="s1">out_shardings: Any</span>
  <span class="s1">static_argnums: Tuple[int</span><span class="s2">, </span><span class="s1">...]</span>
  <span class="s1">static_argnames: Tuple[str</span><span class="s2">, </span><span class="s1">...]</span>
  <span class="s1">donate_argnums: Tuple[int</span><span class="s2">, </span><span class="s1">...]</span>
  <span class="s1">device: Optional[xc.Device]</span>
  <span class="s1">backend: Optional[str]</span>
  <span class="s1">keep_unused: bool</span>
  <span class="s1">inline: bool</span>
  <span class="s1">resource_env: Any</span>
  <span class="s1">abstracted_axes: Optional[Any]</span>


<span class="s2">def </span><span class="s1">common_infer_params(pjit_info_args</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
  <span class="s1">(fun</span><span class="s2">, </span><span class="s1">user_in_shardings</span><span class="s2">, </span><span class="s1">user_out_shardings</span><span class="s2">, </span><span class="s1">static_argnums</span><span class="s2">, </span><span class="s1">static_argnames</span><span class="s2">,</span>
   <span class="s1">donate_argnums</span><span class="s2">, </span><span class="s1">device</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">, </span><span class="s1">keep_unused</span><span class="s2">, </span><span class="s1">inline</span><span class="s2">,</span>
   <span class="s1">resource_env</span><span class="s2">, </span><span class="s1">abstracted_axes) = pjit_info_args</span>

  <span class="s2">if </span><span class="s1">kwargs </span><span class="s2">and not </span><span class="s1">is_unspecified(user_in_shardings):</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span>
        <span class="s3">&quot;pjit does not support kwargs when in_shardings is specified.&quot;</span><span class="s1">)</span>

  <span class="s2">if </span><span class="s1">resource_env </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s1">pjit_mesh = resource_env.physical_mesh</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">pjit_mesh = </span><span class="s2">None</span>

  <span class="s2">if </span><span class="s1">(backend </span><span class="s2">or </span><span class="s1">device) </span><span class="s2">and </span><span class="s1">pjit_mesh </span><span class="s2">is not None and not </span><span class="s1">pjit_mesh.empty:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span>
        <span class="s3">&quot;Mesh context manager should not be used with jit when backend or &quot;</span>
        <span class="s3">&quot;device is also specified as an argument to jit.&quot;</span><span class="s1">)</span>

  <span class="s1">axes_specs = _flat_axes_specs(abstracted_axes</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

  <span class="s1">jit_name = </span><span class="s3">'jit' </span><span class="s2">if </span><span class="s1">resource_env </span><span class="s2">is None else </span><span class="s3">'pjit'</span>
  <span class="s1">dbg = debug_info(jit_name</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">static_argnums</span><span class="s2">, </span><span class="s1">static_argnames)</span>
  <span class="s1">f = lu.wrap_init(fun)</span>
  <span class="s1">f</span><span class="s2">, </span><span class="s1">res_paths = result_paths(f)</span>
  <span class="s1">f</span><span class="s2">, </span><span class="s1">dyn_args = argnums_partial_except(f</span><span class="s2">, </span><span class="s1">static_argnums</span><span class="s2">, </span><span class="s1">args</span><span class="s2">,</span>
                                       <span class="s1">allow_invalid=</span><span class="s2">True</span><span class="s1">)</span>
  <span class="s2">del </span><span class="s1">args</span>

  <span class="s0"># TODO(yashkatariya): Merge the nokwargs and kwargs path. One blocker is</span>
  <span class="s0"># flatten_axes which if kwargs are present in the treedef (even empty {}),</span>
  <span class="s0"># leads to wrong expansion.</span>
  <span class="s2">if </span><span class="s1">kwargs:</span>
    <span class="s1">f</span><span class="s2">, </span><span class="s1">dyn_kwargs = argnames_partial_except(f</span><span class="s2">, </span><span class="s1">static_argnames</span><span class="s2">, </span><span class="s1">kwargs)</span>
    <span class="s1">explicit_args</span><span class="s2">, </span><span class="s1">in_tree = tree_flatten((dyn_args</span><span class="s2">, </span><span class="s1">dyn_kwargs))</span>
    <span class="s1">flat_fun</span><span class="s2">, </span><span class="s1">out_tree = flatten_fun(f</span><span class="s2">, </span><span class="s1">in_tree)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">explicit_args</span><span class="s2">, </span><span class="s1">in_tree = tree_flatten(dyn_args)</span>
    <span class="s1">flat_fun</span><span class="s2">, </span><span class="s1">out_tree = flatten_fun_nokwargs(f</span><span class="s2">, </span><span class="s1">in_tree)</span>
    <span class="s1">dyn_kwargs = ()</span>
  <span class="s2">del </span><span class="s1">kwargs</span>

  <span class="s2">if </span><span class="s1">donate_argnums </span><span class="s2">and not </span><span class="s1">config.jax_debug_nans:</span>
    <span class="s1">donated_invars = donation_vector(donate_argnums</span><span class="s2">, </span><span class="s1">dyn_args</span><span class="s2">, </span><span class="s1">dyn_kwargs)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">donated_invars = (</span><span class="s2">False,</span><span class="s1">) * len(explicit_args)</span>

  <span class="s0"># If backend or device is set as an arg on jit, then resolve them to</span>
  <span class="s0"># in_shardings and out_shardings as if user passed in in_shardings</span>
  <span class="s0"># and out_shardings.</span>
  <span class="s1">device_or_backend_set = </span><span class="s2">False</span>
  <span class="s2">if </span><span class="s1">backend </span><span class="s2">or </span><span class="s1">device:</span>
    <span class="s1">in_shardings = out_shardings = _create_sharding_with_device_backend(</span>
        <span class="s1">device</span><span class="s2">, </span><span class="s1">backend)</span>
    <span class="s1">device_or_backend_set = </span><span class="s2">True</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">in_shardings = tree_map(</span>
        <span class="s2">lambda </span><span class="s1">x: _create_sharding_for_array(pjit_mesh</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s3">'in_shardings'</span><span class="s2">,</span>
                                             <span class="s1">jit_name)</span><span class="s2">,</span>
        <span class="s1">user_in_shardings)</span>
    <span class="s1">out_shardings = tree_map(</span>
        <span class="s2">lambda </span><span class="s1">x: _create_sharding_for_array(pjit_mesh</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s3">'out_shardings'</span><span class="s2">,</span>
                                             <span class="s1">jit_name)</span><span class="s2">,</span>
        <span class="s1">user_out_shardings)</span>

  <span class="s2">del </span><span class="s1">user_in_shardings</span><span class="s2">, </span><span class="s1">user_out_shardings</span>

  <span class="s2">if </span><span class="s1">config.jax_dynamic_shapes:</span>
    <span class="s1">in_type = pe.infer_lambda_input_type(axes_specs</span><span class="s2">, </span><span class="s1">explicit_args)</span>
    <span class="s1">in_avals = tuple(a </span><span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">e </span><span class="s2">in </span><span class="s1">in_type </span><span class="s2">if </span><span class="s1">e)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">avals = []</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">a </span><span class="s2">in </span><span class="s1">enumerate(explicit_args):</span>
      <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">avals.append(shaped_abstractify(a))</span>
      <span class="s2">except </span><span class="s1">OverflowError </span><span class="s2">as </span><span class="s1">e:</span>
        <span class="s1">arg_path = (</span><span class="s3">f&quot;argument path is </span><span class="s2">{</span><span class="s1">dbg.arg_names[i]</span><span class="s2">}</span><span class="s3">&quot; </span><span class="s2">if </span><span class="s1">dbg</span>
                    <span class="s2">else </span><span class="s3">f&quot;flattened argument number is </span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">OverflowError(</span>
          <span class="s3">&quot;An overflow was encountered while parsing an argument to a jitted &quot;</span>
          <span class="s3">f&quot;computation, whose </span><span class="s2">{</span><span class="s1">arg_path</span><span class="s2">}</span><span class="s3">.&quot;</span>
        <span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
    <span class="s1">in_type = in_avals = tuple(avals)</span>

  <span class="s1">canonicalized_in_shardings_flat = _process_in_axis_resources(</span>
      <span class="s1">hashable_pytree(in_shardings)</span><span class="s2">, </span><span class="s1">in_avals</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">dbg</span><span class="s2">,</span>
      <span class="s1">device_or_backend_set)</span>

  <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">consts</span><span class="s2">, </span><span class="s1">canonicalized_out_shardings_flat = _pjit_jaxpr(</span>
      <span class="s1">flat_fun</span><span class="s2">, </span><span class="s1">hashable_pytree(out_shardings)</span><span class="s2">, </span><span class="s1">in_type</span><span class="s2">, </span><span class="s1">dbg</span><span class="s2">,</span>
      <span class="s1">device_or_backend_set</span><span class="s2">, </span><span class="s1">HashableFunction(out_tree</span><span class="s2">, </span><span class="s1">closure=())</span><span class="s2">,</span>
      <span class="s1">HashableFunction(res_paths</span><span class="s2">, </span><span class="s1">closure=()))</span>

  <span class="s2">assert </span><span class="s1">len(explicit_args) == len(canonicalized_in_shardings_flat)</span>

  <span class="s2">if </span><span class="s1">config.jax_dynamic_shapes:</span>
    <span class="s1">implicit_args = _extract_implicit_args(in_type</span><span class="s2">, </span><span class="s1">explicit_args)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">implicit_args = []</span>
  <span class="s1">args_flat = [*implicit_args</span><span class="s2">, </span><span class="s1">*explicit_args]</span>

  <span class="s1">num_extra_args = len(implicit_args) + len(consts)</span>
  <span class="s1">canonicalized_in_shardings_flat = \</span>
      <span class="s1">(UNSPECIFIED</span><span class="s2">,</span><span class="s1">) * num_extra_args + canonicalized_in_shardings_flat</span>
  <span class="s1">donated_invars = (</span><span class="s2">False,</span><span class="s1">) * num_extra_args + donated_invars</span>
  <span class="s2">assert </span><span class="s1">(len(canonicalized_in_shardings_flat) == len(donated_invars) ==</span>
          <span class="s1">len(consts) + len(args_flat))</span>

  <span class="s0"># in_shardings and out_shardings here are all GSPMDSharding.</span>
  <span class="s1">params = dict(</span>
      <span class="s1">jaxpr=jaxpr</span><span class="s2">,</span>
      <span class="s1">in_shardings=canonicalized_in_shardings_flat</span><span class="s2">,</span>
      <span class="s1">out_shardings=canonicalized_out_shardings_flat</span><span class="s2">,</span>
      <span class="s1">resource_env=resource_env</span><span class="s2">,</span>
      <span class="s1">donated_invars=donated_invars</span><span class="s2">,</span>
      <span class="s1">name=getattr(flat_fun</span><span class="s2">, </span><span class="s3">'__name__'</span><span class="s2">, </span><span class="s3">'&lt;unnamed function&gt;'</span><span class="s1">)</span><span class="s2">,</span>
      <span class="s1">keep_unused=keep_unused</span><span class="s2">,</span>
      <span class="s1">inline=inline</span><span class="s2">,</span>
  <span class="s1">)</span>
  <span class="s2">return </span><span class="s1">(consts + args_flat</span><span class="s2">, </span><span class="s1">in_type</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">out_tree()</span><span class="s2">,</span>
          <span class="s1">donate_argnums</span><span class="s2">, </span><span class="s1">jaxpr)</span>

<span class="s2">def </span><span class="s1">_extract_implicit_args(</span>
  <span class="s1">in_type: Sequence[Tuple[core.AbstractValue</span><span class="s2">, </span><span class="s1">bool]]</span><span class="s2">,</span>
  <span class="s1">explicit_args: Sequence[Any]</span>
<span class="s1">) -&gt; Sequence[core.Tracer]:</span>
  <span class="s5">&quot;&quot;&quot; 
  Given an input type and explicitly-passed arguments (per the user-facing API 
  calling convention), extract implicit axis size arguments from shapes of 
  explicit arguments (for the trace-time / jaxpr-level calling convention). 
  &quot;&quot;&quot;</span>
  <span class="s0"># First, using `in_type` construct a list to represent the full argument list,</span>
  <span class="s0"># leaving the implicit arguments as None placeholders for now.</span>
  <span class="s1">explicit_args_ = iter(explicit_args)</span>
  <span class="s1">args = [next(explicit_args_) </span><span class="s2">if </span><span class="s1">expl </span><span class="s2">else None for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">expl </span><span class="s2">in </span><span class="s1">in_type]</span>
  <span class="s2">assert </span><span class="s1">next(explicit_args_</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is None</span>
  <span class="s2">del </span><span class="s1">explicit_args</span><span class="s2">, </span><span class="s1">explicit_args_</span>

  <span class="s0"># Next, populate the implicit arguments using the DBIdxs in `in_type`.</span>
  <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(aval</span><span class="s2">, </span><span class="s1">explicit) </span><span class="s2">in </span><span class="s1">enumerate(in_type):</span>
    <span class="s2">if not </span><span class="s1">explicit </span><span class="s2">or not </span><span class="s1">isinstance(aval</span><span class="s2">, </span><span class="s1">core.DShapedArray):</span>
      <span class="s2">continue  </span><span class="s0"># can't populate an implicit argument</span>
    <span class="s1">arg = args[i]</span>
    <span class="s2">assert </span><span class="s1">arg </span><span class="s2">is not None</span>
    <span class="s2">for </span><span class="s1">d1</span><span class="s2">, </span><span class="s1">d2 </span><span class="s2">in </span><span class="s1">zip(aval.shape</span><span class="s2">, </span><span class="s1">arg.aval.shape):</span>
      <span class="s2">if </span><span class="s1">isinstance(d1</span><span class="s2">, </span><span class="s1">core.DBIdx):</span>
        <span class="s2">if </span><span class="s1">args[d1.val] </span><span class="s2">is None</span><span class="s1">:</span>
          <span class="s1">args[d1.val] = d2</span>
        <span class="s2">assert </span><span class="s1">core.same_referent(args[d1.val]</span><span class="s2">, </span><span class="s1">d2)</span>
  <span class="s2">assert </span><span class="s1">all(x </span><span class="s2">is not None for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">args)</span>
  <span class="s2">return </span><span class="s1">[x </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">(_</span><span class="s2">, </span><span class="s1">e) </span><span class="s2">in </span><span class="s1">zip(args</span><span class="s2">, </span><span class="s1">in_type) </span><span class="s2">if not </span><span class="s1">e]  </span><span class="s0"># type: ignore</span>

<span class="s2">def </span><span class="s1">_flat_axes_specs(abstracted_axes</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs</span>
                     <span class="s1">) -&gt; Optional[List[pe.AbstractedAxesSpec]]:</span>
  <span class="s2">if </span><span class="s1">abstracted_axes </span><span class="s2">is None</span><span class="s1">: </span><span class="s2">return None</span>
  <span class="s2">if </span><span class="s1">kwargs: </span><span class="s2">raise </span><span class="s1">NotImplementedError</span>
  <span class="s2">def </span><span class="s1">ax_leaf(l):</span>
    <span class="s2">return </span><span class="s1">(isinstance(l</span><span class="s2">, </span><span class="s1">dict) </span><span class="s2">and </span><span class="s1">all_leaves(l.values()) </span><span class="s2">or</span>
            <span class="s1">isinstance(l</span><span class="s2">, </span><span class="s1">tuple) </span><span class="s2">and </span><span class="s1">all_leaves(l</span><span class="s2">, lambda </span><span class="s1">x: x </span><span class="s2">is None</span><span class="s1">))</span>
  <span class="s2">return </span><span class="s1">broadcast_prefix(abstracted_axes</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">ax_leaf)</span>


<span class="s0"># in_shardings and out_shardings can't be None as the default value</span>
<span class="s0"># because `None` means that the input is fully replicated.</span>
<span class="s2">def </span><span class="s1">pjit(</span>
    <span class="s1">fun: Callable</span><span class="s2">,</span>
    <span class="s1">in_shardings=UNSPECIFIED</span><span class="s2">,</span>
    <span class="s1">out_shardings=UNSPECIFIED</span><span class="s2">,</span>
    <span class="s1">in_axis_resources=UNSPECIFIED</span><span class="s2">,</span>
    <span class="s1">out_axis_resources=UNSPECIFIED</span><span class="s2">,</span>
    <span class="s1">static_argnums: Union[int</span><span class="s2">, </span><span class="s1">Sequence[int]</span><span class="s2">, None</span><span class="s1">] = </span><span class="s2">None,</span>
    <span class="s1">static_argnames: Union[str</span><span class="s2">, </span><span class="s1">Iterable[str]</span><span class="s2">, None</span><span class="s1">] = </span><span class="s2">None,</span>
    <span class="s1">donate_argnums: Union[int</span><span class="s2">, </span><span class="s1">Sequence[int]] = ()</span><span class="s2">,</span>
    <span class="s1">keep_unused: bool = </span><span class="s2">False,</span>
    <span class="s1">device: Optional[xc.Device] = </span><span class="s2">None,</span>
    <span class="s1">backend: Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">inline: bool = </span><span class="s2">False,</span>
    <span class="s1">abstracted_axes: Optional[Any] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; stages.Wrapped:</span>
  <span class="s5">&quot;&quot;&quot;Makes ``fun`` compiled and automatically partitioned across multiple devices. 
 
  NOTE: This function is now equivalent to jax.jit please use that instead. 
  The returned function has semantics equivalent to those of ``fun``, but is 
  compiled to an XLA computation that runs across multiple devices 
  (e.g. multiple GPUs or multiple TPU cores). This can be useful if the jitted 
  version of ``fun`` would not fit in a single device's memory, or to speed up 
  ``fun`` by running each operation in parallel across multiple devices. 
 
  The partitioning over devices happens automatically based on the 
  propagation of the input partitioning specified in ``in_shardings`` and 
  the output partitioning specified in ``out_shardings``. The resources 
  specified in those two arguments must refer to mesh axes, as defined by 
  the :py:func:`jax.sharding.Mesh` context manager. Note that the mesh 
  definition at :func:`~pjit` application time is ignored, and the returned function 
  will use the mesh definition available at each call site. 
 
  Inputs to a :func:`~pjit`'d function will be automatically partitioned across devices 
  if they're not already correctly partitioned based on ``in_shardings``. 
  In some scenarios, ensuring that the inputs are already correctly pre-partitioned 
  can increase performance. For example, if passing the output of one 
  :func:`~pjit`'d function to another :func:`~pjit`’d function (or the same 
  :func:`~pjit`’d function in a loop), make sure the relevant 
  ``out_shardings`` match the corresponding ``in_shardings``. 
 
  .. note:: 
    **Multi-process platforms:** On multi-process platforms such as TPU pods, 
    :func:`~pjit` can be used to run computations across all available devices across 
    processes. To achieve this, :func:`~pjit` is designed to be used in SPMD Python 
    programs, where every process is running the same Python code such that all 
    processes run the same :func:`~pjit`'d function in the same order. 
 
    When running in this configuration, the mesh should contain devices across 
    all processes. However, any input argument dimensions partitioned over 
    multi-process mesh axes should be of size equal to the corresponding *local* 
    mesh axis size, and outputs will be similarly sized according to the local 
    mesh. ``fun`` will still be executed across *all* devices in the mesh, 
    including those from other processes, and will be given a global view of the 
    data spread across multiple processes as a single array. However, outside 
    of :func:`~pjit` every process only &quot;sees&quot; its local piece of the input and output, 
    corresponding to its local sub-mesh. 
 
    This means that each process's participating local devices must form a 
    _contiguous_ local sub-mesh within the full global mesh. A contiguous 
    sub-mesh is one where all of its devices are adjacent within the global 
    mesh, and form a rectangular prism. 
 
    The SPMD model also requires that the same multi-process :func:`~pjit`'d 
    functions must be run in the same order on all processes, but they can be 
    interspersed with arbitrary operations running in a single process. 
 
  Args: 
    fun: Function to be compiled. Should be a pure function, as side-effects may 
      only be executed once. Its arguments and return value should be arrays, 
      scalars, or (nested) standard Python containers (tuple/list/dict) thereof. 
      Positional arguments indicated by ``static_argnums`` can be anything at 
      all, provided they are hashable and have an equality operation defined. 
      Static arguments are included as part of a compilation cache key, which is 
      why hash and equality operators must be defined. 
    in_shardings: Pytree of structure matching that of arguments to ``fun``, 
      with all actual arguments replaced by resource assignment specifications. 
      It is also valid to specify a pytree prefix (e.g. one value in place of a 
      whole subtree), in which case the leaves get broadcast to all values in 
      that subtree. 
 
      The ``in_shardings`` argument is optional. JAX will infer the shardings 
      from the input :py:class:`jax.Array`'s, and defaults to replicating the input 
      if the sharding cannot be inferred. 
 
      The valid resource assignment specifications are: 
 
      - :py:class:`XLACompatibleSharding`, which will decide how the value 
        will be partitioned. With this, using a mesh context manager is not 
        required. 
      - For backwards compatibility, in_shardings still supports ingesting 
        :py:class:`PartitionSpec` and :py:obj:`None`. These 2 options can 
        *only* be used with the mesh context manager. 
 
        - :py:obj:`None`, in which case the value will be replicated on all devices 
        - :py:class:`PartitionSpec`, a tuple of length at most equal to the rank 
          of the partitioned value. Each element can be a :py:obj:`None`, a mesh 
          axis or a tuple of mesh axes, and specifies the set of resources assigned 
          to partition the value's dimension matching its position in the spec. 
 
      The size of every dimension has to be a multiple of the total number of 
      resources assigned to it. 
    out_shardings: Like ``in_shardings``, but specifies resource 
      assignment for function outputs. 
      The ``out_shardings`` argument is optional. If not specified, :py:func:`jax.jit` 
      will use GSPMD's sharding propagation to determine how to shard the outputs. 
    in_axis_resources: (Deprecated) Please use in_shardings. 
    out_axis_resources: (Deprecated) Please use out_shardings. 
    static_argnums: An optional int or collection of ints that specify which 
      positional arguments to treat as static (compile-time constant). 
      Operations that only depend on static arguments will be constant-folded in 
      Python (during tracing), and so the corresponding argument values can be 
      any Python object. 
 
      Static arguments should be hashable, meaning both ``__hash__`` and 
      ``__eq__`` are implemented, and immutable. Calling the jitted function 
      with different values for these constants will trigger recompilation. 
      Arguments that are not arrays or containers thereof must be marked as 
      static. 
 
      If ``static_argnums`` is not provided, no arguments are treated as static. 
    static_argnames: An optional string or collection of strings specifying 
      which named arguments to treat as static (compile-time constant). See the 
      comment on ``static_argnums`` for details. If not 
      provided but ``static_argnums`` is set, the default is based on calling 
      ``inspect.signature(fun)`` to find corresponding named arguments. 
    donate_argnums: Specify which argument buffers are &quot;donated&quot; to the computation. 
      It is safe to donate argument buffers if you no longer need them once the 
      computation has finished. In some cases XLA can make use of donated 
      buffers to reduce the amount of memory needed to perform a computation, 
      for example recycling one of your input buffers to store a result. You 
      should not reuse buffers that you donate to a computation, JAX will raise 
      an error if you try to. 
      For more details on buffer donation see the `FAQ &lt;https://jax.readthedocs.io/en/latest/faq.html#buffer-donation&gt;`_. 
    keep_unused: If `False` (the default), arguments that JAX determines to be 
      unused by `fun` *may* be dropped from resulting compiled XLA executables. 
      Such arguments will not be transferred to the device nor provided to the 
      underlying executable. If `True`, unused arguments will not be pruned. 
    device: This argument is deprecated. Please put your arguments on the 
      device you want before passing them to jit. 
      Optional, the Device the jitted function will run on. (Available devices 
      can be retrieved via :py:func:`jax.devices`.) The default is inherited 
      from XLA's DeviceAssignment logic and is usually to use 
      ``jax.devices()[0]``. 
    backend: This argument is deprecated. Please put your arguments on the 
      backend you want before passing them to jit. 
      Optional, a string representing the XLA backend: ``'cpu'``, ``'gpu'``, or 
      ``'tpu'``. 
 
  Returns: 
    A wrapped version of ``fun``, set up for just-in-time compilation and 
    automatically partitioned by the mesh available at each call site. 
 
  For example, a convolution operator can be automatically partitioned over 
  an arbitrary set of devices by a single :func:`~pjit` application: 
 
  &gt;&gt;&gt; import jax 
  &gt;&gt;&gt; import jax.numpy as jnp 
  &gt;&gt;&gt; import numpy as np 
  &gt;&gt;&gt; from jax.sharding import Mesh, PartitionSpec 
  &gt;&gt;&gt; from jax.experimental.pjit import pjit 
  &gt;&gt;&gt; 
  &gt;&gt;&gt; x = jnp.arange(8, dtype=jnp.float32) 
  &gt;&gt;&gt; f = pjit(lambda x: jax.numpy.convolve(x, jnp.asarray([0.5, 1.0, 0.5]), 'same'), 
  ...         in_shardings=None, out_shardings=PartitionSpec('devices')) 
  &gt;&gt;&gt; with Mesh(np.array(jax.devices()), ('devices',)): 
  ...   print(f(x))  # doctest: +SKIP 
  [ 0.5  2.   4.   6.   8.  10.  12.  10. ] 
  &quot;&quot;&quot;</span>
  <span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings = _resolve_axis_resources_and_shardings_arg(</span>
      <span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">in_axis_resources</span><span class="s2">, </span><span class="s1">out_axis_resources)</span>

  <span class="s1">(in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">donate_argnums</span><span class="s2">, </span><span class="s1">static_argnums</span><span class="s2">,</span>
   <span class="s1">static_argnames) = pre_infer_params(</span>
       <span class="s1">fun</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">donate_argnums</span><span class="s2">,</span>
       <span class="s1">static_argnums</span><span class="s2">, </span><span class="s1">static_argnames</span><span class="s2">, </span><span class="s1">device</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">, </span><span class="s1">abstracted_axes)</span>

  <span class="s2">def </span><span class="s1">infer_params(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0"># Putting this outside of wrapped would make resources lexically scoped</span>
    <span class="s1">resource_env = mesh_lib.thread_resources.env</span>
    <span class="s1">pjit_info_args = PjitInfo(</span>
          <span class="s1">fun=fun</span><span class="s2">, </span><span class="s1">in_shardings=in_shardings</span><span class="s2">,</span>
          <span class="s1">out_shardings=out_shardings</span><span class="s2">, </span><span class="s1">static_argnums=static_argnums</span><span class="s2">,</span>
          <span class="s1">static_argnames=static_argnames</span><span class="s2">, </span><span class="s1">donate_argnums=donate_argnums</span><span class="s2">,</span>
          <span class="s1">device=device</span><span class="s2">, </span><span class="s1">backend=backend</span><span class="s2">, </span><span class="s1">keep_unused=keep_unused</span><span class="s2">,</span>
          <span class="s1">inline=inline</span><span class="s2">, </span><span class="s1">resource_env=resource_env</span><span class="s2">,</span>
          <span class="s1">abstracted_axes=abstracted_axes)</span>
    <span class="s2">return </span><span class="s1">common_infer_params(pjit_info_args</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

  <span class="s1">has_explicit_sharding = _pjit_explicit_sharding(</span>
      <span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">device</span><span class="s2">, </span><span class="s1">backend)</span>
  <span class="s2">return </span><span class="s1">post_infer_params(fun</span><span class="s2">, </span><span class="s1">infer_params</span><span class="s2">, </span><span class="s1">static_argnums</span><span class="s2">, </span><span class="s1">static_argnames</span><span class="s2">,</span>
                           <span class="s1">donate_argnums</span><span class="s2">, </span><span class="s1">abstracted_axes</span><span class="s2">,</span>
                           <span class="s1">has_explicit_sharding)</span>


<span class="s2">def </span><span class="s1">hashable_pytree(pytree):</span>
  <span class="s1">vals</span><span class="s2">, </span><span class="s1">treedef = tree_flatten(pytree)</span>
  <span class="s1">vals = tuple(vals)</span>
  <span class="s2">return </span><span class="s1">HashableFunction(</span><span class="s2">lambda</span><span class="s1">: tree_unflatten(treedef</span><span class="s2">, </span><span class="s1">vals)</span><span class="s2">,</span>
                          <span class="s1">closure=(treedef</span><span class="s2">, </span><span class="s1">vals))</span>


<span class="s1">@lru_cache(maxsize=</span><span class="s4">4096</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">_create_mesh_pspec_sharding_from_parsed_pspec(mesh</span><span class="s2">, </span><span class="s1">x):</span>
  <span class="s2">if </span><span class="s1">is_unspecified_or_auto(x):</span>
    <span class="s2">return </span><span class="s1">x</span>
  <span class="s2">return </span><span class="s1">pxla.create_mesh_pspec_sharding(mesh</span><span class="s2">, </span><span class="s1">x.user_spec</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s2">def </span><span class="s1">_create_sharding_for_array(mesh</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">api_name):</span>
  <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">XLACompatibleSharding) </span><span class="s2">or </span><span class="s1">is_unspecified_or_auto(x):</span>
    <span class="s2">return </span><span class="s1">x</span>
  <span class="s2">if </span><span class="s1">mesh </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">msg = (</span><span class="s3">'jax.jit only supports `XLACompatibleSharding`s being passed to'</span>
           <span class="s3">f' </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">. Looks like you are passing either `PartitionSpec` or `None`'</span>
           <span class="s3">f' which is not allowed in jax.jit.</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">name == </span><span class="s3">'in_shardings'</span><span class="s1">:</span>
      <span class="s1">msg += (</span><span class="s3">f'Note that </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">argument is optional. JAX will infer the shardings'</span>
              <span class="s3">&quot; from the input jax.Array's and will default to replicating the&quot;</span>
              <span class="s3">' input if the sharding cannot be inferred.'</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">name == </span><span class="s3">'out_shardings'</span><span class="s1">:</span>
      <span class="s1">msg += (</span><span class="s3">f'Note that </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">is optional. If not specified, jax.jit will'</span>
              <span class="s3">&quot; use GSPMD's sharding propagation to figure out what the sharding&quot;</span>
              <span class="s3">' of the output(s) should be.'</span><span class="s1">)</span>
    <span class="s2">raise </span><span class="s1">RuntimeError(msg)</span>
  <span class="s2">if </span><span class="s1">mesh.empty:</span>
    <span class="s2">raise </span><span class="s1">RuntimeError(</span>
        <span class="s3">f'</span><span class="s2">{</span><span class="s1">api_name</span><span class="s2">} </span><span class="s3">requires a non-empty mesh if you are passing'</span>
        <span class="s3">f' `PartitionSpec`s or `None` to </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">! Is a mesh defined at the call'</span>
        <span class="s3">f' site? Alternatively, provide `XLACompatibleSharding`s to </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">and'</span>
        <span class="s3">' then the mesh context manager is not required.'</span><span class="s1">)</span>
  <span class="s0"># A nice user error is raised in prepare_axis_resources.</span>
  <span class="s2">assert </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">ParsedPartitionSpec)</span><span class="s2">, </span><span class="s1">x</span>
  <span class="s2">return </span><span class="s1">_create_mesh_pspec_sharding_from_parsed_pspec(mesh</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s2">def </span><span class="s1">_create_sharding_with_device_backend(device</span><span class="s2">, </span><span class="s1">backend):</span>
  <span class="s2">if </span><span class="s1">device </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s2">assert </span><span class="s1">backend </span><span class="s2">is None</span>
    <span class="s1">out = SingleDeviceSharding(device)</span>
  <span class="s2">elif </span><span class="s1">backend </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s2">assert </span><span class="s1">device </span><span class="s2">is None</span>
    <span class="s1">out = SingleDeviceSharding(</span>
        <span class="s1">xb.get_backend(backend).get_default_device_assignment(</span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">])</span>
  <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">flatten_axis_resources(what</span><span class="s2">, </span><span class="s1">tree</span><span class="s2">, </span><span class="s1">shardings</span><span class="s2">, </span><span class="s1">tupled_args):</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">tuple(flatten_axes(what</span><span class="s2">, </span><span class="s1">tree</span><span class="s2">, </span><span class="s1">shardings</span><span class="s2">, </span><span class="s1">tupled_args=tupled_args))</span>
  <span class="s2">except </span><span class="s1">ValueError:</span>
    <span class="s2">pass  </span><span class="s0"># Raise a tree prefix error below</span>

  <span class="s0"># Tree leaves are always valid prefixes, so if there was a prefix error as</span>
  <span class="s0"># assumed here, axis_resources must not be a leaf.</span>
  <span class="s2">assert not </span><span class="s1">treedef_is_leaf(tree_structure(shardings))</span>

  <span class="s0"># Check the type directly rather than using isinstance because of namedtuples.</span>
  <span class="s2">if </span><span class="s1">tupled_args </span><span class="s2">and </span><span class="s1">(type(shardings) </span><span class="s2">is not </span><span class="s1">tuple </span><span class="s2">or</span>
                      <span class="s1">len(shardings) != len(tree.children())):</span>
    <span class="s0"># We know axis_resources is meant to be a tuple corresponding to the args</span>
    <span class="s0"># tuple, but while it is a non-leaf pytree, either it wasn't a tuple or it</span>
    <span class="s0"># wasn't the right length.</span>
    <span class="s1">msg = (</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">what</span><span class="s2">} </span><span class="s3">specification must be a tree prefix of the positional &quot;</span>
           <span class="s3">f&quot;arguments tuple passed to the `pjit`-decorated function. In &quot;</span>
           <span class="s3">f&quot;particular, </span><span class="s2">{</span><span class="s1">what</span><span class="s2">} </span><span class="s3">must either be a None, a PartitionSpec, or &quot;</span>
           <span class="s3">f&quot;a tuple of length equal to the number of positional arguments.&quot;</span><span class="s1">)</span>
    <span class="s0"># If `tree` represents an args tuple, then `axis_resources` must be a tuple.</span>
    <span class="s0"># TODO(mattjj,apaszke): disable implicit list casts, remove 'or list' below</span>
    <span class="s2">if </span><span class="s1">type(shardings) </span><span class="s2">is not </span><span class="s1">tuple:</span>
      <span class="s1">msg += </span><span class="s3">f&quot; But </span><span class="s2">{</span><span class="s1">what</span><span class="s2">} </span><span class="s3">is not a tuple: got </span><span class="s2">{</span><span class="s1">type(shardings)</span><span class="s2">} </span><span class="s3">instead.&quot;</span>
    <span class="s2">elif </span><span class="s1">len(shardings) != len(tree.children()):</span>
      <span class="s1">msg += (</span><span class="s3">f&quot; But </span><span class="s2">{</span><span class="s1">what</span><span class="s2">} </span><span class="s3">is the wrong length: got a tuple or list of length &quot;</span>
              <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">len(shardings)</span><span class="s2">} </span><span class="s3">for an args tuple of length &quot;</span>
              <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">len(tree.children())</span><span class="s2">}</span><span class="s3">.&quot;</span><span class="s1">)</span>

    <span class="s0"># As an extra hint, let's check if the user just forgot to wrap</span>
    <span class="s0"># shardings in a singleton tuple.</span>
    <span class="s2">if </span><span class="s1">len(tree.children()) == </span><span class="s4">1</span><span class="s1">:</span>
      <span class="s2">try</span><span class="s1">: flatten_axes(what</span><span class="s2">, </span><span class="s1">tree</span><span class="s2">, </span><span class="s1">(shardings</span><span class="s2">,</span><span class="s1">))</span>
      <span class="s2">except </span><span class="s1">ValueError: </span><span class="s2">pass  </span><span class="s0"># That's not the issue.</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">msg += (</span><span class="s3">f&quot; Given the corresponding argument being &quot;</span>
                <span class="s3">f&quot;passed, it looks like </span><span class="s2">{</span><span class="s1">what</span><span class="s2">} </span><span class="s3">might need to be wrapped in &quot;</span>
                <span class="s3">f&quot;a singleton tuple.&quot;</span><span class="s1">)</span>

    <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

  <span class="s1">axis_tree = shardings</span>

  <span class="s0"># Because we only have the `tree` treedef and not the full pytree here,</span>
  <span class="s0"># we construct a dummy tree to compare against. Revise this in callers?</span>
  <span class="s1">dummy_tree = tree_unflatten(tree</span><span class="s2">, </span><span class="s1">[PytreeLeaf()] * tree.num_leaves)</span>
  <span class="s1">errors = prefix_errors(axis_tree</span><span class="s2">, </span><span class="s1">dummy_tree)</span>
  <span class="s2">if </span><span class="s1">errors:</span>
    <span class="s1">e = errors[</span><span class="s4">0</span><span class="s1">]  </span><span class="s0"># Only show information about the first disagreement found.</span>
    <span class="s2">raise </span><span class="s1">e(what)</span>

  <span class="s0"># At this point we've failed to find a tree prefix error.</span>
  <span class="s2">assert False, </span><span class="s3">&quot;Please open a bug report!&quot;  </span><span class="s0"># This should be unreachable.</span>

<span class="s2">class </span><span class="s1">PytreeLeaf:</span>
  <span class="s2">def </span><span class="s1">__repr__(self): </span><span class="s2">return </span><span class="s3">&quot;pytree leaf&quot;</span>


<span class="s1">@lru_cache(maxsize=</span><span class="s4">4096</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">_process_in_axis_resources(in_shardings_thunk</span><span class="s2">, </span><span class="s1">in_avals</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">,</span>
                               <span class="s1">resource_env</span><span class="s2">, </span><span class="s1">debug_info</span><span class="s2">, </span><span class="s1">device_or_backend_set):</span>
  <span class="s1">orig_in_shardings = in_shardings_thunk()</span>
  <span class="s0"># Only do this if original in_shardings are unspecified. If it is AUTO, go</span>
  <span class="s0"># via flatten_axis_resources.</span>
  <span class="s2">if </span><span class="s1">is_unspecified(orig_in_shardings):</span>
    <span class="s1">in_shardings_flat = (orig_in_shardings</span><span class="s2">,</span><span class="s1">) * len(in_avals)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">in_shardings_flat = flatten_axis_resources(</span>
          <span class="s3">&quot;pjit in_shardings&quot;</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">orig_in_shardings</span><span class="s2">,</span>
          <span class="s1">tupled_args=</span><span class="s2">True</span><span class="s1">)</span>

  <span class="s2">if not </span><span class="s1">config.jax_dynamic_shapes:</span>
    <span class="s1">pjit_check_aval_sharding(in_shardings_flat</span><span class="s2">, </span><span class="s1">in_avals</span><span class="s2">,</span>
                             <span class="s2">None if </span><span class="s1">debug_info </span><span class="s2">is None else </span><span class="s1">debug_info.arg_names</span><span class="s2">,</span>
                             <span class="s3">&quot;pjit arguments&quot;</span><span class="s2">, </span><span class="s1">allow_uneven_sharding=</span><span class="s2">False</span><span class="s1">)</span>
  <span class="s1">canonicalized_shardings = tuple(</span>
      <span class="s1">i </span><span class="s2">if </span><span class="s1">is_unspecified_or_auto(i) </span><span class="s2">else</span>
      <span class="s1">to_gspmd_sharding(i</span><span class="s2">, </span><span class="s1">aval.ndim</span><span class="s2">, </span><span class="s1">device_or_backend_set)</span>
      <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">aval </span><span class="s2">in </span><span class="s1">zip(in_shardings_flat</span><span class="s2">, </span><span class="s1">in_avals))</span>
  <span class="s2">return </span><span class="s1">canonicalized_shardings</span>


<span class="s1">@lu.cache</span>
<span class="s2">def </span><span class="s1">_create_pjit_jaxpr(fun</span><span class="s2">, </span><span class="s1">in_type</span><span class="s2">, </span><span class="s1">debug_info</span><span class="s2">, </span><span class="s1">out_paths):</span>
  <span class="s2">with </span><span class="s1">dispatch.log_elapsed_time(</span>
      <span class="s3">&quot;Finished tracing + transforming {fun_name} for pjit in {elapsed_time} sec&quot;</span><span class="s2">,</span>
      <span class="s1">fun_name=fun.__name__</span><span class="s2">, </span><span class="s1">event=dispatch.JAXPR_TRACE_EVENT):</span>
    <span class="s1">pe_debug = debug_info </span><span class="s2">and </span><span class="s1">pe.debug_info_final(fun</span><span class="s2">, </span><span class="s1">debug_info.traced_for)</span>
    <span class="s2">if </span><span class="s1">config.jax_dynamic_shapes:</span>
      <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">global_out_avals</span><span class="s2">, </span><span class="s1">consts = pe.trace_to_jaxpr_dynamic2(</span>
          <span class="s1">lu.annotate(fun</span><span class="s2">, </span><span class="s1">in_type)</span><span class="s2">, </span><span class="s1">debug_info=pe_debug)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">global_out_avals</span><span class="s2">, </span><span class="s1">consts = pe.trace_to_jaxpr_dynamic(</span>
          <span class="s1">fun</span><span class="s2">, </span><span class="s1">in_type</span><span class="s2">, </span><span class="s1">debug_info=pe_debug)</span>

  <span class="s2">if not </span><span class="s1">config.jax_dynamic_shapes:</span>
    <span class="s1">jaxpr = jaxpr_debug_info(jaxpr</span><span class="s2">, </span><span class="s1">debug_info</span><span class="s2">, </span><span class="s1">out_paths())</span>

  <span class="s2">if </span><span class="s1">any(isinstance(c</span><span class="s2">, </span><span class="s1">core.Tracer) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">consts):</span>
    <span class="s1">closed_jaxpr = pe.close_jaxpr(pe.convert_constvars_jaxpr(jaxpr))</span>
    <span class="s1">final_consts = consts</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">closed_jaxpr = core.ClosedJaxpr(jaxpr</span><span class="s2">, </span><span class="s1">consts)</span>
    <span class="s1">final_consts = []</span>
  <span class="s2">return </span><span class="s1">closed_jaxpr</span><span class="s2">, </span><span class="s1">final_consts</span><span class="s2">, </span><span class="s1">global_out_avals</span>


<span class="s1">@lru_cache(maxsize=</span><span class="s4">4096</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">_check_and_canonicalize_out_shardings(</span>
    <span class="s1">out_shardings_thunk</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">, </span><span class="s1">out_type</span><span class="s2">, </span><span class="s1">debug_info</span><span class="s2">, </span><span class="s1">device_or_backend_set):</span>
  <span class="s1">orig_out_shardings = out_shardings_thunk()</span>
  <span class="s0"># TODO(yashkatariya): Remove the if branch and fix flatten_axis_resources</span>
  <span class="s0"># instead. This condition exists because flatten_axis_resources passes in an</span>
  <span class="s0"># `object()` while unflattening which breaks assertion is user defined</span>
  <span class="s0"># pytrees (which shouldn't exist but they do).</span>
  <span class="s2">if </span><span class="s1">(is_unspecified(orig_out_shardings) </span><span class="s2">or</span>
      <span class="s1">isinstance(orig_out_shardings</span><span class="s2">, </span><span class="s1">XLACompatibleSharding)):</span>
    <span class="s1">out_shardings_flat = (orig_out_shardings</span><span class="s2">,</span><span class="s1">) * len(out_type)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">out_shardings_flat = flatten_axis_resources(</span>
        <span class="s3">&quot;pjit out_shardings&quot;</span><span class="s2">, </span><span class="s1">out_tree()</span><span class="s2">, </span><span class="s1">orig_out_shardings</span><span class="s2">,</span>
        <span class="s1">tupled_args=</span><span class="s2">False</span><span class="s1">)</span>

  <span class="s2">if not </span><span class="s1">config.jax_dynamic_shapes:</span>
    <span class="s1">pjit_check_aval_sharding(</span>
        <span class="s1">out_shardings_flat</span><span class="s2">, </span><span class="s1">out_type</span><span class="s2">,</span>
        <span class="s2">None if </span><span class="s1">debug_info </span><span class="s2">is None else </span><span class="s1">debug_info.result_paths</span><span class="s2">,</span>
        <span class="s3">&quot;pjit outputs&quot;</span><span class="s2">, </span><span class="s1">allow_uneven_sharding=</span><span class="s2">False</span><span class="s1">)</span>

  <span class="s1">canonicalized_out_shardings_flat = tuple(</span>
      <span class="s1">o </span><span class="s2">if </span><span class="s1">is_unspecified(o) </span><span class="s2">or </span><span class="s1">is_auto(o) </span><span class="s2">else</span>
      <span class="s1">to_gspmd_sharding(o</span><span class="s2">, </span><span class="s1">aval.ndim</span><span class="s2">, </span><span class="s1">device_or_backend_set)</span>
      <span class="s2">for </span><span class="s1">o</span><span class="s2">, </span><span class="s1">aval </span><span class="s2">in </span><span class="s1">zip(out_shardings_flat</span><span class="s2">, </span><span class="s1">out_type)</span>
  <span class="s1">)</span>
  <span class="s2">return </span><span class="s1">canonicalized_out_shardings_flat</span>


<span class="s2">def </span><span class="s1">_pjit_jaxpr(fun</span><span class="s2">, </span><span class="s1">out_shardings_thunk</span><span class="s2">, </span><span class="s1">in_type</span><span class="s2">, </span><span class="s1">debug_info</span><span class="s2">,</span>
                <span class="s1">device_or_backend_set</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">, </span><span class="s1">result_paths):</span>
  <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">final_consts</span><span class="s2">, </span><span class="s1">out_type = _create_pjit_jaxpr(</span>
      <span class="s1">fun</span><span class="s2">, </span><span class="s1">in_type</span><span class="s2">, </span><span class="s1">debug_info</span><span class="s2">, </span><span class="s1">result_paths)</span>
  <span class="s1">canonicalized_out_shardings_flat = _check_and_canonicalize_out_shardings(</span>
      <span class="s1">out_shardings_thunk</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">, </span><span class="s1">tuple(out_type)</span><span class="s2">, </span><span class="s1">jaxpr.jaxpr.debug_info</span><span class="s2">,</span>
      <span class="s1">device_or_backend_set)</span>
  <span class="s0"># lu.cache needs to be able to create weakrefs to outputs, so we can't return a plain tuple</span>
  <span class="s2">return </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">final_consts</span><span class="s2">, </span><span class="s1">canonicalized_out_shardings_flat</span>


<span class="s2">def </span><span class="s1">pjit_check_aval_sharding(</span>
    <span class="s1">shardings</span><span class="s2">, </span><span class="s1">flat_avals</span><span class="s2">, </span><span class="s1">names: Optional[Tuple[str</span><span class="s2">, </span><span class="s1">...]]</span><span class="s2">,</span>
    <span class="s1">what_aval: str</span><span class="s2">, </span><span class="s1">allow_uneven_sharding: bool):</span>
  <span class="s1">new_names = [</span><span class="s3">''</span><span class="s1">] * len(shardings) </span><span class="s2">if </span><span class="s1">names </span><span class="s2">is None else </span><span class="s1">names</span>
  <span class="s2">for </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">zip(flat_avals</span><span class="s2">, </span><span class="s1">shardings</span><span class="s2">, </span><span class="s1">new_names):</span>
    <span class="s2">if </span><span class="s1">is_unspecified_or_auto(s):</span>
      <span class="s2">continue</span>
    <span class="s1">name_str = </span><span class="s3">f' with pytree key path </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">' </span><span class="s2">if </span><span class="s1">name </span><span class="s2">else </span><span class="s3">''</span>
    <span class="s1">shape = aval.shape</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s0"># Sharding interfaces can implement `is_compatible_aval` as an optional</span>
      <span class="s0"># method to raise a more meaningful error.</span>
      <span class="s2">if </span><span class="s1">hasattr(s</span><span class="s2">, </span><span class="s3">'is_compatible_aval'</span><span class="s1">):</span>
        <span class="s1">s.is_compatible_aval(shape)</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">s._to_xla_hlo_sharding(len(shape))</span>
    <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span>
          <span class="s3">f'One of </span><span class="s2">{</span><span class="s1">what_aval</span><span class="s2">}{</span><span class="s1">name_str</span><span class="s2">} </span><span class="s3">is incompatible with its sharding '</span>
          <span class="s3">f'annotation </span><span class="s2">{</span><span class="s1">s</span><span class="s2">}</span><span class="s3">: </span><span class="s2">{</span><span class="s1">str(e)</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>
    <span class="s0"># Use the `OpSharding` proto to find out how many ways each dimension of</span>
    <span class="s0"># the aval is sharded. This approach will work across all</span>
    <span class="s0"># XLACompatibleSharding.</span>
    <span class="s1">hlo_sharding = s._to_xla_hlo_sharding(len(shape))</span>
    <span class="s2">assert </span><span class="s1">hlo_sharding </span><span class="s2">is not None</span>
    <span class="s1">num_ways_dim_sharded</span><span class="s2">, </span><span class="s1">_ = op_shardings.get_num_ways_dim_sharded(hlo_sharding)</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">size </span><span class="s2">in </span><span class="s1">enumerate(num_ways_dim_sharded):</span>
      <span class="s2">if not </span><span class="s1">allow_uneven_sharding </span><span class="s2">and </span><span class="s1">shape[i] % size != </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;One of </span><span class="s2">{</span><span class="s1">what_aval</span><span class="s2">}{</span><span class="s1">name_str</span><span class="s2">} </span><span class="s3">was given the sharding &quot;</span>
                         <span class="s3">f&quot;of </span><span class="s2">{</span><span class="s1">s</span><span class="s2">}</span><span class="s3">, which implies that &quot;</span>
                         <span class="s3">f&quot;the global size of its dimension </span><span class="s2">{</span><span class="s1">i</span><span class="s2">} </span><span class="s3">should be &quot;</span>
                         <span class="s3">f&quot;divisible by </span><span class="s2">{</span><span class="s1">size</span><span class="s2">}</span><span class="s3">, but it is equal to </span><span class="s2">{</span><span class="s1">shape[i]</span><span class="s2">} </span><span class="s3">&quot;</span>
                         <span class="s3">f&quot;(full shape: </span><span class="s2">{</span><span class="s1">shape</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">)</span>


<span class="s0"># -------------------- pjit rules --------------------</span>

<span class="s1">pjit_p = core.AxisPrimitive(</span><span class="s3">&quot;pjit&quot;</span><span class="s1">)</span>
<span class="s1">pjit_p.multiple_results = </span><span class="s2">True</span>


<span class="s2">def </span><span class="s1">_resolve_in_shardings(</span>
    <span class="s1">args</span><span class="s2">, </span><span class="s1">pjit_in_shardings: Sequence[PjitSharding]</span><span class="s2">,</span>
    <span class="s1">out_shardings: Sequence[PjitSharding]</span><span class="s2">,</span>
    <span class="s1">pjit_mesh: Optional[pxla.Mesh]) -&gt; Sequence[PjitSharding]:</span>
  <span class="s0"># If True, means that device or backend is set by the user on pjit and it</span>
  <span class="s0"># has the same semantics as device_put i.e. doesn't matter which device the</span>
  <span class="s0"># arg is on, reshard it to the device mentioned. So don't do any of the</span>
  <span class="s0"># checks and just return the pjit_in_shardings directly. `shard_args` will</span>
  <span class="s0"># handle the resharding.</span>
  <span class="s2">if </span><span class="s1">pxla.check_device_backend_on_shardings(pjit_in_shardings):</span>
    <span class="s2">return </span><span class="s1">pjit_in_shardings</span>

  <span class="s1">committed_arg_shardings = []</span>
  <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args:</span>
    <span class="s2">if </span><span class="s1">hasattr(a</span><span class="s2">, </span><span class="s3">'sharding'</span><span class="s1">):</span>
      <span class="s1">arg_s = a.sharding</span>
      <span class="s2">if not </span><span class="s1">isinstance(arg_s</span><span class="s2">, </span><span class="s1">XLACompatibleSharding):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'One of the argument to pjit got sharding </span><span class="s2">{</span><span class="s1">arg_s</span><span class="s2">} </span><span class="s3">'</span>
                         <span class="s3">'which is not a subclass of XLACompatibleSharding.'</span><span class="s1">)</span>
      <span class="s0"># Don't consider PmapSharding inputs as committed. They will get resharded</span>
      <span class="s0"># unconditionally.</span>
      <span class="s2">if </span><span class="s1">isinstance(arg_s</span><span class="s2">, </span><span class="s1">PmapSharding):</span>
        <span class="s2">continue</span>
      <span class="s2">if </span><span class="s1">getattr(a</span><span class="s2">, </span><span class="s3">'_committed'</span><span class="s2">, True</span><span class="s1">):</span>
        <span class="s1">committed_arg_shardings.append((arg_s</span><span class="s2">, </span><span class="s1">pxla.MismatchType.ARG_SHARDING</span><span class="s2">, None</span><span class="s1">))</span>

  <span class="s0"># Check if the device_assignment across inputs, outputs and arguments is the</span>
  <span class="s0"># same.</span>
  <span class="s1">pxla._get_and_check_device_assignment(</span>
      <span class="s1">it.chain(</span>
          <span class="s1">committed_arg_shardings</span><span class="s2">,</span>
          <span class="s1">[(i</span><span class="s2">, </span><span class="s1">pxla.MismatchType.IN_SHARDING</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">pjit_in_shardings]</span><span class="s2">,</span>
          <span class="s1">[(o</span><span class="s2">, </span><span class="s1">pxla.MismatchType.OUT_SHARDING</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">out_shardings])</span><span class="s2">,</span>
      <span class="s1">(</span><span class="s2">None if </span><span class="s1">pjit_mesh </span><span class="s2">is None or </span><span class="s1">pjit_mesh.empty </span><span class="s2">else </span><span class="s1">list(pjit_mesh.devices.flat)))</span>

  <span class="s1">resolved_in_shardings = []</span>
  <span class="s2">for </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">pjit_in_s </span><span class="s2">in </span><span class="s1">zip(args</span><span class="s2">, </span><span class="s1">pjit_in_shardings):</span>
    <span class="s1">arg_s</span><span class="s2">, </span><span class="s1">committed = ((arg.sharding</span><span class="s2">, </span><span class="s1">getattr(arg</span><span class="s2">, </span><span class="s3">'_committed'</span><span class="s2">, True</span><span class="s1">))</span>
                        <span class="s2">if </span><span class="s1">hasattr(arg</span><span class="s2">, </span><span class="s3">'sharding'</span><span class="s1">) </span><span class="s2">else </span><span class="s1">(UNSPECIFIED</span><span class="s2">, False</span><span class="s1">))</span>
    <span class="s2">if </span><span class="s1">is_unspecified(pjit_in_s):</span>
      <span class="s2">if </span><span class="s1">is_unspecified(arg_s):</span>
        <span class="s1">resolved_in_shardings.append(arg_s)</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">committed:</span>
          <span class="s0"># If the arg has a PmapSharding, then reshard it unconditionally.</span>
          <span class="s2">if </span><span class="s1">isinstance(arg_s</span><span class="s2">, </span><span class="s1">PmapSharding):</span>
            <span class="s1">resolved_in_shardings.append(UNSPECIFIED)</span>
          <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">resolved_in_shardings.append(to_gspmd_sharding(</span>
                <span class="s1">cast(XLACompatibleSharding</span><span class="s2">, </span><span class="s1">arg_s)</span><span class="s2">, </span><span class="s1">arg.ndim))</span>
        <span class="s2">else</span><span class="s1">:</span>
          <span class="s2">if </span><span class="s1">dispatch.is_single_device_sharding(arg_s):</span>
            <span class="s1">resolved_in_shardings.append(UNSPECIFIED)</span>
          <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">'Having uncommitted Array sharded on '</span>
                                      <span class="s3">'multiple devices is not supported.'</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">if </span><span class="s1">(isinstance(arg</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and</span>
          <span class="s2">not </span><span class="s1">pjit_in_s.is_fully_replicated </span><span class="s2">and  </span><span class="s0"># type: ignore</span>
          <span class="s1">xb.process_count() &gt; </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">'Passing non-trivial shardings for numpy '</span>
            <span class="s3">'inputs is not allowed. To fix this error, either specify a '</span>
            <span class="s3">'replicated sharding explicitly or use '</span>
            <span class="s3">'`jax.experimental.multihost_utils.host_local_array_to_global_array(...)` '</span>
            <span class="s3">'to convert your host local numpy inputs to a jax.Array which you '</span>
            <span class="s3">'can pass to pjit. '</span>
            <span class="s3">'If the numpy input is the same on each process, then you can use '</span>
            <span class="s3">'`jax.make_array_from_callback(...) to create a `jax.Array` which '</span>
            <span class="s3">'you can pass to pjit. '</span>
            <span class="s3">'Please see the jax.Array migration guide for more information '</span>
            <span class="s3">'https://jax.readthedocs.io/en/latest/jax_array_migration.html#handling-of-host-local-inputs-to-pjit-like-batch-etc. '</span>
            <span class="s3">f'Got arg shape: </span><span class="s2">{</span><span class="s1">arg.shape</span><span class="s2">}</span><span class="s3">, arg value: </span><span class="s2">{</span><span class="s1">arg</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>
      <span class="s2">if not </span><span class="s1">is_unspecified(arg_s):</span>
        <span class="s2">if </span><span class="s1">(committed </span><span class="s2">and</span>
            <span class="s2">not </span><span class="s1">isinstance(arg_s</span><span class="s2">, </span><span class="s1">PmapSharding) </span><span class="s2">and</span>
            <span class="s2">not </span><span class="s1">op_shardings.are_op_shardings_equal(</span>
                <span class="s1">pjit_in_s._to_xla_hlo_sharding(arg.ndim)</span><span class="s2">,  </span><span class="s0"># type: ignore</span>
                <span class="s1">arg_s._to_xla_hlo_sharding(arg.ndim))):</span>
          <span class="s1">op =  getattr(pjit_in_s</span><span class="s2">, </span><span class="s3">'_original_sharding'</span><span class="s2">, </span><span class="s1">pjit_in_s)</span>
          <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Sharding passed to pjit does not match the sharding '</span>
                           <span class="s3">'on the respective arg. '</span>
                           <span class="s3">f'Got pjit sharding: </span><span class="s2">{</span><span class="s1">op</span><span class="s2">}</span><span class="s3">,</span><span class="s2">\n</span><span class="s3">'</span>
                           <span class="s3">f'arg sharding: </span><span class="s2">{</span><span class="s1">arg_s</span><span class="s2">} </span><span class="s3">for arg shape: </span><span class="s2">{</span><span class="s1">arg.shape</span><span class="s2">}</span><span class="s3">, '</span>
                           <span class="s3">f'arg value: </span><span class="s2">{</span><span class="s1">arg</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>
      <span class="s1">resolved_in_shardings.append(pjit_in_s)</span>

  <span class="s2">return </span><span class="s1">tuple(resolved_in_shardings)</span>


<span class="s2">def </span><span class="s1">_pjit_call_impl_python(</span>
    <span class="s1">*args</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">,</span>
    <span class="s1">name</span><span class="s2">, </span><span class="s1">keep_unused</span><span class="s2">, </span><span class="s1">inline):</span>
  <span class="s2">global </span><span class="s1">_most_recent_pjit_call_executable</span>

  <span class="s1">in_shardings = _resolve_in_shardings(</span>
      <span class="s1">args</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">,</span>
      <span class="s1">resource_env.physical_mesh </span><span class="s2">if </span><span class="s1">resource_env </span><span class="s2">is not None else None</span><span class="s1">)</span>

  <span class="s1">compiled = _pjit_lower(</span>
      <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">,</span>
      <span class="s1">donated_invars</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">keep_unused</span><span class="s2">, </span><span class="s1">inline</span><span class="s2">,</span>
      <span class="s1">always_lower=</span><span class="s2">False, </span><span class="s1">lowering_platform=</span><span class="s2">None</span><span class="s1">).compile()</span>
  <span class="s1">_most_recent_pjit_call_executable.weak_key_dict[jaxpr] = compiled</span>
  <span class="s0"># This check is expensive so only do it if enable_checks is on.</span>
  <span class="s2">if </span><span class="s1">compiled._auto_spmd_lowering </span><span class="s2">and </span><span class="s1">config.jax_enable_checks:</span>
    <span class="s1">pxla.check_gda_or_array_xla_sharding_match(args</span><span class="s2">, </span><span class="s1">compiled._in_shardings</span><span class="s2">,</span>
                                               <span class="s1">jaxpr.jaxpr.debug_info)</span>
  <span class="s2">if </span><span class="s1">config.jax_distributed_debug:</span>
    <span class="s0"># Defensively only perform fingerprint logic if debug logging is enabled</span>
    <span class="s0"># NOTE(skyewm): I didn't benchmark this</span>
    <span class="s1">fingerprint = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">hasattr(compiled.runtime_executable()</span><span class="s2">, </span><span class="s3">&quot;fingerprint&quot;</span><span class="s1">):</span>
      <span class="s1">fingerprint = compiled.runtime_executable().fingerprint</span>
    <span class="s2">if </span><span class="s1">fingerprint </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s1">fingerprint = fingerprint.hex()</span>
    <span class="s1">distributed_debug_log((</span><span class="s3">&quot;Running pjit'd function&quot;</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s3">&quot;in_shardings&quot;</span><span class="s2">, </span><span class="s1">in_shardings)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s3">&quot;out_shardings&quot;</span><span class="s2">, </span><span class="s1">out_shardings)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s3">&quot;abstract args&quot;</span><span class="s2">, </span><span class="s1">map(xla.abstractify</span><span class="s2">, </span><span class="s1">args))</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s3">&quot;fingerprint&quot;</span><span class="s2">, </span><span class="s1">fingerprint))</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">compiled.unsafe_call(*args)</span><span class="s2">, </span><span class="s1">compiled</span>
  <span class="s2">except </span><span class="s1">FloatingPointError:</span>
    <span class="s2">assert </span><span class="s1">config.jax_debug_nans </span><span class="s2">or </span><span class="s1">config.jax_debug_infs  </span><span class="s0"># compiled_fun can only raise in this case</span>

    <span class="s1">_ = core.jaxpr_as_fun(jaxpr)(*args)  </span><span class="s0"># may raise, not return</span>

    <span class="s0"># If control reaches this line, we got a NaN on the output of `compiled`</span>
    <span class="s0"># but not `fun.call_wrapped` on the same arguments. Let's tell the user.</span>
    <span class="s1">msg = (</span><span class="s3">&quot;An invalid value was encountered in the output of the &quot;</span>
           <span class="s3">f&quot;`jit`-decorated function </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">. Because &quot;</span>
           <span class="s3">&quot;config.jax_debug_nans and/or config.jax_debug_infs is set, the &quot;</span>
           <span class="s3">&quot;de-optimized function (i.e., the function as if the `jit` &quot;</span>
           <span class="s3">&quot;decorator were removed) was called in an attempt to get a more &quot;</span>
           <span class="s3">&quot;precise error message. However, the de-optimized function did not &quot;</span>
           <span class="s3">&quot;produce invalid values during its execution. This behavior can &quot;</span>
           <span class="s3">&quot;result from `jit` optimizations causing the invalid value to be &quot;</span>
           <span class="s3">&quot;produced. It may also arise from having nan/inf constants as &quot;</span>
           <span class="s3">&quot;outputs, like `jax.jit(lambda ...: jax.numpy.nan)(...)`. &quot;</span>
           <span class="s3">&quot;</span><span class="s2">\n\n</span><span class="s3">&quot;</span>
           <span class="s3">&quot;It may be possible to avoid the invalid value by removing the &quot;</span>
           <span class="s3">&quot;`jit` decorator, at the cost of losing optimizations. &quot;</span>
           <span class="s3">&quot;</span><span class="s2">\n\n</span><span class="s3">&quot;</span>
           <span class="s3">&quot;If you see this error, consider opening a bug report at &quot;</span>
           <span class="s3">&quot;https://github.com/google/jax.&quot;</span><span class="s1">)</span>
    <span class="s2">raise </span><span class="s1">FloatingPointError(msg)</span>


<span class="s1">@weakref_lru_cache</span>
<span class="s2">def </span><span class="s1">_get_jaxpr_as_fun(jaxpr</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">,</span>
                      <span class="s1">donated_invars</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">keep_unused</span><span class="s2">, </span><span class="s1">inline):</span>
  <span class="s0"># The input jaxpr to `_get_jaxpr_as_fun` is under a weakref_lru_cache so</span>
  <span class="s0"># returning `core.jaxpr_as_fun(jaxpr)` directly creates a strong reference to</span>
  <span class="s0"># the jaxpr defeating the purpose of weakref_lru_cache. So return a function</span>
  <span class="s0"># that closes over a weakrefed jaxpr and gets called inside that function.</span>
  <span class="s0"># This way there won't be a strong reference to the jaxpr from the output</span>
  <span class="s0"># function.</span>
  <span class="s1">jaxpr = weakref.ref(jaxpr)</span>
  <span class="s2">return lambda </span><span class="s1">*args: core.jaxpr_as_fun(jaxpr())(*args)  </span><span class="s0"># pylint: disable=unnecessary-lambda</span>


<span class="s2">def </span><span class="s1">_pjit_call_impl(*args</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">,</span>
                    <span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">,</span>
                    <span class="s1">donated_invars</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">keep_unused</span><span class="s2">, </span><span class="s1">inline):</span>
  <span class="s2">def </span><span class="s1">call_impl_cache_miss(*args_</span><span class="s2">, </span><span class="s1">**kwargs_):</span>
    <span class="s1">out_flat</span><span class="s2">, </span><span class="s1">compiled = _pjit_call_impl_python(</span>
        <span class="s1">*args</span><span class="s2">, </span><span class="s1">jaxpr=jaxpr</span><span class="s2">, </span><span class="s1">in_shardings=in_shardings</span><span class="s2">,</span>
        <span class="s1">out_shardings=out_shardings</span><span class="s2">, </span><span class="s1">resource_env=resource_env</span><span class="s2">,</span>
        <span class="s1">donated_invars=donated_invars</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">keep_unused=keep_unused</span><span class="s2">,</span>
        <span class="s1">inline=inline)</span>
    <span class="s1">fastpath_data = _get_fastpath_data(</span>
        <span class="s1">compiled</span><span class="s2">, </span><span class="s1">tree_structure(out_flat)</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">out_flat)</span>
    <span class="s2">return </span><span class="s1">out_flat</span><span class="s2">, </span><span class="s1">fastpath_data</span>

  <span class="s1">f = _get_jaxpr_as_fun(</span>
      <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">tuple(getattr(i</span><span class="s2">, </span><span class="s3">'_original_sharding'</span><span class="s2">, </span><span class="s1">i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">in_shardings)</span><span class="s2">,</span>
      <span class="s1">tuple(getattr(o</span><span class="s2">, </span><span class="s3">'_original_sharding'</span><span class="s2">, </span><span class="s1">o) </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">out_shardings)</span><span class="s2">,</span>
      <span class="s1">resource_env</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">keep_unused</span><span class="s2">, </span><span class="s1">inline)</span>
  <span class="s1">donated_argnums = [i </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">enumerate(donated_invars) </span><span class="s2">if </span><span class="s1">d]</span>
  <span class="s1">has_explicit_sharding = _pjit_explicit_sharding(</span>
      <span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, None, None</span><span class="s1">)</span>
  <span class="s2">return </span><span class="s1">xc._xla.pjit(name</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">call_impl_cache_miss</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">donated_argnums</span><span class="s2">,</span>
                      <span class="s1">_get_cpp_global_cache(has_explicit_sharding))(*args)</span>

<span class="s1">pjit_p.def_impl(_pjit_call_impl)</span>


<span class="s1">@dataclasses.dataclass(frozen=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">SameDeviceAssignmentTuple:</span>
  <span class="s1">shardings: Tuple[PjitSharding</span><span class="s2">, </span><span class="s1">...]</span>
  <span class="s0"># device_assignment is Optional because shardings can contain `AUTO` and in</span>
  <span class="s0"># that case `mesh` is compulsory to be used. So in that case</span>
  <span class="s0"># `_pjit_lower_cached` cache, resource_env will check against the devices.</span>
  <span class="s1">device_assignment: Optional[XLADeviceAssignment]</span>

  <span class="s2">def </span><span class="s1">__hash__(self):</span>
    <span class="s1">shardings_hash = tuple(</span>
        <span class="s1">s._hlo_sharding_hash </span><span class="s2">if </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">GSPMDSharding) </span><span class="s2">else </span><span class="s1">s  </span><span class="s0"># type: ignore</span>
        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self.shardings)</span>
    <span class="s2">if </span><span class="s1">self.device_assignment </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">hash(shardings_hash)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">hash((shardings_hash</span><span class="s2">, </span><span class="s1">*self.device_assignment))</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">SameDeviceAssignmentTuple):</span>
      <span class="s2">return False</span>
    <span class="s1">eq = []</span>
    <span class="s2">for </span><span class="s1">s</span><span class="s2">, </span><span class="s1">o </span><span class="s2">in </span><span class="s1">zip(self.shardings</span><span class="s2">, </span><span class="s1">other.shardings):</span>
      <span class="s1">s = getattr(s</span><span class="s2">, </span><span class="s3">&quot;_original_sharding&quot;</span><span class="s2">, </span><span class="s1">s)</span>
      <span class="s1">o = getattr(o</span><span class="s2">, </span><span class="s3">&quot;_original_sharding&quot;</span><span class="s2">, </span><span class="s1">o)</span>
      <span class="s2">if </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">GSPMDSharding) </span><span class="s2">and </span><span class="s1">isinstance(o</span><span class="s2">, </span><span class="s1">GSPMDSharding):</span>
        <span class="s1">eq.append(op_shardings.are_op_shardings_equal(</span>
            <span class="s1">s._hlo_sharding</span><span class="s2">, </span><span class="s1">o._hlo_sharding))</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">eq.append(s == o)</span>
    <span class="s2">return </span><span class="s1">all(eq) </span><span class="s2">and </span><span class="s1">self.device_assignment == other.device_assignment</span>


<span class="s2">def </span><span class="s1">_pjit_lower(</span>
    <span class="s1">jaxpr: core.ClosedJaxpr</span><span class="s2">,</span>
    <span class="s1">in_shardings</span><span class="s2">,</span>
    <span class="s1">out_shardings</span><span class="s2">,</span>
    <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
  <span class="s1">da = _fast_path_get_device_assignment(it.chain(in_shardings</span><span class="s2">, </span><span class="s1">out_shardings))</span>
  <span class="s1">in_shardings = SameDeviceAssignmentTuple(tuple(in_shardings)</span><span class="s2">, </span><span class="s1">da)</span>
  <span class="s1">out_shardings = SameDeviceAssignmentTuple(tuple(out_shardings)</span><span class="s2">, </span><span class="s1">da)</span>
  <span class="s2">return </span><span class="s1">_pjit_lower_cached(jaxpr</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s1">@weakref_lru_cache</span>
<span class="s2">def </span><span class="s1">_pjit_lower_cached(</span>
    <span class="s1">jaxpr: core.ClosedJaxpr</span><span class="s2">,</span>
    <span class="s1">sdat_in_shardings: SameDeviceAssignmentTuple</span><span class="s2">,</span>
    <span class="s1">sdat_out_shardings: SameDeviceAssignmentTuple</span><span class="s2">,</span>
    <span class="s1">resource_env</span><span class="s2">,</span>
    <span class="s1">donated_invars</span><span class="s2">,</span>
    <span class="s1">name: str</span><span class="s2">,</span>
    <span class="s1">keep_unused: bool</span><span class="s2">,</span>
    <span class="s1">inline: bool</span><span class="s2">,</span>
    <span class="s1">always_lower: bool</span><span class="s2">,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">lowering_platform: Optional[str]):</span>
  <span class="s1">in_shardings: Tuple[PjitShardingMinusUnspecified</span><span class="s2">, </span><span class="s1">...] = cast(</span>
      <span class="s1">Tuple[PjitShardingMinusUnspecified</span><span class="s2">, </span><span class="s1">...]</span><span class="s2">, </span><span class="s1">sdat_in_shardings.shardings)</span>
  <span class="s1">out_shardings: Tuple[PjitSharding</span><span class="s2">, </span><span class="s1">...] = sdat_out_shardings.shardings</span>

  <span class="s2">if </span><span class="s1">resource_env </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s1">pxla.resource_typecheck(jaxpr</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">{}</span><span class="s2">, lambda</span><span class="s1">: </span><span class="s3">&quot;pjit&quot;</span><span class="s1">)</span>

  <span class="s2">if </span><span class="s1">resource_env </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s1">mesh = resource_env.physical_mesh</span>
    <span class="s1">api_name = </span><span class="s3">'pjit'</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s0"># resource_env is `None` in the jit wrapper around pjit.</span>
    <span class="s1">mesh = </span><span class="s2">None</span>
    <span class="s1">api_name = </span><span class="s3">'jit'</span>

  <span class="s0"># For `pjit(xmap)` cases, it needs to take the `lower_mesh_computation` path</span>
  <span class="s0"># because `xmap` only supports SPMDAxisContext right now.</span>
  <span class="s2">if </span><span class="s1">dispatch.jaxpr_has_primitive(jaxpr.jaxpr</span><span class="s2">, </span><span class="s3">'xmap'</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">pxla.lower_mesh_computation(</span>
      <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">api_name</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">mesh</span><span class="s2">,</span>
      <span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">,</span>
      <span class="s2">True, </span><span class="s1">jaxpr.in_avals</span><span class="s2">, </span><span class="s1">tiling_method=</span><span class="s2">None,</span>
      <span class="s1">lowering_platform=lowering_platform)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">pxla.lower_sharding_computation(</span>
        <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">api_name</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">,</span>
        <span class="s1">tuple(donated_invars)</span><span class="s2">, </span><span class="s1">tuple(jaxpr.in_avals)</span><span class="s2">,</span>
        <span class="s1">keep_unused=keep_unused</span><span class="s2">, </span><span class="s1">inline=inline</span><span class="s2">, </span><span class="s1">always_lower=always_lower</span><span class="s2">,</span>
        <span class="s1">devices_from_context=(</span>
            <span class="s2">None if </span><span class="s1">mesh </span><span class="s2">is None or </span><span class="s1">mesh.empty </span><span class="s2">else </span><span class="s1">list(mesh.devices.flat))</span><span class="s2">,</span>
        <span class="s1">lowering_platform=lowering_platform)</span>


<span class="s2">def </span><span class="s1">pjit_staging_rule(trace</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**params):</span>
  <span class="s2">if </span><span class="s1">(params[</span><span class="s3">&quot;inline&quot;</span><span class="s1">] </span><span class="s2">and</span>
      <span class="s1">all(is_unspecified(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">params[</span><span class="s3">&quot;in_shardings&quot;</span><span class="s1">]) </span><span class="s2">and</span>
      <span class="s1">all(is_unspecified(o) </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">params[</span><span class="s3">&quot;out_shardings&quot;</span><span class="s1">])):</span>
    <span class="s1">jaxpr = params[</span><span class="s3">'jaxpr'</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">core.eval_jaxpr(jaxpr.jaxpr</span><span class="s2">, </span><span class="s1">jaxpr.consts</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">,</span>
                           <span class="s1">propagate_source_info=</span><span class="s2">False</span><span class="s1">)</span>
  <span class="s2">elif </span><span class="s1">config.jax_dynamic_shapes:</span>
    <span class="s1">source_info = source_info_util.current()</span>
    <span class="s1">out_tracers = []</span>
    <span class="s2">for </span><span class="s1">aval </span><span class="s2">in </span><span class="s1">_out_type(params[</span><span class="s3">'jaxpr'</span><span class="s1">]):</span>
      <span class="s2">if </span><span class="s1">type(aval) </span><span class="s2">is </span><span class="s1">core.DShapedArray:</span>
        <span class="s1">shape = [args[d.val] </span><span class="s2">if </span><span class="s1">type(d) </span><span class="s2">is </span><span class="s1">core.InDBIdx </span><span class="s2">else</span>
                 <span class="s1">out_tracers[d.val] </span><span class="s2">if </span><span class="s1">type(d) </span><span class="s2">is </span><span class="s1">core.OutDBIdx </span><span class="s2">else</span>
                 <span class="s1">d </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">aval.shape]</span>
        <span class="s1">aval = aval.update(shape=tuple(core.get_referent(d) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">shape))</span>
      <span class="s1">out_tracers.append(pe.DynamicJaxprTracer(trace</span><span class="s2">, </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">source_info))</span>
    <span class="s1">eqn = core.new_jaxpr_eqn(</span>
      <span class="s1">map(trace.getvar</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">, </span><span class="s1">map(trace.makevar</span><span class="s2">, </span><span class="s1">out_tracers)</span><span class="s2">, </span><span class="s1">pjit_p</span><span class="s2">, </span><span class="s1">params</span><span class="s2">,</span>
      <span class="s1">params[</span><span class="s3">'jaxpr'</span><span class="s1">].effects</span><span class="s2">, </span><span class="s1">source_info)</span>
    <span class="s1">trace.frame.add_eqn(eqn)</span>
    <span class="s2">return </span><span class="s1">out_tracers</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">trace.default_process_primitive(pjit_p</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">params)</span>
<span class="s1">pe.custom_staging_rules[pjit_p] = pjit_staging_rule</span>

<span class="s0"># TODO(mattjj): remove/trivialize this when jaxprs have type annotation on them,</span>
<span class="s0"># since it's actually not possible in general to infer the type from the term</span>
<span class="s2">def </span><span class="s1">_out_type(jaxpr: core.ClosedJaxpr) -&gt; List[core.AbstractValue]:</span>
  <span class="s1">out = []</span>
  <span class="s1">in_idx = {v: i </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate(jaxpr.jaxpr.invars)}</span>
  <span class="s1">out_idx = {x: i </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(jaxpr.jaxpr.invars)</span>
             <span class="s2">if </span><span class="s1">type(x) </span><span class="s2">is </span><span class="s1">core.Var}</span>
  <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">jaxpr.jaxpr.outvars:</span>
    <span class="s1">aval = x.aval</span>
    <span class="s2">if </span><span class="s1">type(aval) </span><span class="s2">is </span><span class="s1">core.DShapedArray:</span>
      <span class="s1">shape = [core.InDBIdx(in_idx[d]) </span><span class="s2">if </span><span class="s1">d </span><span class="s2">in </span><span class="s1">in_idx </span><span class="s2">else</span>
               <span class="s1">core.OutDBIdx(out_idx[d]) </span><span class="s2">if </span><span class="s1">d </span><span class="s2">in </span><span class="s1">out_idx </span><span class="s2">else</span>
               <span class="s1">d </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">x.aval.shape]</span>
      <span class="s1">aval = aval.update(shape=tuple(shape))</span>
    <span class="s1">out.append(aval)</span>
  <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">_pjit_typecheck(ctx_factory</span><span class="s2">, </span><span class="s1">*in_atoms</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">**params):</span>
  <span class="s2">return </span><span class="s1">core._check_call(ctx_factory</span><span class="s2">, </span><span class="s1">pjit_p</span><span class="s2">, </span><span class="s1">in_atoms</span><span class="s2">,</span>
                          <span class="s1">dict(params</span><span class="s2">, </span><span class="s1">call_jaxpr=jaxpr.jaxpr))</span>
<span class="s1">core.custom_typechecks[pjit_p] = _pjit_typecheck</span>


<span class="s2">def </span><span class="s1">_pjit_abstract_eval(*args</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">**_):</span>
  <span class="s2">return </span><span class="s1">jaxpr.out_avals</span><span class="s2">, </span><span class="s1">jaxpr.effects</span>
<span class="s1">pjit_p.def_effectful_abstract_eval(_pjit_abstract_eval)</span>


<span class="s2">def </span><span class="s1">_pjit_lowering(ctx</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">,</span>
                   <span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">,</span>
                   <span class="s1">keep_unused</span><span class="s2">, </span><span class="s1">inline):</span>
  <span class="s1">effects = list(ctx.tokens_in.effects())</span>
  <span class="s1">output_types = map(mlir.aval_to_ir_types</span><span class="s2">, </span><span class="s1">ctx.avals_out)</span>
  <span class="s1">output_types = [mlir.token_type()] * len(effects) + output_types</span>
  <span class="s1">flat_output_types = flatten(output_types)</span>

  <span class="s1">arg_shardings = [</span><span class="s2">None if </span><span class="s1">is_unspecified(i) </span><span class="s2">else</span>
                   <span class="s1">i._to_xla_hlo_sharding(aval.ndim)</span>
                   <span class="s2">for </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">i </span><span class="s2">in </span><span class="s1">zip(ctx.avals_in</span><span class="s2">, </span><span class="s1">in_shardings)]</span>
  <span class="s1">result_shardings = [</span><span class="s2">None if </span><span class="s1">is_unspecified(o) </span><span class="s2">else</span>
                      <span class="s1">o._to_xla_hlo_sharding(aval.ndim)</span>
                      <span class="s2">for </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">o </span><span class="s2">in </span><span class="s1">zip(ctx.avals_out</span><span class="s2">, </span><span class="s1">out_shardings)]</span>

  <span class="s0"># TODO(b/228598865): inlined calls cannot have shardings set directly on the</span>
  <span class="s0"># inputs or outputs because they are lost during MLIR-&gt;HLO conversion.</span>
  <span class="s0"># using_sharding_annotation=False means we add an identity operation instead.</span>
  <span class="s1">func = mlir.lower_jaxpr_to_fun(</span>
      <span class="s1">ctx.module_context</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">effects</span><span class="s2">, </span><span class="s1">arg_shardings=arg_shardings</span><span class="s2">,</span>
      <span class="s1">result_shardings=result_shardings</span><span class="s2">, </span><span class="s1">use_sharding_annotations=</span><span class="s2">False,</span>
      <span class="s1">api_name=(</span><span class="s3">'jit' </span><span class="s2">if </span><span class="s1">resource_env </span><span class="s2">is None else </span><span class="s3">'pjit'</span><span class="s1">))</span>
  <span class="s1">tokens_in = [ctx.tokens_in.get(eff) </span><span class="s2">for </span><span class="s1">eff </span><span class="s2">in </span><span class="s1">effects]</span>
  <span class="s1">args = (*ctx.dim_var_values</span><span class="s2">, </span><span class="s1">*tokens_in</span><span class="s2">, </span><span class="s1">*args)</span>
  <span class="s1">call = func_dialect.CallOp(flat_output_types</span><span class="s2">,</span>
                             <span class="s1">ir.FlatSymbolRefAttr.get(func.name.value)</span><span class="s2">,</span>
                             <span class="s1">mlir.flatten_lowering_ir_args(args))</span>
  <span class="s1">out_nodes = unflatten(call.results</span><span class="s2">, </span><span class="s1">map(len</span><span class="s2">, </span><span class="s1">output_types))</span>
  <span class="s1">tokens</span><span class="s2">, </span><span class="s1">out_nodes = split_list(out_nodes</span><span class="s2">, </span><span class="s1">[len(effects)])</span>
  <span class="s1">tokens_out = ctx.tokens_in.update_tokens(mlir.TokenSet(zip(effects</span><span class="s2">, </span><span class="s1">tokens)))</span>
  <span class="s1">ctx.set_tokens_out(tokens_out)</span>
  <span class="s2">return </span><span class="s1">out_nodes</span>

<span class="s1">mlir.register_lowering(pjit_p</span><span class="s2">, </span><span class="s1">_pjit_lowering)</span>


<span class="s2">def </span><span class="s1">_pjit_batcher(insert_axis</span><span class="s2">, </span><span class="s1">spmd_axis_name</span><span class="s2">,</span>
                  <span class="s1">axis_size</span><span class="s2">, </span><span class="s1">axis_name</span><span class="s2">, </span><span class="s1">main_type</span><span class="s2">,</span>
                  <span class="s1">vals_in</span><span class="s2">, </span><span class="s1">dims_in</span><span class="s2">,</span>
                  <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">,</span>
                  <span class="s1">resource_env</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">keep_unused</span><span class="s2">, </span><span class="s1">inline):</span>
  <span class="s1">new_jaxpr</span><span class="s2">, </span><span class="s1">axes_out = batching.batch_jaxpr2(</span>
      <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">axis_size</span><span class="s2">, </span><span class="s1">dims_in</span><span class="s2">, </span><span class="s1">axis_name=axis_name</span><span class="s2">,</span>
      <span class="s1">spmd_axis_name=spmd_axis_name</span><span class="s2">, </span><span class="s1">main_type=main_type)</span>

  <span class="s0"># `insert_axis` is set to True only for some `xmap` uses.</span>
  <span class="s1">new_parts = (axis_name</span><span class="s2">,</span><span class="s1">) </span><span class="s2">if </span><span class="s1">insert_axis </span><span class="s2">else </span><span class="s1">(</span>
      <span class="s1">() </span><span class="s2">if </span><span class="s1">spmd_axis_name </span><span class="s2">is None else </span><span class="s1">spmd_axis_name)</span>

  <span class="s2">if </span><span class="s1">resource_env </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s1">mesh = resource_env.physical_mesh</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">mesh = </span><span class="s2">None</span>

  <span class="s1">in_shardings = tuple(</span>
      <span class="s1">_pjit_batcher_for_sharding(i</span><span class="s2">, </span><span class="s1">axis_in</span><span class="s2">, </span><span class="s1">new_parts</span><span class="s2">, </span><span class="s1">mesh</span><span class="s2">, </span><span class="s1">aval.ndim)</span>
      <span class="s2">if </span><span class="s1">axis_in </span><span class="s2">is not None else </span><span class="s1">i</span>
      <span class="s2">for </span><span class="s1">axis_in</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">aval </span><span class="s2">in </span><span class="s1">zip(dims_in</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">new_jaxpr.in_avals))</span>
  <span class="s1">out_shardings = tuple(</span>
      <span class="s1">_pjit_batcher_for_sharding(o</span><span class="s2">, </span><span class="s1">axis_out</span><span class="s2">, </span><span class="s1">new_parts</span><span class="s2">, </span><span class="s1">mesh</span><span class="s2">, </span><span class="s1">aval.ndim)</span>
      <span class="s2">if </span><span class="s1">axis_out </span><span class="s2">is not None else </span><span class="s1">o</span>
      <span class="s2">for </span><span class="s1">axis_out</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">aval </span><span class="s2">in </span><span class="s1">zip(axes_out</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">new_jaxpr.out_avals))</span>
  <span class="s1">vals_out = pjit_p.bind(</span>
    <span class="s1">*vals_in</span><span class="s2">,</span>
    <span class="s1">jaxpr=new_jaxpr</span><span class="s2">,</span>
    <span class="s1">in_shardings=in_shardings</span><span class="s2">,</span>
    <span class="s1">out_shardings=out_shardings</span><span class="s2">,</span>
    <span class="s1">resource_env=resource_env</span><span class="s2">,</span>
    <span class="s1">donated_invars=donated_invars</span><span class="s2">,</span>
    <span class="s1">name=name</span><span class="s2">,</span>
    <span class="s1">keep_unused=keep_unused</span><span class="s2">,</span>
    <span class="s1">inline=inline)</span>
  <span class="s2">return </span><span class="s1">vals_out</span><span class="s2">, </span><span class="s1">axes_out</span>

<span class="s1">batching.spmd_axis_primitive_batchers[pjit_p] = partial(_pjit_batcher</span><span class="s2">, False</span><span class="s1">)</span>
<span class="s1">batching.axis_primitive_batchers[pjit_p] = partial(_pjit_batcher</span><span class="s2">, False, None</span><span class="s1">)</span>
<span class="s1">pxla.spmd_primitive_batchers[pjit_p] = partial(_pjit_batcher</span><span class="s2">, True, None</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">_pjit_batcher_for_sharding(</span>
    <span class="s1">s: Union[GSPMDSharding</span><span class="s2">, </span><span class="s1">UnspecifiedValue]</span><span class="s2">,</span>
    <span class="s1">dim: int</span><span class="s2">, </span><span class="s1">val: Tuple[str</span><span class="s2">, </span><span class="s1">...]</span><span class="s2">, </span><span class="s1">mesh</span><span class="s2">, </span><span class="s1">ndim: int):</span>
  <span class="s2">if </span><span class="s1">is_unspecified(s):</span>
    <span class="s2">return </span><span class="s1">s</span>
  <span class="s2">if not </span><span class="s1">val:</span>
    <span class="s2">if </span><span class="s1">sharding_impls.is_op_sharding_replicated(s._hlo_sharding):  </span><span class="s0"># type: ignore</span>
      <span class="s2">return </span><span class="s1">s</span>
    <span class="s1">old_op = s._hlo_sharding.to_proto()  </span><span class="s0"># type: ignore</span>
    <span class="s1">new_op = old_op.clone()  </span><span class="s0"># type: ignore</span>
    <span class="s1">tad = list(new_op.tile_assignment_dimensions)</span>
    <span class="s1">tad.insert(dim</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">new_op.tile_assignment_dimensions = tad</span>
    <span class="s1">new_gs = GSPMDSharding(s._device_assignment</span><span class="s2">, </span><span class="s1">new_op)  </span><span class="s0"># type: ignore</span>
    <span class="s2">if </span><span class="s1">hasattr(s</span><span class="s2">, </span><span class="s3">'_original_sharding'</span><span class="s1">):</span>
      <span class="s1">vmapped_s</span><span class="s2">, </span><span class="s1">_ = pxla._get_out_sharding_from_orig_sharding(</span>
          <span class="s1">[new_gs]</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">s._original_sharding</span><span class="s2">, None, </span><span class="s1">[</span><span class="s2">False</span><span class="s1">])[</span><span class="s4">0</span><span class="s1">]  </span><span class="s0"># type: ignore</span>
      <span class="s1">new_gs = to_gspmd_sharding(vmapped_s</span><span class="s2">, </span><span class="s1">ndim)</span>
    <span class="s2">return </span><span class="s1">new_gs</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">assert </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">GSPMDSharding)</span>
    <span class="s2">if </span><span class="s1">isinstance(getattr(s</span><span class="s2">, </span><span class="s3">'_original_sharding'</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NamedSharding):</span>
      <span class="s1">mesh = s._original_sharding.mesh  </span><span class="s0"># type: ignore</span>
    <span class="s2">assert </span><span class="s1">mesh </span><span class="s2">is not None and not </span><span class="s1">mesh.empty</span>
    <span class="s1">parsed_pspec = parse_flatten_op_sharding(s._hlo_sharding</span><span class="s2">, </span><span class="s1">mesh)[</span><span class="s4">0</span><span class="s1">]  </span><span class="s0"># type: ignore</span>
    <span class="s1">parsed_pspec = parsed_pspec.insert_axis_partitions(dim</span><span class="s2">, </span><span class="s1">val)</span>
    <span class="s1">mps = NamedSharding._from_parsed_pspec(mesh</span><span class="s2">, </span><span class="s1">parsed_pspec)</span>
    <span class="s2">return </span><span class="s1">GSPMDSharding(mps._device_assignment</span><span class="s2">, </span><span class="s1">mps._to_xla_hlo_sharding(ndim))</span>


<span class="s2">def </span><span class="s1">_pjit_jvp(primals_in</span><span class="s2">, </span><span class="s1">tangents_in</span><span class="s2">,</span>
              <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">,</span>
              <span class="s1">resource_env</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">keep_unused</span><span class="s2">, </span><span class="s1">inline):</span>
  <span class="s1">is_nz_tangents_in = [type(t) </span><span class="s2">is not </span><span class="s1">ad.Zero </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">tangents_in]</span>
  <span class="s1">jaxpr_jvp</span><span class="s2">, </span><span class="s1">is_nz_tangents_out = ad.jvp_jaxpr(</span>
      <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">is_nz_tangents_in</span><span class="s2">, </span><span class="s1">instantiate=</span><span class="s2">False</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">_filter_zeros(is_nz_l</span><span class="s2">, </span><span class="s1">l):</span>
    <span class="s2">return </span><span class="s1">(x </span><span class="s2">for </span><span class="s1">nz</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">zip(is_nz_l</span><span class="s2">, </span><span class="s1">l) </span><span class="s2">if </span><span class="s1">nz)</span>
  <span class="s1">_filter_zeros_in = partial(_filter_zeros</span><span class="s2">, </span><span class="s1">is_nz_tangents_in)</span>
  <span class="s1">_filter_zeros_out = partial(_filter_zeros</span><span class="s2">, </span><span class="s1">is_nz_tangents_out)</span>
  <span class="s1">outputs = pjit_p.bind(</span>
      <span class="s1">*primals_in</span><span class="s2">, </span><span class="s1">*_filter_zeros_in(tangents_in)</span><span class="s2">,</span>
      <span class="s1">jaxpr=jaxpr_jvp</span><span class="s2">,</span>
      <span class="s1">in_shardings=(*in_shardings</span><span class="s2">, </span><span class="s1">*_filter_zeros_in(in_shardings))</span><span class="s2">,</span>
      <span class="s1">out_shardings=(*out_shardings</span><span class="s2">, </span><span class="s1">*_filter_zeros_out(out_shardings))</span><span class="s2">,</span>
      <span class="s1">resource_env=resource_env</span><span class="s2">,</span>
      <span class="s1">donated_invars=(*donated_invars</span><span class="s2">, </span><span class="s1">*_filter_zeros_in(donated_invars))</span><span class="s2">,</span>
      <span class="s1">name=name</span><span class="s2">,</span>
      <span class="s1">keep_unused=keep_unused</span><span class="s2">,</span>
      <span class="s1">inline=inline)</span>

  <span class="s1">primals_out</span><span class="s2">, </span><span class="s1">tangents_out = split_list(outputs</span><span class="s2">, </span><span class="s1">[len(jaxpr.jaxpr.outvars)])</span>
  <span class="s2">assert </span><span class="s1">len(primals_out) == len(jaxpr.jaxpr.outvars)</span>
  <span class="s1">tangents_out_it = iter(tangents_out)</span>
  <span class="s2">return </span><span class="s1">primals_out</span><span class="s2">, </span><span class="s1">[next(tangents_out_it) </span><span class="s2">if </span><span class="s1">nz </span><span class="s2">else </span><span class="s1">ad.Zero(aval)</span>
                       <span class="s2">for </span><span class="s1">nz</span><span class="s2">, </span><span class="s1">aval </span><span class="s2">in </span><span class="s1">zip(is_nz_tangents_out</span><span class="s2">, </span><span class="s1">jaxpr.out_avals)]</span>
<span class="s1">ad.primitive_jvps[pjit_p] = _pjit_jvp</span>


<span class="s1">@weakref_lru_cache</span>
<span class="s2">def </span><span class="s1">_known_jaxpr_fwd(known_jaxpr: core.ClosedJaxpr</span><span class="s2">,</span>
                     <span class="s1">fwds_known: Tuple[Optional[int]]) -&gt; core.ClosedJaxpr:</span>
  <span class="s1">updated_jaxpr = known_jaxpr.jaxpr.replace(</span>
      <span class="s1">outvars=[x </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">i </span><span class="s2">in </span><span class="s1">zip(known_jaxpr.jaxpr.outvars</span><span class="s2">, </span><span class="s1">fwds_known)</span>
               <span class="s2">if </span><span class="s1">i </span><span class="s2">is None</span><span class="s1">])</span>
  <span class="s2">return </span><span class="s1">known_jaxpr.replace(jaxpr=updated_jaxpr)</span>


<span class="s2">def </span><span class="s1">_pjit_partial_eval(trace</span><span class="s2">, </span><span class="s1">*in_tracers</span><span class="s2">,</span>
                       <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">,</span>
                       <span class="s1">resource_env</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">keep_unused</span><span class="s2">, </span><span class="s1">inline):</span>
  <span class="s1">in_pvals = [t.pval </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">in_tracers]</span>

  <span class="s1">known_ins = tuple(pv.is_known() </span><span class="s2">for </span><span class="s1">pv </span><span class="s2">in </span><span class="s1">in_pvals)</span>
  <span class="s1">unknown_ins = tuple(</span><span class="s2">not </span><span class="s1">k </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">known_ins)</span>
  <span class="s1">known_jaxpr</span><span class="s2">, </span><span class="s1">unknown_jaxpr</span><span class="s2">, </span><span class="s1">unknown_outs</span><span class="s2">, </span><span class="s1">res_avals = pe.partial_eval_jaxpr_nounits(</span>
      <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">unknown_ins</span><span class="s2">, </span><span class="s1">instantiate=</span><span class="s2">False</span><span class="s1">)</span>
  <span class="s1">unknown_outs = tuple(unknown_outs)</span>
  <span class="s1">known_outs = tuple(</span><span class="s2">not </span><span class="s1">uk </span><span class="s2">for </span><span class="s1">uk </span><span class="s2">in </span><span class="s1">unknown_outs)</span>
  <span class="s1">num_residuals = len(res_avals)</span>

  <span class="s2">def </span><span class="s1">keep_where(l</span><span class="s2">, </span><span class="s1">should_keep):</span>
    <span class="s2">return </span><span class="s1">tuple(x </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">keep </span><span class="s2">in </span><span class="s1">unsafe_zip(l</span><span class="s2">, </span><span class="s1">should_keep) </span><span class="s2">if </span><span class="s1">keep)</span>

  <span class="s1">residual_shardings = (UNSPECIFIED</span><span class="s2">,</span><span class="s1">) * num_residuals</span>
  <span class="s0"># Compute the known outputs</span>
  <span class="s1">known_params = dict(</span>
      <span class="s1">jaxpr=known_jaxpr</span><span class="s2">,</span>
      <span class="s1">in_shardings=keep_where(in_shardings</span><span class="s2">, </span><span class="s1">known_ins)</span><span class="s2">,</span>
      <span class="s1">out_shardings=(</span>
          <span class="s1">keep_where(out_shardings</span><span class="s2">, </span><span class="s1">known_outs) + residual_shardings)</span><span class="s2">,</span>
      <span class="s1">resource_env=resource_env</span><span class="s2">,</span>
      <span class="s1">donated_invars=keep_where(donated_invars</span><span class="s2">, </span><span class="s1">known_ins)</span><span class="s2">,</span>
      <span class="s1">name=name</span><span class="s2">,</span>
      <span class="s1">keep_unused=keep_unused</span><span class="s2">,</span>
      <span class="s1">inline=inline)</span>

  <span class="s1">fwds_known = pe._jaxpr_forwarding(known_params[</span><span class="s3">'jaxpr'</span><span class="s1">].jaxpr)</span>

  <span class="s0"># Only forward the outvars where the out_sharding is UNSPECIFIED.</span>
  <span class="s1">known_user_out_shardings = keep_where(known_params[</span><span class="s3">'out_shardings'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">known_outs)</span>
  <span class="s1">fwds_known_user = [</span>
      <span class="s1">fwd </span><span class="s2">if </span><span class="s1">is_unspecified(os) </span><span class="s2">else None</span>
      <span class="s2">for </span><span class="s1">os</span><span class="s2">, </span><span class="s1">fwd </span><span class="s2">in </span><span class="s1">zip(known_user_out_shardings</span><span class="s2">,</span>
                              <span class="s1">fwds_known[:len(known_user_out_shardings)])]</span>
  <span class="s1">fwds_known = fwds_known_user + fwds_known[len(known_user_out_shardings):]</span>
  <span class="s2">del </span><span class="s1">fwds_known_user</span>

  <span class="s0"># Remove forwarded outvars and out_shardings</span>
  <span class="s1">known_params[</span><span class="s3">'jaxpr'</span><span class="s1">] = _known_jaxpr_fwd(known_params[</span><span class="s3">'jaxpr'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tuple(fwds_known))</span>
  <span class="s1">known_out_shardings = tuple(</span>
      <span class="s1">s </span><span class="s2">for </span><span class="s1">s</span><span class="s2">, </span><span class="s1">i </span><span class="s2">in </span><span class="s1">zip(known_params[</span><span class="s3">'out_shardings'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fwds_known) </span><span class="s2">if </span><span class="s1">i </span><span class="s2">is None</span><span class="s1">)</span>
  <span class="s1">known_params[</span><span class="s3">'out_shardings'</span><span class="s1">] = known_out_shardings</span>
  <span class="s2">del </span><span class="s1">known_out_shardings</span>

  <span class="s2">assert </span><span class="s1">len(known_params[</span><span class="s3">'out_shardings'</span><span class="s1">]) == len(known_params[</span><span class="s3">'jaxpr'</span><span class="s1">].out_avals)</span>

  <span class="s0"># Bind known things to pjit_p.</span>
  <span class="s1">known_inputs = [pv.get_known() </span><span class="s2">for </span><span class="s1">pv </span><span class="s2">in </span><span class="s1">in_pvals </span><span class="s2">if </span><span class="s1">pv.is_known()]</span>
  <span class="s1">all_known_outs = pjit_p.bind(*known_inputs</span><span class="s2">, </span><span class="s1">**known_params)</span>

  <span class="s1">known_outs_iter = iter(all_known_outs)</span>
  <span class="s1">all_known_outs = [next(known_outs_iter)</span>
                    <span class="s2">if </span><span class="s1">fwd_idx </span><span class="s2">is None else </span><span class="s1">known_inputs[fwd_idx]</span>
                    <span class="s2">for </span><span class="s1">fwd_idx </span><span class="s2">in </span><span class="s1">fwds_known]</span>
  <span class="s2">assert </span><span class="s1">next(known_outs_iter</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is None</span>
  <span class="s2">del </span><span class="s1">known_outs_iter</span><span class="s2">, </span><span class="s1">known_inputs</span>

  <span class="s2">if </span><span class="s1">num_residuals:</span>
    <span class="s1">known_out_vals</span><span class="s2">, </span><span class="s1">residual_vals = \</span>
        <span class="s1">split_list(all_known_outs</span><span class="s2">, </span><span class="s1">[len(all_known_outs) - num_residuals])</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">known_out_vals</span><span class="s2">, </span><span class="s1">residual_vals = all_known_outs</span><span class="s2">, </span><span class="s1">()</span>
  <span class="s1">residual_tracers = [trace.new_instantiated_const(residual) </span><span class="s2">for </span><span class="s1">residual </span><span class="s2">in </span><span class="s1">residual_vals]</span>

  <span class="s0"># The convention of partial_eval_jaxpr_nounits is to place residual binders</span>
  <span class="s0"># at the front of the jaxpr produced, so we move them to the back since both</span>
  <span class="s0"># the jaxpr equation built below and the pjit transpose rule assume a</span>
  <span class="s0"># residual-inputs-last convention.</span>
  <span class="s1">unknown_jaxpr = pe.move_binders_to_back(</span>
      <span class="s1">unknown_jaxpr</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True</span><span class="s1">] * num_residuals + [</span><span class="s2">False</span><span class="s1">] * sum(unknown_ins))</span>
  <span class="s0"># Prepare unknown tracers</span>
  <span class="s1">unknown_params = dict(</span>
      <span class="s1">jaxpr=unknown_jaxpr</span><span class="s2">,</span>
      <span class="s1">in_shardings=(keep_where(in_shardings</span><span class="s2">, </span><span class="s1">unknown_ins) + residual_shardings)</span><span class="s2">,</span>
      <span class="s1">out_shardings=keep_where(out_shardings</span><span class="s2">, </span><span class="s1">unknown_outs)</span><span class="s2">,</span>
      <span class="s1">resource_env=resource_env</span><span class="s2">,</span>
      <span class="s1">donated_invars=(keep_where(donated_invars</span><span class="s2">, </span><span class="s1">unknown_ins) +</span>
                      <span class="s1">(</span><span class="s2">False,</span><span class="s1">) * num_residuals)</span><span class="s2">,</span>
      <span class="s1">name=name</span><span class="s2">,</span>
      <span class="s1">keep_unused=keep_unused</span><span class="s2">,</span>
      <span class="s1">inline=inline)</span>
  <span class="s1">unknown_tracers_in = [t </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">in_tracers </span><span class="s2">if not </span><span class="s1">t.pval.is_known()]</span>
  <span class="s1">unknown_out_avals = unknown_jaxpr.out_avals</span>
  <span class="s1">unknown_tracers_out = [</span>
      <span class="s1">pe.JaxprTracer(trace</span><span class="s2">, </span><span class="s1">pe.PartialVal.unknown(aval)</span><span class="s2">, None</span><span class="s1">)</span>
      <span class="s2">for </span><span class="s1">aval </span><span class="s2">in </span><span class="s1">unknown_out_avals</span>
  <span class="s1">]</span>
  <span class="s1">eqn = pe.new_eqn_recipe((*unknown_tracers_in</span><span class="s2">, </span><span class="s1">*residual_tracers)</span><span class="s2">,</span>
                          <span class="s1">unknown_tracers_out</span><span class="s2">,</span>
                          <span class="s1">pjit_p</span><span class="s2">,</span>
                          <span class="s1">unknown_params</span><span class="s2">,</span>
                          <span class="s1">unknown_jaxpr.effects</span><span class="s2">,</span>
                          <span class="s1">source_info_util.current())</span>
  <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">unknown_tracers_out: t.recipe = eqn</span>
  <span class="s2">return </span><span class="s1">merge_lists(unknown_outs</span><span class="s2">, </span><span class="s1">known_out_vals</span><span class="s2">, </span><span class="s1">unknown_tracers_out)</span>

<span class="s1">pe.custom_partial_eval_rules[pjit_p] = _pjit_partial_eval</span>


<span class="s2">def </span><span class="s1">_pjit_partial_eval_custom_params_updater(</span>
    <span class="s1">unks_in: Sequence[bool]</span><span class="s2">, </span><span class="s1">inst_in: Sequence[bool]</span><span class="s2">,</span>
    <span class="s1">kept_outs_known: Sequence[bool]</span><span class="s2">, </span><span class="s1">kept_outs_staged: Sequence[bool]</span><span class="s2">,</span>
    <span class="s1">num_res: int</span><span class="s2">, </span><span class="s1">params_known: dict</span><span class="s2">, </span><span class="s1">params_staged: dict</span>
  <span class="s1">) -&gt; Tuple[dict</span><span class="s2">, </span><span class="s1">dict]:</span>
  <span class="s0"># prune inputs to jaxpr_known according to unks_in</span>
  <span class="s1">donated_invars_known</span><span class="s2">, </span><span class="s1">_ = pe.partition_list(unks_in</span><span class="s2">, </span><span class="s1">params_known[</span><span class="s3">'donated_invars'</span><span class="s1">])</span>
  <span class="s1">in_shardings_known</span><span class="s2">, </span><span class="s1">_ = pe.partition_list(unks_in</span><span class="s2">, </span><span class="s1">params_known[</span><span class="s3">'in_shardings'</span><span class="s1">])</span>
  <span class="s2">if </span><span class="s1">num_res == </span><span class="s4">0</span><span class="s1">:</span>
    <span class="s1">residual_shardings = []</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">residual_shardings = [UNSPECIFIED] * num_res</span>
  <span class="s1">_</span><span class="s2">, </span><span class="s1">out_shardings_known = pe.partition_list(kept_outs_known</span><span class="s2">, </span><span class="s1">params_known[</span><span class="s3">'out_shardings'</span><span class="s1">])</span>
  <span class="s1">new_params_known = dict(params_known</span><span class="s2">,</span>
                          <span class="s1">in_shardings=tuple(in_shardings_known)</span><span class="s2">,</span>
                          <span class="s1">out_shardings=(*out_shardings_known</span><span class="s2">, </span><span class="s1">*residual_shardings)</span><span class="s2">,</span>
                          <span class="s1">donated_invars=tuple(donated_invars_known))</span>
  <span class="s2">assert </span><span class="s1">len(new_params_known[</span><span class="s3">'in_shardings'</span><span class="s1">]) == len(params_known[</span><span class="s3">'jaxpr'</span><span class="s1">].in_avals)</span>
  <span class="s2">assert </span><span class="s1">len(new_params_known[</span><span class="s3">'out_shardings'</span><span class="s1">]) == len(params_known[</span><span class="s3">'jaxpr'</span><span class="s1">].out_avals)</span>

  <span class="s0"># added num_res new inputs to jaxpr_staged, and pruning according to inst_in</span>
  <span class="s1">_</span><span class="s2">, </span><span class="s1">donated_invars_staged = pe.partition_list(inst_in</span><span class="s2">, </span><span class="s1">params_staged[</span><span class="s3">'donated_invars'</span><span class="s1">])</span>
  <span class="s1">donated_invars_staged = [</span><span class="s2">False</span><span class="s1">] * num_res + donated_invars_staged</span>
  <span class="s1">_</span><span class="s2">, </span><span class="s1">in_shardings_staged = pe.partition_list(inst_in</span><span class="s2">, </span><span class="s1">params_staged[</span><span class="s3">'in_shardings'</span><span class="s1">])</span>
  <span class="s1">in_shardings_staged = [*residual_shardings</span><span class="s2">, </span><span class="s1">*in_shardings_staged]</span>

  <span class="s1">_</span><span class="s2">, </span><span class="s1">out_shardings_staged = pe.partition_list(kept_outs_staged</span><span class="s2">, </span><span class="s1">params_staged[</span><span class="s3">'out_shardings'</span><span class="s1">])</span>

  <span class="s1">new_params_staged = dict(params_staged</span><span class="s2">,</span>
                           <span class="s1">in_shardings=tuple(in_shardings_staged)</span><span class="s2">,</span>
                           <span class="s1">out_shardings=tuple(out_shardings_staged)</span><span class="s2">,</span>
                           <span class="s1">donated_invars=tuple(donated_invars_staged))</span>
  <span class="s2">assert </span><span class="s1">len(new_params_staged[</span><span class="s3">'in_shardings'</span><span class="s1">]) == len(params_staged[</span><span class="s3">'jaxpr'</span><span class="s1">].in_avals)</span>
  <span class="s2">assert </span><span class="s1">len(new_params_staged[</span><span class="s3">'out_shardings'</span><span class="s1">]) == len(params_staged[</span><span class="s3">'jaxpr'</span><span class="s1">].out_avals)</span>
  <span class="s2">return </span><span class="s1">new_params_known</span><span class="s2">, </span><span class="s1">new_params_staged</span>

<span class="s1">pe.partial_eval_jaxpr_custom_rules[pjit_p] = \</span>
    <span class="s1">partial(pe.closed_call_partial_eval_custom_rule</span><span class="s2">, </span><span class="s3">'jaxpr'</span><span class="s2">,</span>
            <span class="s1">_pjit_partial_eval_custom_params_updater)</span>


<span class="s1">@lu.cache</span>
<span class="s2">def </span><span class="s1">_pjit_transpose_trace(fun</span><span class="s2">, </span><span class="s1">in_avals):</span>
  <span class="s1">transpose_jaxpr</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">consts = pe.trace_to_jaxpr_dynamic(fun</span><span class="s2">, </span><span class="s1">in_avals)</span>
  <span class="s1">transpose_jaxpr = core.ClosedJaxpr(transpose_jaxpr</span><span class="s2">, </span><span class="s1">consts)</span>
  <span class="s2">return </span><span class="s1">transpose_jaxpr</span>


<span class="s2">def </span><span class="s1">_pjit_transpose(reduce_axes</span><span class="s2">, </span><span class="s1">cts_in</span><span class="s2">, </span><span class="s1">*primals_in</span><span class="s2">,</span>
                    <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">,</span>
                    <span class="s1">resource_env</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">keep_unused</span><span class="s2">, </span><span class="s1">inline):</span>
  <span class="s2">def </span><span class="s1">prune_type(ty</span><span class="s2">, </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">maybe_zeros):</span>
    <span class="s2">return </span><span class="s1">tuple(x </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">mz </span><span class="s2">in </span><span class="s1">zip(xs</span><span class="s2">, </span><span class="s1">maybe_zeros) </span><span class="s2">if </span><span class="s1">type(mz) </span><span class="s2">is not </span><span class="s1">ty)</span>

  <span class="s1">body = lu.wrap_init(ad.closed_backward_pass)</span>
  <span class="s1">body = lu.hashable_partial(body</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">reduce_axes</span><span class="s2">, False</span><span class="s1">)</span>
  <span class="s1">primals_and_nz_cts_in</span><span class="s2">, </span><span class="s1">in_treedef = tree_flatten((primals_in</span><span class="s2">, </span><span class="s1">cts_in))</span>
  <span class="s1">body</span><span class="s2">, </span><span class="s1">cts_out_treedef_thunk = flatten_fun_nokwargs(body</span><span class="s2">, </span><span class="s1">in_treedef)</span>

  <span class="s1">transpose_in_shardings = (</span>
    <span class="s1">*prune_type(ad.UndefinedPrimal</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">primals_in)</span><span class="s2">,</span>
    <span class="s1">*prune_type(ad.Zero</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">, </span><span class="s1">cts_in)</span>
  <span class="s1">)</span>
  <span class="s1">global_cts_in_avals = tuple(core.raise_to_shaped(core.get_aval(ct))</span>
                              <span class="s2">for </span><span class="s1">ct </span><span class="s2">in </span><span class="s1">primals_and_nz_cts_in)</span>

  <span class="s1">transpose_jaxpr = _pjit_transpose_trace(body</span><span class="s2">, </span><span class="s1">global_cts_in_avals)</span>
  <span class="s1">cts_out_treedef = cts_out_treedef_thunk()</span>
  <span class="s1">transpose_out_shardings = prune_type(</span>
      <span class="s1">ad.Zero</span><span class="s2">,</span>
      <span class="s1">in_shardings</span><span class="s2">,</span>
      <span class="s1">tree_unflatten(cts_out_treedef</span><span class="s2">, </span><span class="s1">[object()] * cts_out_treedef.num_leaves))</span>

  <span class="s1">nz_cts_out = pjit_p.bind(</span>
      <span class="s1">*primals_and_nz_cts_in</span><span class="s2">,</span>
      <span class="s1">jaxpr=transpose_jaxpr</span><span class="s2">,</span>
      <span class="s1">in_shardings=transpose_in_shardings</span><span class="s2">,</span>
      <span class="s1">out_shardings=transpose_out_shardings</span><span class="s2">,</span>
      <span class="s1">resource_env=resource_env</span><span class="s2">,</span>
      <span class="s1">donated_invars=(</span><span class="s2">False,</span><span class="s1">) * len(primals_and_nz_cts_in)</span><span class="s2">,</span>
      <span class="s1">name=name</span><span class="s2">,</span>
      <span class="s1">keep_unused=keep_unused</span><span class="s2">,</span>
      <span class="s1">inline=inline)</span>
  <span class="s2">return </span><span class="s1">tree_unflatten(cts_out_treedef</span><span class="s2">, </span><span class="s1">nz_cts_out)</span>
<span class="s1">ad.reducing_transposes[pjit_p] = _pjit_transpose</span>


<span class="s1">@weakref_lru_cache</span>
<span class="s2">def </span><span class="s1">_dce_jaxpr_pjit(</span>
    <span class="s1">jaxpr: core.ClosedJaxpr</span><span class="s2">, </span><span class="s1">used_outputs: Tuple[bool]</span>
<span class="s1">) -&gt; Tuple[core.ClosedJaxpr</span><span class="s2">, </span><span class="s1">List[bool]]:</span>
  <span class="s1">new_jaxpr</span><span class="s2">, </span><span class="s1">used_inputs = pe.dce_jaxpr(jaxpr.jaxpr</span><span class="s2">, </span><span class="s1">used_outputs)</span>
  <span class="s2">return </span><span class="s1">core.ClosedJaxpr(new_jaxpr</span><span class="s2">, </span><span class="s1">jaxpr.consts)</span><span class="s2">, </span><span class="s1">used_inputs</span>


<span class="s2">def </span><span class="s1">dce_jaxpr_pjit_rule(used_outputs: List[bool]</span><span class="s2">, </span><span class="s1">eqn: core.JaxprEqn</span>
                        <span class="s1">) -&gt; Tuple[List[bool]</span><span class="s2">, </span><span class="s1">Optional[core.JaxprEqn]]:</span>
  <span class="s1">dced_jaxpr</span><span class="s2">, </span><span class="s1">used_inputs = _dce_jaxpr_pjit(</span>
      <span class="s1">eqn.params[</span><span class="s3">'jaxpr'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tuple(used_outputs))</span>

  <span class="s2">def </span><span class="s1">keep_where(xs</span><span class="s2">, </span><span class="s1">keeps):</span>
    <span class="s2">return </span><span class="s1">tuple(x </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">keep </span><span class="s2">in </span><span class="s1">zip(xs</span><span class="s2">, </span><span class="s1">keeps) </span><span class="s2">if </span><span class="s1">keep)</span>

  <span class="s1">eqn_params = eqn.params</span>
  <span class="s1">new_params = dict(</span>
      <span class="s1">eqn_params</span><span class="s2">,</span>
      <span class="s1">jaxpr=dced_jaxpr</span><span class="s2">,</span>
      <span class="s1">in_shardings=keep_where(eqn_params[</span><span class="s3">&quot;in_shardings&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">used_inputs)</span><span class="s2">,</span>
      <span class="s1">out_shardings=keep_where(eqn_params[</span><span class="s3">&quot;out_shardings&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">used_outputs)</span><span class="s2">,</span>
      <span class="s1">donated_invars=keep_where(eqn_params[</span><span class="s3">&quot;donated_invars&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">used_inputs)</span><span class="s2">,</span>
  <span class="s1">)</span>
  <span class="s2">if not </span><span class="s1">any(used_inputs) </span><span class="s2">and not </span><span class="s1">any(used_outputs) </span><span class="s2">and not </span><span class="s1">dced_jaxpr.effects:</span>
    <span class="s2">return </span><span class="s1">used_inputs</span><span class="s2">, None</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">new_eqn = core.new_jaxpr_eqn(</span>
        <span class="s1">[v </span><span class="s2">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">used </span><span class="s2">in </span><span class="s1">zip(eqn.invars</span><span class="s2">, </span><span class="s1">used_inputs) </span><span class="s2">if </span><span class="s1">used]</span><span class="s2">,</span>
        <span class="s1">[v </span><span class="s2">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">used </span><span class="s2">in </span><span class="s1">zip(eqn.outvars</span><span class="s2">, </span><span class="s1">used_outputs) </span><span class="s2">if </span><span class="s1">used]</span><span class="s2">,</span>
        <span class="s1">eqn.primitive</span><span class="s2">, </span><span class="s1">new_params</span><span class="s2">, </span><span class="s1">dced_jaxpr.effects</span><span class="s2">, </span><span class="s1">eqn.source_info)</span>
    <span class="s2">return </span><span class="s1">used_inputs</span><span class="s2">, </span><span class="s1">new_eqn</span>

<span class="s1">pe.dce_rules[pjit_p] = dce_jaxpr_pjit_rule</span>


<span class="s2">def </span><span class="s1">_check_resources_against_named_axes(what</span><span class="s2">, </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">pos_axis_resources</span><span class="s2">, </span><span class="s1">named_axis_resources):</span>
  <span class="s1">pjit_resources = set(</span>
      <span class="s1">it.chain.from_iterable([d </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">pos_axis_resources </span><span class="s2">if </span><span class="s1">d </span><span class="s2">is not None</span><span class="s1">]))</span>
  <span class="s1">aval_resources = set(it.chain.from_iterable(</span>
    <span class="s1">named_axis_resources[a] </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">aval.named_shape))</span>
  <span class="s1">overlap = pjit_resources &amp; aval_resources</span>
  <span class="s2">if </span><span class="s1">overlap:</span>
    <span class="s2">raise </span><span class="s1">JAXTypeError(</span>
        <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">what</span><span class="s2">} </span><span class="s3">has an axis resources specification of &quot;</span>
        <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">pos_axis_resources.unsynced_user_spec(SpecSync.DIM_PERMUTE)</span><span class="s2">} </span><span class="s3">&quot;</span>
        <span class="s3">f&quot;that uses one or more mesh axes already used by xmap to partition &quot;</span>
        <span class="s3">f&quot;a named axis appearing in its named_shape (both use mesh axes &quot;</span>
        <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">mesh_lib.show_axes(overlap)</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">_resource_typing_pjit(avals</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">source_info</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">named_axis_resources):</span>
  <span class="s1">jaxpr = params[</span><span class="s3">&quot;jaxpr&quot;</span><span class="s1">]</span>
  <span class="s1">what = </span><span class="s3">&quot;pjit input&quot;</span>
  <span class="s2">if </span><span class="s1">(resource_env </span><span class="s2">is not None and </span><span class="s1">params[</span><span class="s3">'resource_env'</span><span class="s1">] </span><span class="s2">is not None and</span>
      <span class="s1">resource_env.physical_mesh != params[</span><span class="s3">'resource_env'</span><span class="s1">].physical_mesh):</span>
      <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Changing the physical mesh is not allowed inside pjit.&quot;</span><span class="s1">)</span>

  <span class="s2">for </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">zip(jaxpr.in_avals</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'in_shardings'</span><span class="s1">]):</span>
    <span class="s2">if </span><span class="s1">is_unspecified(s) </span><span class="s2">or </span><span class="s1">is_auto(s):</span>
      <span class="s2">continue</span>
    <span class="s2">elif </span><span class="s1">hasattr(s</span><span class="s2">, </span><span class="s3">'_original_sharding'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">hasattr(</span>
        <span class="s1">s._original_sharding</span><span class="s2">, </span><span class="s3">'_parsed_pspec'</span><span class="s1">):</span>
      <span class="s1">parsed_pspec = s._original_sharding._parsed_pspec</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">if </span><span class="s1">resource_env </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">parsed_pspec = parse_flatten_op_sharding(</span>
            <span class="s1">s._hlo_sharding</span><span class="s2">, </span><span class="s1">resource_env.physical_mesh)[</span><span class="s4">0</span><span class="s1">]</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">parsed_pspec = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">parsed_pspec </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s1">_check_resources_against_named_axes(what</span><span class="s2">, </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">parsed_pspec</span><span class="s2">,</span>
                                          <span class="s1">named_axis_resources)</span>

  <span class="s1">pxla.resource_typecheck(</span>
      <span class="s1">jaxpr.jaxpr</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">named_axis_resources</span><span class="s2">,</span>
      <span class="s2">lambda</span><span class="s1">: (</span><span class="s3">f&quot;a pjit'ed function </span><span class="s2">{</span><span class="s1">params[</span><span class="s3">'name'</span><span class="s1">]</span><span class="s2">} </span><span class="s3">&quot;</span>
               <span class="s3">f&quot;(pjit called at </span><span class="s2">{</span><span class="s1">source_info_util.summarize(source_info)</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">))</span>

  <span class="s1">what = </span><span class="s3">&quot;pjit output&quot;</span>
  <span class="s2">for </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">zip(jaxpr.out_avals</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">'out_shardings'</span><span class="s1">]):</span>
    <span class="s2">if </span><span class="s1">is_unspecified(s) </span><span class="s2">or </span><span class="s1">is_auto(s):</span>
      <span class="s2">continue</span>
    <span class="s2">elif </span><span class="s1">hasattr(s</span><span class="s2">, </span><span class="s3">'_original_sharding'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">hasattr(</span>
        <span class="s1">s._original_sharding</span><span class="s2">, </span><span class="s3">'_parsed_pspec'</span><span class="s1">):</span>
      <span class="s1">parsed_pspec = s._original_sharding._parsed_pspec</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">if </span><span class="s1">resource_env </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">parsed_pspec = parse_flatten_op_sharding(</span>
            <span class="s1">s._hlo_sharding</span><span class="s2">, </span><span class="s1">resource_env.physical_mesh)[</span><span class="s4">0</span><span class="s1">]</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">parsed_pspec = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">parsed_pspec </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s1">_check_resources_against_named_axes(what</span><span class="s2">, </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">parsed_pspec</span><span class="s2">,</span>
                                          <span class="s1">named_axis_resources)</span>

<span class="s1">pxla.custom_resource_typing_rules[pjit_p] = _resource_typing_pjit</span>


<span class="s2">def </span><span class="s1">_pjit_pp_rule(eqn</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">settings):</span>
  <span class="s1">params = dict(eqn.params)</span>
  <span class="s2">del </span><span class="s1">params[</span><span class="s3">'inline'</span><span class="s1">]</span>
  <span class="s2">if not </span><span class="s1">any(params[</span><span class="s3">'donated_invars'</span><span class="s1">]):</span>
    <span class="s2">del </span><span class="s1">params[</span><span class="s3">'donated_invars'</span><span class="s1">]</span>
  <span class="s2">if </span><span class="s1">all(is_unspecified(s) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">params[</span><span class="s3">'in_shardings'</span><span class="s1">]):</span>
    <span class="s2">del </span><span class="s1">params[</span><span class="s3">'in_shardings'</span><span class="s1">]</span>
  <span class="s2">if </span><span class="s1">all(is_unspecified(s) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">params[</span><span class="s3">'out_shardings'</span><span class="s1">]):</span>
    <span class="s2">del </span><span class="s1">params[</span><span class="s3">'out_shardings'</span><span class="s1">]</span>
  <span class="s2">if not </span><span class="s1">params[</span><span class="s3">'keep_unused'</span><span class="s1">]:</span>
    <span class="s2">del </span><span class="s1">params[</span><span class="s3">'keep_unused'</span><span class="s1">]</span>
  <span class="s2">if </span><span class="s1">(params[</span><span class="s3">'resource_env'</span><span class="s1">] </span><span class="s2">is None or</span>
      <span class="s1">params[</span><span class="s3">'resource_env'</span><span class="s1">].physical_mesh.empty):</span>
    <span class="s2">del </span><span class="s1">params[</span><span class="s3">'resource_env'</span><span class="s1">]</span>
  <span class="s2">return </span><span class="s1">core._pp_eqn(eqn.replace(params=params)</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">settings)</span>
<span class="s1">core.pp_eqn_rules[pjit_p] = _pjit_pp_rule</span>


<span class="s0"># -------------------- with_sharding_constraint --------------------</span>

<span class="s2">def </span><span class="s1">with_sharding_constraint(x</span><span class="s2">, </span><span class="s1">shardings):</span>
  <span class="s5">&quot;&quot;&quot;Mechanism to constrain the sharding of an Array inside a jitted computation 
 
  This is a strict constraint for the GSPMD partitioner and not a hint. For examples 
  of how to use this function, see `Distributed arrays and automatic parallelization`_. 
 
  Args: 
    x: PyTree of jax.Arrays which will have their shardings constrainted 
    shardings: PyTree of sharding specifications. Valid values are the same as for 
      the ``in_shardings`` argument of :func:`jax.experimental.pjit`. 
  Returns: 
    x_with_shardings: PyTree of jax.Arrays with specified sharding constraints. 
 
  .. _Distributed arrays and automatic parallelization: https://jax.readthedocs.io/en/latest/notebooks/Distributed_arrays_and_automatic_parallelization.html 
  &quot;&quot;&quot;</span>
  <span class="s1">x_flat</span><span class="s2">, </span><span class="s1">tree = tree_flatten(x)</span>
  <span class="s1">user_shardings</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = prepare_axis_resources(</span>
      <span class="s1">shardings</span><span class="s2">, </span><span class="s3">&quot;shardings&quot;</span><span class="s2">, </span><span class="s1">allow_unconstrained_dims=</span><span class="s2">True</span><span class="s1">)</span>
  <span class="s2">del </span><span class="s1">shardings</span>

  <span class="s1">user_shardings_flat = tuple(</span>
      <span class="s1">flatten_axes(</span><span class="s3">&quot;with_sharding_constraint shardings&quot;</span><span class="s2">, </span><span class="s1">tree</span><span class="s2">, </span><span class="s1">user_shardings))</span>
  <span class="s2">del </span><span class="s1">user_shardings</span>

  <span class="s1">resource_env = mesh_lib.thread_resources.env</span>
  <span class="s1">mesh = resource_env.physical_mesh</span>

  <span class="s1">shardings_flat = [_create_sharding_for_array(mesh</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s3">'shardings'</span><span class="s2">,</span>
                                               <span class="s3">'with_sharding_constraint'</span><span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">user_shardings_flat]</span>
  <span class="s1">unconstrained_dims = [get_unconstrained_dims(s)</span>
                        <span class="s2">if </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">NamedSharding) </span><span class="s2">else </span><span class="s1">{}</span>
                        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">shardings_flat]</span>
  <span class="s2">del </span><span class="s1">user_shardings_flat</span>

  <span class="s1">pjit_check_aval_sharding(</span>
      <span class="s1">shardings_flat</span><span class="s2">, </span><span class="s1">x_flat</span><span class="s2">, None, </span><span class="s3">&quot;with_sharding_constraint arguments&quot;</span><span class="s2">,</span>
      <span class="s1">allow_uneven_sharding=</span><span class="s2">True</span><span class="s1">)</span>

  <span class="s1">outs = [sharding_constraint_p.bind(xf</span><span class="s2">, </span><span class="s1">sharding=to_gspmd_sharding(i</span><span class="s2">, </span><span class="s1">xf.ndim)</span><span class="s2">,</span>
                                     <span class="s1">resource_env=resource_env</span><span class="s2">,</span>
                                     <span class="s1">unconstrained_dims=ud)</span>
          <span class="s2">for </span><span class="s1">xf</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">ud </span><span class="s2">in </span><span class="s1">zip(x_flat</span><span class="s2">, </span><span class="s1">shardings_flat</span><span class="s2">, </span><span class="s1">unconstrained_dims)]</span>
  <span class="s2">return </span><span class="s1">tree_unflatten(tree</span><span class="s2">, </span><span class="s1">outs)</span>

<span class="s2">def </span><span class="s1">_identity_fn(x): </span><span class="s2">return </span><span class="s1">x</span>

<span class="s2">def </span><span class="s1">_sharding_constraint_impl(x</span><span class="s2">, </span><span class="s1">sharding</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">unconstrained_dims):</span>
  <span class="s2">if </span><span class="s1">hasattr(x</span><span class="s2">, </span><span class="s3">'sharding'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">x.sharding.is_equivalent_to(sharding</span><span class="s2">, </span><span class="s1">x.ndim):</span>
    <span class="s2">return </span><span class="s1">x</span>
  <span class="s0"># Run a jit here to raise good errors when device assignment don't match.</span>
  <span class="s2">return </span><span class="s1">api.jit(_identity_fn</span><span class="s2">, </span><span class="s1">out_shardings=sharding)(x)</span>


<span class="s1">sharding_constraint_p = core.Primitive(</span><span class="s3">&quot;sharding_constraint&quot;</span><span class="s1">)</span>
<span class="s1">sharding_constraint_p.def_impl(_sharding_constraint_impl)</span>
<span class="s1">sharding_constraint_p.def_abstract_eval(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**_: x)</span>
<span class="s1">ad.deflinear2(sharding_constraint_p</span><span class="s2">,</span>
              <span class="s2">lambda </span><span class="s1">ct</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">**params: (sharding_constraint_p.bind(ct</span><span class="s2">, </span><span class="s1">**params)</span><span class="s2">,</span><span class="s1">))</span>

<span class="s2">def </span><span class="s1">_sharding_constraint_hlo_lowering(ctx</span><span class="s2">, </span><span class="s1">x_node</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">sharding</span><span class="s2">,</span>
                                      <span class="s1">resource_env</span><span class="s2">, </span><span class="s1">unconstrained_dims):</span>
  <span class="s1">aval</span><span class="s2">, </span><span class="s1">= ctx.avals_in</span>
  <span class="s1">out_aval</span><span class="s2">, </span><span class="s1">= ctx.avals_out</span>
  <span class="s1">axis_ctx = ctx.module_context.axis_context</span>
  <span class="s0"># axis_ctx and manual_axes is *only used with xmap* and xmap only works with</span>
  <span class="s0"># NamedSharding. So convert the GSPMDSharding to NamedSharding</span>
  <span class="s0"># and then convert it back with the added special axes.</span>
  <span class="s2">if </span><span class="s1">isinstance(axis_ctx</span><span class="s2">, </span><span class="s1">sharding_impls.SPMDAxisContext):</span>
    <span class="s1">mesh = resource_env.physical_mesh</span>
    <span class="s1">parsed_pspec = parse_flatten_op_sharding(sharding._hlo_sharding</span><span class="s2">, </span><span class="s1">mesh)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">mps = NamedSharding._from_parsed_pspec(mesh</span><span class="s2">, </span><span class="s1">parsed_pspec)</span>
    <span class="s1">sharding = GSPMDSharding(</span>
        <span class="s1">mps._device_assignment</span><span class="s2">, </span><span class="s1">mps._to_xla_hlo_sharding(aval.ndim</span><span class="s2">, </span><span class="s1">axis_ctx=axis_ctx))</span>
  <span class="s2">return </span><span class="s1">[</span>
      <span class="s1">mlir.wrap_with_sharding_op(ctx</span><span class="s2">,</span>
          <span class="s1">x_node</span><span class="s2">, </span><span class="s1">out_aval</span><span class="s2">,</span>
          <span class="s1">sharding._to_xla_hlo_sharding(aval.ndim).to_proto()</span><span class="s2">,</span>
          <span class="s1">unspecified_dims=unconstrained_dims)</span>
  <span class="s1">]</span>
<span class="s1">mlir.register_lowering(sharding_constraint_p</span><span class="s2">,</span>
                       <span class="s1">_sharding_constraint_hlo_lowering)</span>


<span class="s2">def </span><span class="s1">_sharding_constraint_batcher(insert_axis</span><span class="s2">, </span><span class="s1">spmd_axis_name</span><span class="s2">, </span><span class="s1">axis_size</span><span class="s2">,</span>
                                 <span class="s1">axis_name</span><span class="s2">, </span><span class="s1">main_type</span><span class="s2">, </span><span class="s1">vals_in</span><span class="s2">, </span><span class="s1">dims_in</span><span class="s2">,</span>
                                 <span class="s1">sharding</span><span class="s2">, </span><span class="s1">resource_env</span><span class="s2">, </span><span class="s1">unconstrained_dims):</span>
  <span class="s1">x</span><span class="s2">, </span><span class="s1">= vals_in</span>
  <span class="s1">d</span><span class="s2">, </span><span class="s1">= dims_in</span>
  <span class="s0"># None means unconstrained in ParsedPartitionSpec</span>
  <span class="s1">new_parts = (axis_name</span><span class="s2">,</span><span class="s1">) </span><span class="s2">if </span><span class="s1">insert_axis </span><span class="s2">else </span><span class="s1">(</span>
      <span class="s2">None if </span><span class="s1">spmd_axis_name </span><span class="s2">is None else </span><span class="s1">spmd_axis_name)</span>
  <span class="s1">unconstrained_dims = {ud + (d &lt;= ud) </span><span class="s2">for </span><span class="s1">ud </span><span class="s2">in </span><span class="s1">unconstrained_dims}</span>
  <span class="s2">if </span><span class="s1">new_parts </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">unconstrained_dims.add(d)</span>
  <span class="s1">y = sharding_constraint_p.bind(</span>
      <span class="s1">x</span><span class="s2">,</span>
      <span class="s1">sharding=_pjit_batcher_for_sharding(</span>
          <span class="s1">sharding</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">new_parts</span><span class="s2">, </span><span class="s1">resource_env.physical_mesh</span><span class="s2">, </span><span class="s1">x.ndim)</span><span class="s2">,</span>
      <span class="s1">resource_env=resource_env</span><span class="s2">,</span>
      <span class="s1">unconstrained_dims=unconstrained_dims)</span>
  <span class="s2">return </span><span class="s1">y</span><span class="s2">, </span><span class="s1">d</span>
<span class="s1">batching.spmd_axis_primitive_batchers[sharding_constraint_p] = partial(</span>
    <span class="s1">_sharding_constraint_batcher</span><span class="s2">, False</span><span class="s1">)</span>
<span class="s1">batching.axis_primitive_batchers[sharding_constraint_p] = partial(</span>
    <span class="s1">_sharding_constraint_batcher</span><span class="s2">, False, None</span><span class="s1">)</span>
<span class="s1">pxla.spmd_primitive_batchers[sharding_constraint_p] = partial(</span>
    <span class="s1">_sharding_constraint_batcher</span><span class="s2">, True, None</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_resource_typing_sharding_constraint(avals</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">source_info</span><span class="s2">,</span>
                                         <span class="s1">resource_env</span><span class="s2">, </span><span class="s1">named_axis_resources):</span>
  <span class="s1">aval</span><span class="s2">, </span><span class="s1">= avals</span>
  <span class="s2">if </span><span class="s1">hasattr(params[</span><span class="s3">'sharding'</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'_original_sharding'</span><span class="s1">):</span>
    <span class="s1">parsed_pspec = params[</span><span class="s3">'sharding'</span><span class="s1">]._original_sharding._parsed_pspec</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">parsed_pspec = parse_flatten_op_sharding(</span>
        <span class="s1">params[</span><span class="s3">'sharding'</span><span class="s1">]._hlo_sharding</span><span class="s2">, </span><span class="s1">resource_env.physical_mesh)[</span><span class="s4">0</span><span class="s1">]</span>
  <span class="s1">_check_resources_against_named_axes(</span>
    <span class="s3">&quot;with_sharding_constraint input&quot;</span><span class="s2">, </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">parsed_pspec</span><span class="s2">, </span><span class="s1">named_axis_resources)</span>

<span class="s1">pxla.custom_resource_typing_rules[sharding_constraint_p] = \</span>
    <span class="s1">_resource_typing_sharding_constraint</span>

<span class="s0"># -------------------- helpers --------------------</span>

<span class="s1">@lru_cache(maxsize=</span><span class="s4">2048</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">to_gspmd_sharding(s: XLACompatibleSharding</span><span class="s2">, </span><span class="s1">ndim: int</span><span class="s2">,</span>
                      <span class="s1">device_or_backend_set: bool = </span><span class="s2">False</span><span class="s1">) -&gt; GSPMDSharding:</span>
  <span class="s2">if </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">GSPMDSharding):</span>
    <span class="s2">return </span><span class="s1">s</span>
  <span class="s1">gs = GSPMDSharding(s._device_assignment</span><span class="s2">, </span><span class="s1">s._to_xla_hlo_sharding(ndim))</span>
  <span class="s1">gs._original_sharding = s</span>
  <span class="s2">if </span><span class="s1">device_or_backend_set:</span>
    <span class="s1">gs._original_sharding._device_backend = device_or_backend_set</span>
  <span class="s2">return </span><span class="s1">gs</span>


<span class="s2">def </span><span class="s1">get_unconstrained_dims(sharding: NamedSharding):</span>
  <span class="s2">assert </span><span class="s1">sharding._parsed_pspec </span><span class="s2">is not None</span>
  <span class="s2">return </span><span class="s1">{i </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">axes </span><span class="s2">in </span><span class="s1">enumerate(sharding._parsed_pspec)</span>
          <span class="s2">if </span><span class="s1">axes </span><span class="s2">is None</span><span class="s1">}</span>


<span class="s2">def </span><span class="s1">_fast_path_get_device_assignment(</span>
    <span class="s1">shardings: Iterable[PjitSharding]) -&gt; Optional[XLADeviceAssignment]:</span>
  <span class="s1">da = </span><span class="s2">None</span>
  <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">shardings:</span>
    <span class="s2">if </span><span class="s1">is_unspecified(i):</span>
      <span class="s2">continue</span>
    <span class="s2">if </span><span class="s1">is_auto(i):</span>
      <span class="s2">return </span><span class="s1">i.mesh._flat_devices_tuple  </span><span class="s0"># type: ignore</span>
    <span class="s2">return </span><span class="s1">i._device_assignment  </span><span class="s0"># type: ignore</span>
  <span class="s2">return </span><span class="s1">da</span>


<span class="s2">def </span><span class="s1">_get_partition_spec(ppspec: Sequence[ParsedPartitionSpec]) -&gt; Sequence[PartitionSpec]:</span>
  <span class="s2">return </span><span class="s1">[get_single_pspec(p) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">ppspec]</span>


<span class="s2">def </span><span class="s1">_get_op_sharding_from_executable(</span>
    <span class="s1">executable) -&gt; Tuple[Sequence[xc.OpSharding]</span><span class="s2">, </span><span class="s1">Sequence[xc.OpSharding]]:</span>
  <span class="s1">in_op_shardings: List[xc.OpSharding] = []</span>
  <span class="s1">parameter_shardings_from_xla = executable.get_parameter_shardings()</span>
  <span class="s2">if </span><span class="s1">parameter_shardings_from_xla </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s1">in_op_shardings = parameter_shardings_from_xla</span>

  <span class="s1">out_op_shardings: List[xc.OpSharding] = []</span>
  <span class="s1">output_shardings_from_xla = executable.get_output_shardings()</span>
  <span class="s2">if </span><span class="s1">output_shardings_from_xla </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s1">out_op_shardings = output_shardings_from_xla</span>

  <span class="s2">return </span><span class="s1">in_op_shardings</span><span class="s2">, </span><span class="s1">out_op_shardings</span>


<span class="s2">def </span><span class="s1">_get_ppspec_from_executable(executable</span><span class="s2">, </span><span class="s1">mesh) -&gt; Tuple[Sequence[ParsedPartitionSpec]</span><span class="s2">, </span><span class="s1">Sequence[ParsedPartitionSpec]]:</span>
  <span class="s1">input_op_shardings: Sequence[xc.OpSharding] = executable.hlo_modules()[</span><span class="s4">0</span><span class="s1">].spmd_parameters_shardings</span>
  <span class="s1">output_op_sharding: xc.OpSharding = executable.hlo_modules()[</span><span class="s4">0</span><span class="s1">].spmd_output_sharding</span>
  <span class="s1">in_ppspec: List[ParsedPartitionSpec] = []</span>
  <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">input_op_shardings:</span>
    <span class="s1">in_ppspec.extend(parse_flatten_op_sharding(s</span><span class="s2">, </span><span class="s1">mesh))</span>
  <span class="s1">out_ppspec = parse_flatten_op_sharding(output_op_sharding</span><span class="s2">, </span><span class="s1">mesh)</span>
  <span class="s2">return </span><span class="s1">in_ppspec</span><span class="s2">, </span><span class="s1">out_ppspec</span>


<span class="s2">def </span><span class="s1">_get_pspec_from_executable(</span>
    <span class="s1">executable</span><span class="s2">, </span><span class="s1">mesh: pxla.Mesh</span>
<span class="s1">) -&gt; Tuple[Tuple[PartitionSpec</span><span class="s2">, </span><span class="s1">...]</span><span class="s2">, </span><span class="s1">Tuple[PartitionSpec</span><span class="s2">, </span><span class="s1">...]]:</span>
  <span class="s1">in_ppspec</span><span class="s2">, </span><span class="s1">out_ppspec = _get_ppspec_from_executable(executable</span><span class="s2">, </span><span class="s1">mesh)</span>
  <span class="s1">out_partition_spec = _get_partition_spec(out_ppspec)</span>
  <span class="s1">in_partition_spec = _get_partition_spec(in_ppspec)</span>
  <span class="s2">return </span><span class="s1">tuple(in_partition_spec)</span><span class="s2">, </span><span class="s1">tuple(out_partition_spec)</span>
</pre>
</body>
</html>