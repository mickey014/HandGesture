<html>
<head>
<title>sounddevice.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sounddevice.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (c) 2015-2023 Matthias Geier</span>
<span class="s0">#</span>
<span class="s0"># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="s0"># of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="s0"># in the Software without restriction, including without limitation the rights</span>
<span class="s0"># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="s0"># copies of the Software, and to permit persons to whom the Software is</span>
<span class="s0"># furnished to do so, subject to the following conditions:</span>
<span class="s0">#</span>
<span class="s0"># The above copyright notice and this permission notice shall be included in</span>
<span class="s0"># all copies or substantial portions of the Software.</span>
<span class="s0">#</span>
<span class="s0"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="s0"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="s0"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="s0"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="s0"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="s0"># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span>
<span class="s0"># THE SOFTWARE.</span>

<span class="s2">&quot;&quot;&quot;Play and Record Sound with Python. 
 
API overview: 
  * Convenience functions to play and record NumPy arrays: 
    `play()`, `rec()`, `playrec()` and the related functions 
    `wait()`, `stop()`, `get_status()`, `get_stream()` 
 
  * Functions to get information about the available hardware: 
    `query_devices()`, `query_hostapis()`, 
    `check_input_settings()`, `check_output_settings()` 
 
  * Module-wide default settings: `default` 
 
  * Platform-specific settings: 
    `AsioSettings`, `CoreAudioSettings`, `WasapiSettings` 
 
  * PortAudio streams, using NumPy arrays: 
    `Stream`, `InputStream`, `OutputStream` 
 
  * PortAudio streams, using Python buffer objects (NumPy not needed): 
    `RawStream`, `RawInputStream`, `RawOutputStream` 
 
  * Miscellaneous functions and classes: 
    `sleep()`, `get_portaudio_version()`, `CallbackFlags`, 
    `CallbackStop`, `CallbackAbort` 
 
Online documentation: 
    https://python-sounddevice.readthedocs.io/ 
 
&quot;&quot;&quot;</span>
<span class="s1">__version__ = </span><span class="s3">'0.4.6'</span>

<span class="s4">import </span><span class="s1">atexit </span><span class="s4">as </span><span class="s1">_atexit</span>
<span class="s4">import </span><span class="s1">os </span><span class="s4">as </span><span class="s1">_os</span>
<span class="s4">import </span><span class="s1">platform </span><span class="s4">as </span><span class="s1">_platform</span>
<span class="s4">import </span><span class="s1">sys </span><span class="s4">as </span><span class="s1">_sys</span>
<span class="s4">from </span><span class="s1">ctypes.util </span><span class="s4">import </span><span class="s1">find_library </span><span class="s4">as </span><span class="s1">_find_library</span>
<span class="s4">from </span><span class="s1">_sounddevice </span><span class="s4">import </span><span class="s1">ffi </span><span class="s4">as </span><span class="s1">_ffi</span>


<span class="s4">try</span><span class="s1">:</span>
    <span class="s4">for </span><span class="s1">_libname </span><span class="s4">in </span><span class="s1">(</span>
            <span class="s3">'portaudio'</span><span class="s4">,  </span><span class="s0"># Default name on POSIX systems</span>
            <span class="s3">'bin</span><span class="s4">\\</span><span class="s3">libportaudio-2.dll'</span><span class="s4">,  </span><span class="s0"># DLL from conda-forge</span>
            <span class="s3">'lib/libportaudio.dylib'</span><span class="s4">,  </span><span class="s0"># dylib from anaconda</span>
            <span class="s1">):</span>
        <span class="s1">_libname = _find_library(_libname)</span>
        <span class="s4">if </span><span class="s1">_libname </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">break</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">OSError(</span><span class="s3">'PortAudio library not found'</span><span class="s1">)</span>
    <span class="s1">_lib = _ffi.dlopen(_libname)</span>
<span class="s4">except </span><span class="s1">OSError:</span>
    <span class="s4">if </span><span class="s1">_platform.system() == </span><span class="s3">'Darwin'</span><span class="s1">:</span>
        <span class="s1">_libname = </span><span class="s3">'libportaudio.dylib'</span>
    <span class="s4">elif </span><span class="s1">_platform.system() == </span><span class="s3">'Windows'</span><span class="s1">:</span>
        <span class="s1">_libname = </span><span class="s3">'libportaudio' </span><span class="s1">+ _platform.architecture()[</span><span class="s5">0</span><span class="s1">] + </span><span class="s3">'.dll'</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">raise</span>
    <span class="s4">import </span><span class="s1">_sounddevice_data</span>
    <span class="s1">_libname = _os.path.join(</span>
        <span class="s1">next(iter(_sounddevice_data.__path__))</span><span class="s4">, </span><span class="s3">'portaudio-binaries'</span><span class="s4">, </span><span class="s1">_libname)</span>
    <span class="s1">_lib = _ffi.dlopen(_libname)</span>

<span class="s1">_sampleformats = {</span>
    <span class="s3">'float32'</span><span class="s1">: _lib.paFloat32</span><span class="s4">,</span>
    <span class="s3">'int32'</span><span class="s1">: _lib.paInt32</span><span class="s4">,</span>
    <span class="s3">'int24'</span><span class="s1">: _lib.paInt24</span><span class="s4">,</span>
    <span class="s3">'int16'</span><span class="s1">: _lib.paInt16</span><span class="s4">,</span>
    <span class="s3">'int8'</span><span class="s1">: _lib.paInt8</span><span class="s4">,</span>
    <span class="s3">'uint8'</span><span class="s1">: _lib.paUInt8</span><span class="s4">,</span>
<span class="s1">}</span>

<span class="s1">_initialized = </span><span class="s5">0</span>
<span class="s1">_last_callback = </span><span class="s4">None</span>


<span class="s4">def </span><span class="s1">play(data</span><span class="s4">, </span><span class="s1">samplerate=</span><span class="s4">None, </span><span class="s1">mapping=</span><span class="s4">None, </span><span class="s1">blocking=</span><span class="s4">False, </span><span class="s1">loop=</span><span class="s4">False,</span>
         <span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot;Play back a NumPy array containing audio data. 
 
    This is a convenience function for interactive use and for small 
    scripts.  It cannot be used for multiple overlapping playbacks. 
 
    This function does the following steps internally: 
 
    * Call `stop()` to terminate any currently running invocation 
      of `play()`, `rec()` and `playrec()`. 
 
    * Create an `OutputStream` and a callback function for taking care 
      of the actual playback. 
 
    * Start the stream. 
 
    * If ``blocking=True`` was given, wait until playback is done. 
      If not, return immediately 
      (to start waiting at a later point, `wait()` can be used). 
 
    If you need more control (e.g. block-wise gapless playback, multiple 
    overlapping playbacks, ...), you should explicitly create an 
    `OutputStream` yourself. 
    If NumPy is not available, you can use a `RawOutputStream`. 
 
    Parameters 
    ---------- 
    data : array_like 
        Audio data to be played back.  The columns of a two-dimensional 
        array are interpreted as channels, one-dimensional arrays are 
        treated as mono data. 
        The data types *float64*, *float32*, *int32*, *int16*, *int8* 
        and *uint8* can be used. 
        *float64* data is simply converted to *float32* before passing 
        it to PortAudio, because it's not supported natively. 
    mapping : array_like, optional 
        List of channel numbers (starting with 1) where the columns of 
        *data* shall be played back on.  Must have the same length as 
        number of channels in *data* (except if *data* is mono, in which 
        case the signal is played back on all given output channels). 
        Each channel number may only appear once in *mapping*. 
    blocking : bool, optional 
        If ``False`` (the default), return immediately (but playback 
        continues in the background), if ``True``, wait until playback 
        is finished.  A non-blocking invocation can be stopped with 
        `stop()` or turned into a blocking one with `wait()`. 
    loop : bool, optional 
        Play *data* in a loop. 
 
    Other Parameters 
    ---------------- 
    samplerate, **kwargs 
        All parameters of `OutputStream` -- except *channels*, *dtype*, 
        *callback* and *finished_callback* -- can be used. 
 
    Notes 
    ----- 
    If you don't specify the correct sampling rate 
    (either with the *samplerate* argument or by assigning a value to 
    `default.samplerate`), the audio data will be played back, 
    but it might be too slow or too fast! 
 
    See Also 
    -------- 
    rec, playrec 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ctx = _CallbackContext(loop=loop)</span>
    <span class="s1">ctx.frames = ctx.check_data(data</span><span class="s4">, </span><span class="s1">mapping</span><span class="s4">, </span><span class="s1">kwargs.get(</span><span class="s3">'device'</span><span class="s1">))</span>

    <span class="s4">def </span><span class="s1">callback(outdata</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">status):</span>
        <span class="s4">assert </span><span class="s1">len(outdata) == frames</span>
        <span class="s1">ctx.callback_enter(status</span><span class="s4">, </span><span class="s1">outdata)</span>
        <span class="s1">ctx.write_outdata(outdata)</span>
        <span class="s1">ctx.callback_exit()</span>

    <span class="s1">ctx.start_stream(OutputStream</span><span class="s4">, </span><span class="s1">samplerate</span><span class="s4">, </span><span class="s1">ctx.output_channels</span><span class="s4">,</span>
                     <span class="s1">ctx.output_dtype</span><span class="s4">, </span><span class="s1">callback</span><span class="s4">, </span><span class="s1">blocking</span><span class="s4">,</span>
                     <span class="s1">prime_output_buffers_using_stream_callback=</span><span class="s4">False,</span>
                     <span class="s1">**kwargs)</span>


<span class="s4">def </span><span class="s1">rec(frames=</span><span class="s4">None, </span><span class="s1">samplerate=</span><span class="s4">None, </span><span class="s1">channels=</span><span class="s4">None, </span><span class="s1">dtype=</span><span class="s4">None,</span>
        <span class="s1">out=</span><span class="s4">None, </span><span class="s1">mapping=</span><span class="s4">None, </span><span class="s1">blocking=</span><span class="s4">False, </span><span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot;Record audio data into a NumPy array. 
 
    This is a convenience function for interactive use and for small 
    scripts. 
 
    This function does the following steps internally: 
 
    * Call `stop()` to terminate any currently running invocation 
      of `play()`, `rec()` and `playrec()`. 
 
    * Create an `InputStream` and a callback function for taking care 
      of the actual recording. 
 
    * Start the stream. 
 
    * If ``blocking=True`` was given, wait until recording is done. 
      If not, return immediately 
      (to start waiting at a later point, `wait()` can be used). 
 
    If you need more control (e.g. block-wise gapless recording, 
    overlapping recordings, ...), you should explicitly create an 
    `InputStream` yourself. 
    If NumPy is not available, you can use a `RawInputStream`. 
 
    Parameters 
    ---------- 
    frames : int, sometimes optional 
        Number of frames to record.  Not needed if *out* is given. 
    channels : int, optional 
        Number of channels to record.  Not needed if *mapping* or *out* 
        is given.  The default value can be changed with 
        `default.channels`. 
    dtype : str or numpy.dtype, optional 
        Data type of the recording.  Not needed if *out* is given. 
        The data types *float64*, *float32*, *int32*, *int16*, *int8* 
        and *uint8* can be used.  For ``dtype='float64'``, audio data is 
        recorded in *float32* format and converted afterwards, because 
        it's not natively supported by PortAudio.  The default value can 
        be changed with `default.dtype`. 
    mapping : array_like, optional 
        List of channel numbers (starting with 1) to record. 
        If *mapping* is given, *channels* is silently ignored. 
    blocking : bool, optional 
        If ``False`` (the default), return immediately (but recording 
        continues in the background), if ``True``, wait until recording 
        is finished. 
        A non-blocking invocation can be stopped with `stop()` or turned 
        into a blocking one with `wait()`. 
 
    Returns 
    ------- 
    numpy.ndarray or type(out) 
        The recorded data. 
 
        .. note:: By default (``blocking=False``), an array of data is 
           returned which is still being written to while recording! 
           The returned data is only valid once recording has stopped. 
           Use `wait()` to make sure the recording is finished. 
 
    Other Parameters 
    ---------------- 
    out : numpy.ndarray or subclass, optional 
        If *out* is specified, the recorded data is written into the 
        given array instead of creating a new array. 
        In this case, the arguments *frames*, *channels* and *dtype* are 
        silently ignored! 
        If *mapping* is given, its length must match the number of 
        channels in *out*. 
    samplerate, **kwargs 
        All parameters of `InputStream` -- except *callback* and 
        *finished_callback* -- can be used. 
 
    Notes 
    ----- 
    If you don't specify a sampling rate (either with the *samplerate* 
    argument or by assigning a value to `default.samplerate`), 
    the default sampling rate of the sound device will be used 
    (see `query_devices()`). 
 
    See Also 
    -------- 
    play, playrec 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ctx = _CallbackContext()</span>
    <span class="s1">out</span><span class="s4">, </span><span class="s1">ctx.frames = ctx.check_out(out</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">channels</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">mapping)</span>

    <span class="s4">def </span><span class="s1">callback(indata</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">status):</span>
        <span class="s4">assert </span><span class="s1">len(indata) == frames</span>
        <span class="s1">ctx.callback_enter(status</span><span class="s4">, </span><span class="s1">indata)</span>
        <span class="s1">ctx.read_indata(indata)</span>
        <span class="s1">ctx.callback_exit()</span>

    <span class="s1">ctx.start_stream(InputStream</span><span class="s4">, </span><span class="s1">samplerate</span><span class="s4">, </span><span class="s1">ctx.input_channels</span><span class="s4">,</span>
                     <span class="s1">ctx.input_dtype</span><span class="s4">, </span><span class="s1">callback</span><span class="s4">, </span><span class="s1">blocking</span><span class="s4">, </span><span class="s1">**kwargs)</span>
    <span class="s4">return </span><span class="s1">out</span>


<span class="s4">def </span><span class="s1">playrec(data</span><span class="s4">, </span><span class="s1">samplerate=</span><span class="s4">None, </span><span class="s1">channels=</span><span class="s4">None, </span><span class="s1">dtype=</span><span class="s4">None,</span>
            <span class="s1">out=</span><span class="s4">None, </span><span class="s1">input_mapping=</span><span class="s4">None, </span><span class="s1">output_mapping=</span><span class="s4">None, </span><span class="s1">blocking=</span><span class="s4">False,</span>
            <span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot;Simultaneous playback and recording of NumPy arrays. 
 
    This function does the following steps internally: 
 
    * Call `stop()` to terminate any currently running invocation 
      of `play()`, `rec()` and `playrec()`. 
 
    * Create a `Stream` and a callback function for taking care of the 
      actual playback and recording. 
 
    * Start the stream. 
 
    * If ``blocking=True`` was given, wait until playback/recording is 
      done.  If not, return immediately 
      (to start waiting at a later point, `wait()` can be used). 
 
    If you need more control (e.g. block-wise gapless playback and 
    recording, realtime processing, ...), 
    you should explicitly create a `Stream` yourself. 
    If NumPy is not available, you can use a `RawStream`. 
 
    Parameters 
    ---------- 
    data : array_like 
        Audio data to be played back.  See `play()`. 
    channels : int, sometimes optional 
        Number of input channels, see `rec()`. 
        The number of output channels is obtained from *data.shape*. 
    dtype : str or numpy.dtype, optional 
        Input data type, see `rec()`. 
        If *dtype* is not specified, it is taken from *data.dtype* 
        (i.e. `default.dtype` is ignored). 
        The output data type is obtained from *data.dtype* anyway. 
    input_mapping, output_mapping : array_like, optional 
        See the parameter *mapping* of `rec()` and `play()`, 
        respectively. 
    blocking : bool, optional 
        If ``False`` (the default), return immediately (but continue 
        playback/recording in the background), if ``True``, wait until 
        playback/recording is finished. 
        A non-blocking invocation can be stopped with `stop()` or turned 
        into a blocking one with `wait()`. 
 
    Returns 
    ------- 
    numpy.ndarray or type(out) 
        The recorded data.  See `rec()`. 
 
    Other Parameters 
    ---------------- 
    out : numpy.ndarray or subclass, optional 
        See `rec()`. 
    samplerate, **kwargs 
        All parameters of `Stream` -- except *channels*, *dtype*, 
        *callback* and *finished_callback* -- can be used. 
 
    Notes 
    ----- 
    If you don't specify the correct sampling rate 
    (either with the *samplerate* argument or by assigning a value to 
    `default.samplerate`), the audio data will be played back, 
    but it might be too slow or too fast! 
 
    See Also 
    -------- 
    play, rec 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ctx = _CallbackContext()</span>
    <span class="s1">output_frames = ctx.check_data(data</span><span class="s4">, </span><span class="s1">output_mapping</span><span class="s4">, </span><span class="s1">kwargs.get(</span><span class="s3">'device'</span><span class="s1">))</span>
    <span class="s4">if </span><span class="s1">dtype </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">dtype = ctx.data.dtype  </span><span class="s0"># ignore module defaults</span>
    <span class="s1">out</span><span class="s4">, </span><span class="s1">input_frames = ctx.check_out(out</span><span class="s4">, </span><span class="s1">output_frames</span><span class="s4">, </span><span class="s1">channels</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">,</span>
                                      <span class="s1">input_mapping)</span>
    <span class="s4">if </span><span class="s1">input_frames != output_frames:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'len(data) != len(out)'</span><span class="s1">)</span>
    <span class="s1">ctx.frames = input_frames</span>

    <span class="s4">def </span><span class="s1">callback(indata</span><span class="s4">, </span><span class="s1">outdata</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">status):</span>
        <span class="s4">assert </span><span class="s1">len(indata) == len(outdata) == frames</span>
        <span class="s1">ctx.callback_enter(status</span><span class="s4">, </span><span class="s1">indata)</span>
        <span class="s1">ctx.read_indata(indata)</span>
        <span class="s1">ctx.write_outdata(outdata)</span>
        <span class="s1">ctx.callback_exit()</span>

    <span class="s1">ctx.start_stream(Stream</span><span class="s4">, </span><span class="s1">samplerate</span><span class="s4">,</span>
                     <span class="s1">(ctx.input_channels</span><span class="s4">, </span><span class="s1">ctx.output_channels)</span><span class="s4">,</span>
                     <span class="s1">(ctx.input_dtype</span><span class="s4">, </span><span class="s1">ctx.output_dtype)</span><span class="s4">,</span>
                     <span class="s1">callback</span><span class="s4">, </span><span class="s1">blocking</span><span class="s4">,</span>
                     <span class="s1">prime_output_buffers_using_stream_callback=</span><span class="s4">False,</span>
                     <span class="s1">**kwargs)</span>
    <span class="s4">return </span><span class="s1">out</span>


<span class="s4">def </span><span class="s1">wait(ignore_errors=</span><span class="s4">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Wait for `play()`/`rec()`/`playrec()` to be finished. 
 
    Playback/recording can be stopped with a `KeyboardInterrupt`. 
 
    Returns 
    ------- 
    CallbackFlags or None 
        If at least one buffer over-/underrun happened during the last 
        playback/recording, a `CallbackFlags` object is returned. 
 
    See Also 
    -------- 
    get_status 
 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">_last_callback:</span>
        <span class="s4">return </span><span class="s1">_last_callback.wait(ignore_errors)</span>


<span class="s4">def </span><span class="s1">stop(ignore_errors=</span><span class="s4">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Stop playback/recording. 
 
    This only stops `play()`, `rec()` and `playrec()`, but has no 
    influence on streams created with `Stream`, `InputStream`, 
    `OutputStream`, `RawStream`, `RawInputStream`, `RawOutputStream`. 
 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">_last_callback:</span>
        <span class="s0"># Calling stop() before close() is necessary for older PortAudio</span>
        <span class="s0"># versions, see issue #87:</span>
        <span class="s1">_last_callback.stream.stop(ignore_errors)</span>
        <span class="s1">_last_callback.stream.close(ignore_errors)</span>


<span class="s4">def </span><span class="s1">get_status():</span>
    <span class="s2">&quot;&quot;&quot;Get info about over-/underflows in `play()`/`rec()`/`playrec()`. 
 
    Returns 
    ------- 
    CallbackFlags 
        A `CallbackFlags` object that holds information about the last 
        invocation of `play()`, `rec()` or `playrec()`. 
 
    See Also 
    -------- 
    wait 
 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">_last_callback:</span>
        <span class="s4">return </span><span class="s1">_last_callback.status</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">RuntimeError(</span><span class="s3">'play()/rec()/playrec() was not called yet'</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">get_stream():</span>
    <span class="s2">&quot;&quot;&quot;Get a reference to the current stream. 
 
    This applies only to streams created by calls to `play()`, `rec()` 
    or `playrec()`. 
 
    Returns 
    ------- 
    Stream 
        An `OutputStream`, `InputStream` or `Stream` associated with 
        the last invocation of `play()`, `rec()` or `playrec()`, 
        respectively. 
 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">_last_callback:</span>
        <span class="s4">return </span><span class="s1">_last_callback.stream</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">RuntimeError(</span><span class="s3">'play()/rec()/playrec() was not called yet'</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">query_devices(device=</span><span class="s4">None, </span><span class="s1">kind=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Return information about available devices. 
 
    Information and capabilities of PortAudio devices. 
    Devices may support input, output or both input and output. 
 
    To find the default input/output device(s), use `default.device`. 
 
    Parameters 
    ---------- 
    device : int or str, optional 
        Numeric device ID or device name substring(s). 
        If specified, information about only the given *device* is 
        returned in a single dictionary. 
    kind : {'input', 'output'}, optional 
        If *device* is not specified and *kind* is ``'input'`` or 
        ``'output'``, a single dictionary is returned with information 
        about the default input or output device, respectively. 
 
    Returns 
    ------- 
    dict or DeviceList 
        A dictionary with information about the given *device* or -- if 
        no arguments were specified -- a `DeviceList` containing one 
        dictionary for each available device. 
        The dictionaries have the following keys: 
 
        ``'name'`` 
            The name of the device. 
        ``'index'`` 
            The device index. 
        ``'hostapi'`` 
            The ID of the corresponding host API.  Use 
            `query_hostapis()` to get information about a host API. 
        ``'max_input_channels'``, ``'max_output_channels'`` 
            The maximum number of input/output channels supported by the 
            device.  See `default.channels`. 
        ``'default_low_input_latency'``, ``'default_low_output_latency'`` 
            Default latency values for interactive performance. 
            This is used if `default.latency` (or the *latency* argument 
            of `playrec()`, `Stream` etc.) is set to ``'low'``. 
        ``'default_high_input_latency'``, ``'default_high_output_latency'`` 
            Default latency values for robust non-interactive 
            applications (e.g. playing sound files). 
            This is used if `default.latency` (or the *latency* argument 
            of `playrec()`, `Stream` etc.) is set to ``'high'``. 
        ``'default_samplerate'`` 
            The default sampling frequency of the device. 
            This is used if `default.samplerate` is not set. 
 
    Notes 
    ----- 
    The list of devices can also be displayed in a terminal: 
 
    .. code-block:: sh 
 
        python3 -m sounddevice 
 
    Examples 
    -------- 
    The returned `DeviceList` can be indexed and iterated over like any 
    sequence type (yielding the abovementioned dictionaries), but it 
    also has a special string representation which is shown when used in 
    an interactive Python session. 
 
    Each available device is listed on one line together with the 
    corresponding device ID, which can be assigned to `default.device` 
    or used as *device* argument in `play()`, `Stream` etc. 
 
    The first character of a line is ``&gt;`` for the default input device, 
    ``&lt;`` for the default output device and ``*`` for the default 
    input/output device.  After the device ID and the device name, the 
    corresponding host API name is displayed.  In the end of each line, 
    the maximum number of input and output channels is shown. 
 
    On a GNU/Linux computer it might look somewhat like this: 
 
    &gt;&gt;&gt; import sounddevice as sd 
    &gt;&gt;&gt; sd.query_devices() 
       0 HDA Intel: ALC662 rev1 Analog (hw:0,0), ALSA (2 in, 2 out) 
       1 HDA Intel: ALC662 rev1 Digital (hw:0,1), ALSA (0 in, 2 out) 
       2 HDA Intel: HDMI 0 (hw:0,3), ALSA (0 in, 8 out) 
       3 sysdefault, ALSA (128 in, 128 out) 
       4 front, ALSA (0 in, 2 out) 
       5 surround40, ALSA (0 in, 2 out) 
       6 surround51, ALSA (0 in, 2 out) 
       7 surround71, ALSA (0 in, 2 out) 
       8 iec958, ALSA (0 in, 2 out) 
       9 spdif, ALSA (0 in, 2 out) 
      10 hdmi, ALSA (0 in, 8 out) 
    * 11 default, ALSA (128 in, 128 out) 
      12 dmix, ALSA (0 in, 2 out) 
      13 /dev/dsp, OSS (16 in, 16 out) 
 
    Note that ALSA provides access to some &quot;real&quot; and some &quot;virtual&quot; 
    devices.  The latter sometimes have a ridiculously high number of 
    (virtual) inputs and outputs. 
 
    On macOS, you might get something similar to this: 
 
    &gt;&gt;&gt; sd.query_devices() 
      0 Built-in Line Input, Core Audio (2 in, 0 out) 
    &gt; 1 Built-in Digital Input, Core Audio (2 in, 0 out) 
    &lt; 2 Built-in Output, Core Audio (0 in, 2 out) 
      3 Built-in Line Output, Core Audio (0 in, 2 out) 
      4 Built-in Digital Output, Core Audio (0 in, 2 out) 
 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">kind </span><span class="s4">not in </span><span class="s1">(</span><span class="s3">'input'</span><span class="s4">, </span><span class="s3">'output'</span><span class="s4">, None</span><span class="s1">):</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">f'Invalid kind: </span><span class="s4">{</span><span class="s1">kind</span><span class="s4">!r}</span><span class="s3">'</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">device </span><span class="s4">is None and </span><span class="s1">kind </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">DeviceList(query_devices(i)</span>
                          <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(_check(_lib.Pa_GetDeviceCount())))</span>
    <span class="s1">device = _get_device_id(device</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">, </span><span class="s1">raise_on_error=</span><span class="s4">True</span><span class="s1">)</span>
    <span class="s1">info = _lib.Pa_GetDeviceInfo(device)</span>
    <span class="s4">if not </span><span class="s1">info:</span>
        <span class="s4">raise </span><span class="s1">PortAudioError(</span><span class="s3">f'Error querying device </span><span class="s4">{</span><span class="s1">device</span><span class="s4">}</span><span class="s3">'</span><span class="s1">)</span>
    <span class="s4">assert </span><span class="s1">info.structVersion == </span><span class="s5">2</span>
    <span class="s1">name_bytes = _ffi.string(info.name)</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s0"># We don't know beforehand if DirectSound and MME device names use</span>
        <span class="s0"># 'utf-8' or 'mbcs' encoding.  Let's try 'utf-8' first, because it more</span>
        <span class="s0"># likely raises an exception on 'mbcs' data than vice versa, see also</span>
        <span class="s0"># https://github.com/spatialaudio/python-sounddevice/issues/72.</span>
        <span class="s0"># All other host APIs use 'utf-8' anyway.</span>
        <span class="s1">name = name_bytes.decode(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
    <span class="s4">except </span><span class="s1">UnicodeDecodeError:</span>
        <span class="s4">if </span><span class="s1">info.hostApi </span><span class="s4">in </span><span class="s1">(</span>
                <span class="s1">_lib.Pa_HostApiTypeIdToHostApiIndex(_lib.paDirectSound)</span><span class="s4">,</span>
                <span class="s1">_lib.Pa_HostApiTypeIdToHostApiIndex(_lib.paMME)):</span>
            <span class="s1">name = name_bytes.decode(</span><span class="s3">'mbcs'</span><span class="s1">)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">raise</span>
    <span class="s1">device_dict = {</span>
        <span class="s3">'name'</span><span class="s1">: name</span><span class="s4">,</span>
        <span class="s3">'index'</span><span class="s1">: device</span><span class="s4">,</span>
        <span class="s3">'hostapi'</span><span class="s1">: info.hostApi</span><span class="s4">,</span>
        <span class="s3">'max_input_channels'</span><span class="s1">: info.maxInputChannels</span><span class="s4">,</span>
        <span class="s3">'max_output_channels'</span><span class="s1">: info.maxOutputChannels</span><span class="s4">,</span>
        <span class="s3">'default_low_input_latency'</span><span class="s1">: info.defaultLowInputLatency</span><span class="s4">,</span>
        <span class="s3">'default_low_output_latency'</span><span class="s1">: info.defaultLowOutputLatency</span><span class="s4">,</span>
        <span class="s3">'default_high_input_latency'</span><span class="s1">: info.defaultHighInputLatency</span><span class="s4">,</span>
        <span class="s3">'default_high_output_latency'</span><span class="s1">: info.defaultHighOutputLatency</span><span class="s4">,</span>
        <span class="s3">'default_samplerate'</span><span class="s1">: info.defaultSampleRate</span><span class="s4">,</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">kind </span><span class="s4">and </span><span class="s1">device_dict[</span><span class="s3">'max_' </span><span class="s1">+ kind + </span><span class="s3">'_channels'</span><span class="s1">] &lt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span>
            <span class="s3">'Not an {} device: {!r}'</span><span class="s1">.format(kind</span><span class="s4">, </span><span class="s1">device_dict[</span><span class="s3">'name'</span><span class="s1">]))</span>
    <span class="s4">return </span><span class="s1">device_dict</span>


<span class="s4">def </span><span class="s1">query_hostapis(index=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Return information about available host APIs. 
 
    Parameters 
    ---------- 
    index : int, optional 
        If specified, information about only the given host API *index* 
        is returned in a single dictionary. 
 
    Returns 
    ------- 
    dict or tuple of dict 
        A dictionary with information about the given host API *index* 
        or -- if no *index* was specified -- a tuple containing one 
        dictionary for each available host API. 
        The dictionaries have the following keys: 
 
        ``'name'`` 
            The name of the host API. 
        ``'devices'`` 
            A list of device IDs belonging to the host API. 
            Use `query_devices()` to get information about a device. 
        ``'default_input_device'``, ``'default_output_device'`` 
            The device ID of the default input/output device of the host 
            API.  If no default input/output device exists for the given 
            host API, this is -1. 
 
            .. note:: The overall default device(s) -- which can be 
                overwritten by assigning to `default.device` -- take(s) 
                precedence over `default.hostapi` and the information in 
                the abovementioned dictionaries. 
 
    See Also 
    -------- 
    query_devices 
 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">index </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">tuple(query_hostapis(i)</span>
                     <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(_check(_lib.Pa_GetHostApiCount())))</span>
    <span class="s1">info = _lib.Pa_GetHostApiInfo(index)</span>
    <span class="s4">if not </span><span class="s1">info:</span>
        <span class="s4">raise </span><span class="s1">PortAudioError(</span><span class="s3">f'Error querying host API </span><span class="s4">{</span><span class="s1">index</span><span class="s4">}</span><span class="s3">'</span><span class="s1">)</span>
    <span class="s4">assert </span><span class="s1">info.structVersion == </span><span class="s5">1</span>
    <span class="s4">return </span><span class="s1">{</span>
        <span class="s3">'name'</span><span class="s1">: _ffi.string(info.name).decode()</span><span class="s4">,</span>
        <span class="s3">'devices'</span><span class="s1">: [_lib.Pa_HostApiDeviceIndexToDeviceIndex(index</span><span class="s4">, </span><span class="s1">i)</span>
                    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(info.deviceCount)]</span><span class="s4">,</span>
        <span class="s3">'default_input_device'</span><span class="s1">: info.defaultInputDevice</span><span class="s4">,</span>
        <span class="s3">'default_output_device'</span><span class="s1">: info.defaultOutputDevice</span><span class="s4">,</span>
    <span class="s1">}</span>


<span class="s4">def </span><span class="s1">check_input_settings(device=</span><span class="s4">None, </span><span class="s1">channels=</span><span class="s4">None, </span><span class="s1">dtype=</span><span class="s4">None,</span>
                         <span class="s1">extra_settings=</span><span class="s4">None, </span><span class="s1">samplerate=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Check if given input device settings are supported. 
 
    All parameters are optional, `default` settings are used for any 
    unspecified parameters.  If the settings are supported, the function 
    does nothing; if not, an exception is raised. 
 
    Parameters 
    ---------- 
    device : int or str, optional 
        Device ID or device name substring(s), see `default.device`. 
    channels : int, optional 
        Number of input channels, see `default.channels`. 
    dtype : str or numpy.dtype, optional 
        Data type for input samples, see `default.dtype`. 
    extra_settings : settings object, optional 
        This can be used for host-API-specific input settings. 
        See `default.extra_settings`. 
    samplerate : float, optional 
        Sampling frequency, see `default.samplerate`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">parameters</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">samplesize</span><span class="s4">, </span><span class="s1">samplerate = _get_stream_parameters(</span>
        <span class="s3">'input'</span><span class="s4">, </span><span class="s1">device=device</span><span class="s4">, </span><span class="s1">channels=channels</span><span class="s4">, </span><span class="s1">dtype=dtype</span><span class="s4">, </span><span class="s1">latency=</span><span class="s4">None,</span>
        <span class="s1">extra_settings=extra_settings</span><span class="s4">, </span><span class="s1">samplerate=samplerate)</span>
    <span class="s1">_check(_lib.Pa_IsFormatSupported(parameters</span><span class="s4">, </span><span class="s1">_ffi.NULL</span><span class="s4">, </span><span class="s1">samplerate))</span>


<span class="s4">def </span><span class="s1">check_output_settings(device=</span><span class="s4">None, </span><span class="s1">channels=</span><span class="s4">None, </span><span class="s1">dtype=</span><span class="s4">None,</span>
                          <span class="s1">extra_settings=</span><span class="s4">None, </span><span class="s1">samplerate=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Check if given output device settings are supported. 
 
    Same as `check_input_settings()`, just for output device 
    settings. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">parameters</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">samplesize</span><span class="s4">, </span><span class="s1">samplerate = _get_stream_parameters(</span>
        <span class="s3">'output'</span><span class="s4">, </span><span class="s1">device=device</span><span class="s4">, </span><span class="s1">channels=channels</span><span class="s4">, </span><span class="s1">dtype=dtype</span><span class="s4">, </span><span class="s1">latency=</span><span class="s4">None,</span>
        <span class="s1">extra_settings=extra_settings</span><span class="s4">, </span><span class="s1">samplerate=samplerate)</span>
    <span class="s1">_check(_lib.Pa_IsFormatSupported(_ffi.NULL</span><span class="s4">, </span><span class="s1">parameters</span><span class="s4">, </span><span class="s1">samplerate))</span>


<span class="s4">def </span><span class="s1">sleep(msec):</span>
    <span class="s2">&quot;&quot;&quot;Put the caller to sleep for at least *msec* milliseconds. 
 
    The function may sleep longer than requested so don't rely on this 
    for accurate musical timing. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_lib.Pa_Sleep(msec)</span>


<span class="s4">def </span><span class="s1">get_portaudio_version():</span>
    <span class="s2">&quot;&quot;&quot;Get version information for the PortAudio library. 
 
    Returns the release number and a textual description of the current 
    PortAudio build, e.g. :: 
 
        (1899, 'PortAudio V19-devel (built Feb 15 2014 23:28:00)') 
 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">_lib.Pa_GetVersion()</span><span class="s4">, </span><span class="s1">_ffi.string(_lib.Pa_GetVersionText()).decode()</span>


<span class="s4">class </span><span class="s1">_StreamBase:</span>
    <span class="s2">&quot;&quot;&quot;Direct or indirect base class for all stream classes.&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">, </span><span class="s1">samplerate=</span><span class="s4">None, </span><span class="s1">blocksize=</span><span class="s4">None, </span><span class="s1">device=</span><span class="s4">None,</span>
                 <span class="s1">channels=</span><span class="s4">None, </span><span class="s1">dtype=</span><span class="s4">None, </span><span class="s1">latency=</span><span class="s4">None, </span><span class="s1">extra_settings=</span><span class="s4">None,</span>
                 <span class="s1">callback=</span><span class="s4">None, </span><span class="s1">finished_callback=</span><span class="s4">None, </span><span class="s1">clip_off=</span><span class="s4">None,</span>
                 <span class="s1">dither_off=</span><span class="s4">None, </span><span class="s1">never_drop_input=</span><span class="s4">None,</span>
                 <span class="s1">prime_output_buffers_using_stream_callback=</span><span class="s4">None,</span>
                 <span class="s1">userdata=</span><span class="s4">None, </span><span class="s1">wrap_callback=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Base class for PortAudio streams. 
 
        This class should only be used by library authors who want to 
        create their own custom stream classes. 
        Most users should use the derived classes 
        `Stream`, `InputStream`, `OutputStream`, 
        `RawStream`, `RawInputStream` and `RawOutputStream` instead. 
 
        This class has the same properties and methods as `Stream`, 
        except for `read_available`/:meth:`~Stream.read` and 
        `write_available`/:meth:`~Stream.write`. 
 
        It can be created with the same parameters as `Stream`, 
        except that there are three additional parameters 
        and the *callback* parameter also accepts a C function pointer. 
 
        Parameters 
        ---------- 
        kind : {'input', 'output', 'duplex'} 
            The desired type of stream: for recording, playback or both. 
        callback : Python callable or CData function pointer, optional 
            If *wrap_callback* is ``None`` this can be a function pointer 
            provided by CFFI. 
            Otherwise, it has to be a Python callable. 
        wrap_callback : {'array', 'buffer'}, optional 
            If *callback* is a Python callable, this selects whether 
            the audio data is provided as NumPy array (like in `Stream`) 
            or as Python buffer object (like in `RawStream`). 
        userdata : CData void pointer 
            This is passed to the underlying C callback function 
            on each call and can only be accessed from a *callback* 
            provided as ``CData`` function pointer. 
 
        Examples 
        -------- 
        A usage example of this class can be seen at 
        https://github.com/spatialaudio/python-rtmixer. 
 
        &quot;&quot;&quot;</span>
        <span class="s4">assert </span><span class="s1">kind </span><span class="s4">in </span><span class="s1">(</span><span class="s3">'input'</span><span class="s4">, </span><span class="s3">'output'</span><span class="s4">, </span><span class="s3">'duplex'</span><span class="s1">)</span>
        <span class="s4">assert </span><span class="s1">wrap_callback </span><span class="s4">in </span><span class="s1">(</span><span class="s3">'array'</span><span class="s4">, </span><span class="s3">'buffer'</span><span class="s4">, None</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">blocksize </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">blocksize = default.blocksize</span>
        <span class="s4">if </span><span class="s1">clip_off </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">clip_off = default.clip_off</span>
        <span class="s4">if </span><span class="s1">dither_off </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">dither_off = default.dither_off</span>
        <span class="s4">if </span><span class="s1">never_drop_input </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">never_drop_input = default.never_drop_input</span>
        <span class="s4">if </span><span class="s1">prime_output_buffers_using_stream_callback </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">prime_output_buffers_using_stream_callback = \</span>
                <span class="s1">default.prime_output_buffers_using_stream_callback</span>

        <span class="s1">stream_flags = _lib.paNoFlag</span>
        <span class="s4">if </span><span class="s1">clip_off:</span>
            <span class="s1">stream_flags |= _lib.paClipOff</span>
        <span class="s4">if </span><span class="s1">dither_off:</span>
            <span class="s1">stream_flags |= _lib.paDitherOff</span>
        <span class="s4">if </span><span class="s1">never_drop_input:</span>
            <span class="s1">stream_flags |= _lib.paNeverDropInput</span>
        <span class="s4">if </span><span class="s1">prime_output_buffers_using_stream_callback:</span>
            <span class="s1">stream_flags |= _lib.paPrimeOutputBuffersUsingStreamCallback</span>

        <span class="s4">if </span><span class="s1">kind == </span><span class="s3">'duplex'</span><span class="s1">:</span>
            <span class="s1">idevice</span><span class="s4">, </span><span class="s1">odevice = _split(device)</span>
            <span class="s1">ichannels</span><span class="s4">, </span><span class="s1">ochannels = _split(channels)</span>
            <span class="s1">idtype</span><span class="s4">, </span><span class="s1">odtype = _split(dtype)</span>
            <span class="s1">ilatency</span><span class="s4">, </span><span class="s1">olatency = _split(latency)</span>
            <span class="s1">iextra</span><span class="s4">, </span><span class="s1">oextra = _split(extra_settings)</span>
            <span class="s1">iparameters</span><span class="s4">, </span><span class="s1">idtype</span><span class="s4">, </span><span class="s1">isize</span><span class="s4">, </span><span class="s1">isamplerate = _get_stream_parameters(</span>
                <span class="s3">'input'</span><span class="s4">, </span><span class="s1">idevice</span><span class="s4">, </span><span class="s1">ichannels</span><span class="s4">, </span><span class="s1">idtype</span><span class="s4">, </span><span class="s1">ilatency</span><span class="s4">, </span><span class="s1">iextra</span><span class="s4">,</span>
                <span class="s1">samplerate)</span>
            <span class="s1">oparameters</span><span class="s4">, </span><span class="s1">odtype</span><span class="s4">, </span><span class="s1">osize</span><span class="s4">, </span><span class="s1">osamplerate = _get_stream_parameters(</span>
                <span class="s3">'output'</span><span class="s4">, </span><span class="s1">odevice</span><span class="s4">, </span><span class="s1">ochannels</span><span class="s4">, </span><span class="s1">odtype</span><span class="s4">, </span><span class="s1">olatency</span><span class="s4">, </span><span class="s1">oextra</span><span class="s4">,</span>
                <span class="s1">samplerate)</span>
            <span class="s1">self._dtype = idtype</span><span class="s4">, </span><span class="s1">odtype</span>
            <span class="s1">self._device = iparameters.device</span><span class="s4">, </span><span class="s1">oparameters.device</span>
            <span class="s1">self._channels = iparameters.channelCount</span><span class="s4">, </span><span class="s1">oparameters.channelCount</span>
            <span class="s1">self._samplesize = isize</span><span class="s4">, </span><span class="s1">osize</span>
            <span class="s4">if </span><span class="s1">isamplerate != osamplerate:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">'Input and output device must have the same samplerate'</span><span class="s1">)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">samplerate = isamplerate</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">parameters</span><span class="s4">, </span><span class="s1">self._dtype</span><span class="s4">, </span><span class="s1">self._samplesize</span><span class="s4">, </span><span class="s1">samplerate = \</span>
                <span class="s1">_get_stream_parameters(kind</span><span class="s4">, </span><span class="s1">device</span><span class="s4">, </span><span class="s1">channels</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">latency</span><span class="s4">,</span>
                                       <span class="s1">extra_settings</span><span class="s4">, </span><span class="s1">samplerate)</span>
            <span class="s1">self._device = parameters.device</span>
            <span class="s1">self._channels = parameters.channelCount</span>
            <span class="s4">if </span><span class="s1">kind == </span><span class="s3">'input'</span><span class="s1">:</span>
                <span class="s1">iparameters = parameters</span>
                <span class="s1">oparameters = _ffi.NULL</span>
            <span class="s4">elif </span><span class="s1">kind == </span><span class="s3">'output'</span><span class="s1">:</span>
                <span class="s1">iparameters = _ffi.NULL</span>
                <span class="s1">oparameters = parameters</span>

        <span class="s1">ffi_callback = _ffi.callback(</span><span class="s3">'PaStreamCallback'</span><span class="s4">, </span><span class="s1">error=_lib.paAbort)</span>

        <span class="s4">if </span><span class="s1">callback </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">callback_ptr = _ffi.NULL</span>
        <span class="s4">elif </span><span class="s1">kind == </span><span class="s3">'input' </span><span class="s4">and </span><span class="s1">wrap_callback == </span><span class="s3">'buffer'</span><span class="s1">:</span>

            <span class="s1">@ffi_callback</span>
            <span class="s4">def </span><span class="s1">callback_ptr(iptr</span><span class="s4">, </span><span class="s1">optr</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">status</span><span class="s4">, </span><span class="s1">_):</span>
                <span class="s1">data = _buffer(iptr</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">self._channels</span><span class="s4">, </span><span class="s1">self._samplesize)</span>
                <span class="s4">return </span><span class="s1">_wrap_callback(callback</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">status)</span>

        <span class="s4">elif </span><span class="s1">kind == </span><span class="s3">'input' </span><span class="s4">and </span><span class="s1">wrap_callback == </span><span class="s3">'array'</span><span class="s1">:</span>

            <span class="s1">@ffi_callback</span>
            <span class="s4">def </span><span class="s1">callback_ptr(iptr</span><span class="s4">, </span><span class="s1">optr</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">status</span><span class="s4">, </span><span class="s1">_):</span>
                <span class="s1">data = _array(</span>
                    <span class="s1">_buffer(iptr</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">self._channels</span><span class="s4">, </span><span class="s1">self._samplesize)</span><span class="s4">,</span>
                    <span class="s1">self._channels</span><span class="s4">, </span><span class="s1">self._dtype)</span>
                <span class="s4">return </span><span class="s1">_wrap_callback(callback</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">status)</span>

        <span class="s4">elif </span><span class="s1">kind == </span><span class="s3">'output' </span><span class="s4">and </span><span class="s1">wrap_callback == </span><span class="s3">'buffer'</span><span class="s1">:</span>

            <span class="s1">@ffi_callback</span>
            <span class="s4">def </span><span class="s1">callback_ptr(iptr</span><span class="s4">, </span><span class="s1">optr</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">status</span><span class="s4">, </span><span class="s1">_):</span>
                <span class="s1">data = _buffer(optr</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">self._channels</span><span class="s4">, </span><span class="s1">self._samplesize)</span>
                <span class="s4">return </span><span class="s1">_wrap_callback(callback</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">status)</span>

        <span class="s4">elif </span><span class="s1">kind == </span><span class="s3">'output' </span><span class="s4">and </span><span class="s1">wrap_callback == </span><span class="s3">'array'</span><span class="s1">:</span>

            <span class="s1">@ffi_callback</span>
            <span class="s4">def </span><span class="s1">callback_ptr(iptr</span><span class="s4">, </span><span class="s1">optr</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">status</span><span class="s4">, </span><span class="s1">_):</span>
                <span class="s1">data = _array(</span>
                    <span class="s1">_buffer(optr</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">self._channels</span><span class="s4">, </span><span class="s1">self._samplesize)</span><span class="s4">,</span>
                    <span class="s1">self._channels</span><span class="s4">, </span><span class="s1">self._dtype)</span>
                <span class="s4">return </span><span class="s1">_wrap_callback(callback</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">status)</span>

        <span class="s4">elif </span><span class="s1">kind == </span><span class="s3">'duplex' </span><span class="s4">and </span><span class="s1">wrap_callback == </span><span class="s3">'buffer'</span><span class="s1">:</span>

            <span class="s1">@ffi_callback</span>
            <span class="s4">def </span><span class="s1">callback_ptr(iptr</span><span class="s4">, </span><span class="s1">optr</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">status</span><span class="s4">, </span><span class="s1">_):</span>
                <span class="s1">ichannels</span><span class="s4">, </span><span class="s1">ochannels = self._channels</span>
                <span class="s1">isize</span><span class="s4">, </span><span class="s1">osize = self._samplesize</span>
                <span class="s1">idata = _buffer(iptr</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">ichannels</span><span class="s4">, </span><span class="s1">isize)</span>
                <span class="s1">odata = _buffer(optr</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">ochannels</span><span class="s4">, </span><span class="s1">osize)</span>
                <span class="s4">return </span><span class="s1">_wrap_callback(</span>
                    <span class="s1">callback</span><span class="s4">, </span><span class="s1">idata</span><span class="s4">, </span><span class="s1">odata</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">status)</span>

        <span class="s4">elif </span><span class="s1">kind == </span><span class="s3">'duplex' </span><span class="s4">and </span><span class="s1">wrap_callback == </span><span class="s3">'array'</span><span class="s1">:</span>

            <span class="s1">@ffi_callback</span>
            <span class="s4">def </span><span class="s1">callback_ptr(iptr</span><span class="s4">, </span><span class="s1">optr</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">status</span><span class="s4">, </span><span class="s1">_):</span>
                <span class="s1">ichannels</span><span class="s4">, </span><span class="s1">ochannels = self._channels</span>
                <span class="s1">idtype</span><span class="s4">, </span><span class="s1">odtype = self._dtype</span>
                <span class="s1">isize</span><span class="s4">, </span><span class="s1">osize = self._samplesize</span>
                <span class="s1">idata = _array(_buffer(iptr</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">ichannels</span><span class="s4">, </span><span class="s1">isize)</span><span class="s4">,</span>
                               <span class="s1">ichannels</span><span class="s4">, </span><span class="s1">idtype)</span>
                <span class="s1">odata = _array(_buffer(optr</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">ochannels</span><span class="s4">, </span><span class="s1">osize)</span><span class="s4">,</span>
                               <span class="s1">ochannels</span><span class="s4">, </span><span class="s1">odtype)</span>
                <span class="s4">return </span><span class="s1">_wrap_callback(</span>
                    <span class="s1">callback</span><span class="s4">, </span><span class="s1">idata</span><span class="s4">, </span><span class="s1">odata</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">status)</span>

        <span class="s4">else</span><span class="s1">:</span>
            <span class="s0"># Use cast() to allow CData from different FFI instance:</span>
            <span class="s1">callback_ptr = _ffi.cast(</span><span class="s3">'PaStreamCallback*'</span><span class="s4">, </span><span class="s1">callback)</span>

        <span class="s0"># CFFI callback object must be kept alive during stream lifetime:</span>
        <span class="s1">self._callback = callback_ptr</span>
        <span class="s4">if </span><span class="s1">userdata </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">userdata = _ffi.NULL</span>
        <span class="s1">self._ptr = _ffi.new(</span><span class="s3">'PaStream**'</span><span class="s1">)</span>
        <span class="s1">_check(_lib.Pa_OpenStream(self._ptr</span><span class="s4">, </span><span class="s1">iparameters</span><span class="s4">, </span><span class="s1">oparameters</span><span class="s4">,</span>
                                  <span class="s1">samplerate</span><span class="s4">, </span><span class="s1">blocksize</span><span class="s4">, </span><span class="s1">stream_flags</span><span class="s4">,</span>
                                  <span class="s1">callback_ptr</span><span class="s4">, </span><span class="s1">userdata)</span><span class="s4">,</span>
               <span class="s3">f'Error opening </span><span class="s4">{</span><span class="s1">self.__class__.__name__</span><span class="s4">}</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s0"># dereference PaStream** --&gt; PaStream*</span>
        <span class="s1">self._ptr = self._ptr[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">self._blocksize = blocksize</span>
        <span class="s1">info = _lib.Pa_GetStreamInfo(self._ptr)</span>
        <span class="s4">if not </span><span class="s1">info:</span>
            <span class="s4">raise </span><span class="s1">PortAudioError(</span><span class="s3">'Could not obtain stream info'</span><span class="s1">)</span>
        <span class="s0"># TODO: assert info.structVersion == 1</span>
        <span class="s1">self._samplerate = info.sampleRate</span>
        <span class="s4">if not </span><span class="s1">oparameters:</span>
            <span class="s1">self._latency = info.inputLatency</span>
        <span class="s4">elif not </span><span class="s1">iparameters:</span>
            <span class="s1">self._latency = info.outputLatency</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self._latency = info.inputLatency</span><span class="s4">, </span><span class="s1">info.outputLatency</span>

        <span class="s4">if </span><span class="s1">finished_callback:</span>
            <span class="s4">if </span><span class="s1">isinstance(finished_callback</span><span class="s4">, </span><span class="s1">_ffi.CData):</span>
                <span class="s1">self._finished_callback = finished_callback</span>
            <span class="s4">else</span><span class="s1">:</span>

                <span class="s4">def </span><span class="s1">finished_callback_wrapper(_):</span>
                    <span class="s4">return </span><span class="s1">finished_callback()</span>

                <span class="s0"># CFFI callback object is kept alive during stream lifetime:</span>
                <span class="s1">self._finished_callback = _ffi.callback(</span>
                    <span class="s3">'PaStreamFinishedCallback'</span><span class="s4">, </span><span class="s1">finished_callback_wrapper)</span>
            <span class="s1">_check(_lib.Pa_SetStreamFinishedCallback(self._ptr</span><span class="s4">,</span>
                                                     <span class="s1">self._finished_callback))</span>

    <span class="s0"># Avoid confusion if something goes wrong before assigning self._ptr:</span>
    <span class="s1">_ptr = _ffi.NULL</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">samplerate(self):</span>
        <span class="s2">&quot;&quot;&quot;The sampling frequency in Hertz (= frames per second). 
 
        In cases where the hardware sampling frequency is inaccurate and 
        PortAudio is aware of it, the value of this field may be 
        different from the *samplerate* parameter passed to `Stream()`. 
        If information about the actual hardware sampling frequency is 
        not available, this field will have the same value as the 
        *samplerate* parameter passed to `Stream()`. 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self._samplerate</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">blocksize(self):</span>
        <span class="s2">&quot;&quot;&quot;Number of frames per block. 
 
        The special value 0 means that the blocksize can change between 
        blocks.  See the *blocksize* argument of `Stream`. 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self._blocksize</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">device(self):</span>
        <span class="s2">&quot;&quot;&quot;IDs of the input/output device.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self._device</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">channels(self):</span>
        <span class="s2">&quot;&quot;&quot;The number of input/output channels.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self._channels</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">dtype(self):</span>
        <span class="s2">&quot;&quot;&quot;Data type of the audio samples. 
 
        See Also 
        -------- 
        default.dtype, samplesize 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self._dtype</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">samplesize(self):</span>
        <span class="s2">&quot;&quot;&quot;The size in bytes of a single sample. 
 
        See Also 
        -------- 
        dtype 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self._samplesize</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">latency(self):</span>
        <span class="s2">&quot;&quot;&quot;The input/output latency of the stream in seconds. 
 
        This value provides the most accurate estimate of input/output 
        latency available to the implementation. 
        It may differ significantly from the *latency* value(s) passed 
        to `Stream()`. 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self._latency</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">active(self):</span>
        <span class="s2">&quot;&quot;&quot;``True`` when the stream is active, ``False`` otherwise. 
 
        A stream is active after a successful call to `start()`, until 
        it becomes inactive either as a result of a call to `stop()` or 
        `abort()`, or as a result of an exception raised in the stream 
        callback.  In the latter case, the stream is considered inactive 
        after the last buffer has finished playing. 
 
        See Also 
        -------- 
        stopped 
 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self.closed:</span>
            <span class="s4">return False</span>
        <span class="s4">return </span><span class="s1">_check(_lib.Pa_IsStreamActive(self._ptr)) == </span><span class="s5">1</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">stopped(self):</span>
        <span class="s2">&quot;&quot;&quot;``True`` when the stream is stopped, ``False`` otherwise. 
 
        A stream is considered to be stopped prior to a successful call 
        to `start()` and after a successful call to `stop()` or 
        `abort()`.  If a stream callback is cancelled (by raising an 
        exception) the stream is *not* considered to be stopped. 
 
        See Also 
        -------- 
        active 
 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self.closed:</span>
            <span class="s4">return True</span>
        <span class="s4">return </span><span class="s1">_check(_lib.Pa_IsStreamStopped(self._ptr)) == </span><span class="s5">1</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">closed(self):</span>
        <span class="s2">&quot;&quot;&quot;``True`` after a call to `close()`, ``False`` otherwise.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self._ptr == _ffi.NULL</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">time(self):</span>
        <span class="s2">&quot;&quot;&quot;The current stream time in seconds. 
 
        This is according to the same clock used to generate the 
        timestamps passed with the *time* argument to the stream 
        callback (see the *callback* argument of `Stream`). 
        The time values are monotonically increasing and have 
        unspecified origin. 
 
        This provides valid time values for the entire life of the 
        stream, from when the stream is opened until it is closed. 
        Starting and stopping the stream does not affect the passage of 
        time as provided here. 
 
        This time may be used for synchronizing other events to the 
        audio stream, for example synchronizing audio to MIDI. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">time = _lib.Pa_GetStreamTime(self._ptr)</span>
        <span class="s4">if not </span><span class="s1">time:</span>
            <span class="s4">raise </span><span class="s1">PortAudioError(</span><span class="s3">'Error getting stream time'</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">time</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">cpu_load(self):</span>
        <span class="s2">&quot;&quot;&quot;CPU usage information for the stream. 
 
        The &quot;CPU Load&quot; is a fraction of total CPU time consumed by a 
        callback stream's audio processing routines including, but not 
        limited to the client supplied stream callback. This function 
        does not work with blocking read/write streams. 
 
        This may be used in the stream callback function or in the 
        application. 
        It provides a floating point value, typically between 0.0 and 
        1.0, where 1.0 indicates that the stream callback is consuming 
        the maximum number of CPU cycles possible to maintain real-time 
        operation.  A value of 0.5 would imply that PortAudio and the 
        stream callback was consuming roughly 50% of the available CPU 
        time.  The value may exceed 1.0.  A value of 0.0 will always be 
        returned for a blocking read/write stream, or if an error 
        occurs. 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">_lib.Pa_GetStreamCpuLoad(self._ptr)</span>

    <span class="s4">def </span><span class="s1">__enter__(self):</span>
        <span class="s2">&quot;&quot;&quot;Start  the stream in the beginning of a &quot;with&quot; statement.&quot;&quot;&quot;</span>
        <span class="s1">self.start()</span>
        <span class="s4">return </span><span class="s1">self</span>

    <span class="s4">def </span><span class="s1">__exit__(self</span><span class="s4">, </span><span class="s1">*args):</span>
        <span class="s2">&quot;&quot;&quot;Stop and close the stream when exiting a &quot;with&quot; statement.&quot;&quot;&quot;</span>
        <span class="s1">self.stop()</span>
        <span class="s1">self.close()</span>

    <span class="s4">def </span><span class="s1">start(self):</span>
        <span class="s2">&quot;&quot;&quot;Commence audio processing. 
 
        See Also 
        -------- 
        stop, abort 
 
        &quot;&quot;&quot;</span>
        <span class="s1">err = _lib.Pa_StartStream(self._ptr)</span>
        <span class="s4">if </span><span class="s1">err != _lib.paStreamIsNotStopped:</span>
            <span class="s1">_check(err</span><span class="s4">, </span><span class="s3">'Error starting stream'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">stop(self</span><span class="s4">, </span><span class="s1">ignore_errors=</span><span class="s4">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Terminate audio processing. 
 
        This waits until all pending audio buffers have been played 
        before it returns. 
 
        See Also 
        -------- 
        start, abort 
 
        &quot;&quot;&quot;</span>
        <span class="s1">err = _lib.Pa_StopStream(self._ptr)</span>
        <span class="s4">if not </span><span class="s1">ignore_errors:</span>
            <span class="s1">_check(err</span><span class="s4">, </span><span class="s3">'Error stopping stream'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">abort(self</span><span class="s4">, </span><span class="s1">ignore_errors=</span><span class="s4">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Terminate audio processing immediately. 
 
        This does not wait for pending buffers to complete. 
 
        See Also 
        -------- 
        start, stop 
 
        &quot;&quot;&quot;</span>
        <span class="s1">err = _lib.Pa_AbortStream(self._ptr)</span>
        <span class="s4">if not </span><span class="s1">ignore_errors:</span>
            <span class="s1">_check(err</span><span class="s4">, </span><span class="s3">'Error aborting stream'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">close(self</span><span class="s4">, </span><span class="s1">ignore_errors=</span><span class="s4">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Close the stream. 
 
        If the audio stream is active any pending buffers are discarded 
        as if `abort()` had been called. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">err = _lib.Pa_CloseStream(self._ptr)</span>
        <span class="s1">self._ptr = _ffi.NULL</span>
        <span class="s4">if not </span><span class="s1">ignore_errors:</span>
            <span class="s1">_check(err</span><span class="s4">, </span><span class="s3">'Error closing stream'</span><span class="s1">)</span>


<span class="s4">class </span><span class="s1">RawInputStream(_StreamBase):</span>
    <span class="s2">&quot;&quot;&quot;Raw stream for recording only.  See __init__() and RawStream.&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">samplerate=</span><span class="s4">None, </span><span class="s1">blocksize=</span><span class="s4">None,</span>
                 <span class="s1">device=</span><span class="s4">None, </span><span class="s1">channels=</span><span class="s4">None, </span><span class="s1">dtype=</span><span class="s4">None, </span><span class="s1">latency=</span><span class="s4">None,</span>
                 <span class="s1">extra_settings=</span><span class="s4">None, </span><span class="s1">callback=</span><span class="s4">None, </span><span class="s1">finished_callback=</span><span class="s4">None,</span>
                 <span class="s1">clip_off=</span><span class="s4">None, </span><span class="s1">dither_off=</span><span class="s4">None, </span><span class="s1">never_drop_input=</span><span class="s4">None,</span>
                 <span class="s1">prime_output_buffers_using_stream_callback=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;PortAudio input stream (using buffer objects). 
 
        This is the same as `InputStream`, except that the *callback* 
        function and :meth:`~RawStream.read` work on plain Python buffer 
        objects instead of on NumPy arrays. 
        NumPy is not necessary for using this. 
 
        Parameters 
        ---------- 
        dtype : str 
            See `RawStream`. 
        callback : callable 
            User-supplied function to consume audio data in response to 
            requests from an active stream. 
            The callback must have this signature:: 
 
                callback(indata: buffer, frames: int, 
                         time: CData, status: CallbackFlags) -&gt; None 
 
            The arguments are the same as in the *callback* parameter of 
            `RawStream`, except that *outdata* is missing. 
 
        See Also 
        -------- 
        RawStream, Stream 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_StreamBase.__init__(self</span><span class="s4">, </span><span class="s1">kind=</span><span class="s3">'input'</span><span class="s4">, </span><span class="s1">wrap_callback=</span><span class="s3">'buffer'</span><span class="s4">,</span>
                             <span class="s1">**_remove_self(locals()))</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">read_available(self):</span>
        <span class="s2">&quot;&quot;&quot;The number of frames that can be read without waiting. 
 
        Returns a value representing the maximum number of frames that 
        can be read from the stream without blocking or busy waiting. 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">_check(_lib.Pa_GetStreamReadAvailable(self._ptr))</span>

    <span class="s4">def </span><span class="s1">read(self</span><span class="s4">, </span><span class="s1">frames):</span>
        <span class="s2">&quot;&quot;&quot;Read samples from the stream into a buffer. 
 
        This is the same as `Stream.read()`, except that it returns 
        a plain Python buffer object instead of a NumPy array. 
        NumPy is not necessary for using this. 
 
        Parameters 
        ---------- 
        frames : int 
            The number of frames to be read.  See `Stream.read()`. 
 
        Returns 
        ------- 
        data : buffer 
            A buffer of interleaved samples. The buffer contains 
            samples in the format specified by the *dtype* parameter 
            used to open the stream, and the number of channels 
            specified by *channels*. 
            See also `samplesize`. 
        overflowed : bool 
            See `Stream.read()`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">channels</span><span class="s4">, </span><span class="s1">_ = _split(self._channels)</span>
        <span class="s1">samplesize</span><span class="s4">, </span><span class="s1">_ = _split(self._samplesize)</span>
        <span class="s1">data = _ffi.new(</span><span class="s3">'signed char[]'</span><span class="s4">, </span><span class="s1">channels * samplesize * frames)</span>
        <span class="s1">err = _lib.Pa_ReadStream(self._ptr</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">frames)</span>
        <span class="s4">if </span><span class="s1">err == _lib.paInputOverflowed:</span>
            <span class="s1">overflowed = </span><span class="s4">True</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">_check(err)</span>
            <span class="s1">overflowed = </span><span class="s4">False</span>
        <span class="s4">return </span><span class="s1">_ffi.buffer(data)</span><span class="s4">, </span><span class="s1">overflowed</span>


<span class="s4">class </span><span class="s1">RawOutputStream(_StreamBase):</span>
    <span class="s2">&quot;&quot;&quot;Raw stream for playback only.  See __init__() and RawStream.&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">samplerate=</span><span class="s4">None, </span><span class="s1">blocksize=</span><span class="s4">None,</span>
                 <span class="s1">device=</span><span class="s4">None, </span><span class="s1">channels=</span><span class="s4">None, </span><span class="s1">dtype=</span><span class="s4">None, </span><span class="s1">latency=</span><span class="s4">None,</span>
                 <span class="s1">extra_settings=</span><span class="s4">None, </span><span class="s1">callback=</span><span class="s4">None, </span><span class="s1">finished_callback=</span><span class="s4">None,</span>
                 <span class="s1">clip_off=</span><span class="s4">None, </span><span class="s1">dither_off=</span><span class="s4">None, </span><span class="s1">never_drop_input=</span><span class="s4">None,</span>
                 <span class="s1">prime_output_buffers_using_stream_callback=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;PortAudio output stream (using buffer objects). 
 
        This is the same as `OutputStream`, except that the *callback* 
        function and :meth:`~RawStream.write` work on plain Python 
        buffer objects instead of on NumPy arrays. 
        NumPy is not necessary for using this. 
 
        Parameters 
        ---------- 
        dtype : str 
            See `RawStream`. 
        callback : callable 
            User-supplied function to generate audio data in response to 
            requests from an active stream. 
            The callback must have this signature:: 
 
                callback(outdata: buffer, frames: int, 
                         time: CData, status: CallbackFlags) -&gt; None 
 
            The arguments are the same as in the *callback* parameter of 
            `RawStream`, except that *indata* is missing. 
 
        See Also 
        -------- 
        RawStream, Stream 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_StreamBase.__init__(self</span><span class="s4">, </span><span class="s1">kind=</span><span class="s3">'output'</span><span class="s4">, </span><span class="s1">wrap_callback=</span><span class="s3">'buffer'</span><span class="s4">,</span>
                             <span class="s1">**_remove_self(locals()))</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">write_available(self):</span>
        <span class="s2">&quot;&quot;&quot;The number of frames that can be written without waiting. 
 
        Returns a value representing the maximum number of frames that 
        can be written to the stream without blocking or busy waiting. 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">_check(_lib.Pa_GetStreamWriteAvailable(self._ptr))</span>

    <span class="s4">def </span><span class="s1">write(self</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s2">&quot;&quot;&quot;Write samples to the stream. 
 
        This is the same as `Stream.write()`, except that it expects 
        a plain Python buffer object instead of a NumPy array. 
        NumPy is not necessary for using this. 
 
        Parameters 
        ---------- 
        data : buffer or bytes or iterable of int 
            A buffer of interleaved samples.  The buffer contains 
            samples in the format specified by the *dtype* argument used 
            to open the stream, and the number of channels specified by 
            *channels*.  The length of the buffer is not constrained to 
            a specific range, however high performance applications will 
            want to match this parameter to the *blocksize* parameter 
            used when opening the stream.  See also `samplesize`. 
 
        Returns 
        ------- 
        underflowed : bool 
            See `Stream.write()`. 
 
        &quot;&quot;&quot;</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">data = _ffi.from_buffer(data)</span>
        <span class="s4">except </span><span class="s1">AttributeError:</span>
            <span class="s4">pass  </span><span class="s0"># from_buffer() not supported</span>
        <span class="s4">except </span><span class="s1">TypeError:</span>
            <span class="s4">pass  </span><span class="s0"># input is not a buffer</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">samplesize = _split(self._samplesize)</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">channels = _split(self._channels)</span>
        <span class="s1">samples</span><span class="s4">, </span><span class="s1">remainder = divmod(len(data)</span><span class="s4">, </span><span class="s1">samplesize)</span>
        <span class="s4">if </span><span class="s1">remainder:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'len(data) not divisible by samplesize'</span><span class="s1">)</span>
        <span class="s1">frames</span><span class="s4">, </span><span class="s1">remainder = divmod(samples</span><span class="s4">, </span><span class="s1">channels)</span>
        <span class="s4">if </span><span class="s1">remainder:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Number of samples not divisible by channels'</span><span class="s1">)</span>
        <span class="s1">err = _lib.Pa_WriteStream(self._ptr</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">frames)</span>
        <span class="s4">if </span><span class="s1">err == _lib.paOutputUnderflowed:</span>
            <span class="s1">underflowed = </span><span class="s4">True</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">_check(err)</span>
            <span class="s1">underflowed = </span><span class="s4">False</span>
        <span class="s4">return </span><span class="s1">underflowed</span>


<span class="s4">class </span><span class="s1">RawStream(RawInputStream</span><span class="s4">, </span><span class="s1">RawOutputStream):</span>
    <span class="s2">&quot;&quot;&quot;Raw stream for playback and recording.  See __init__().&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">samplerate=</span><span class="s4">None, </span><span class="s1">blocksize=</span><span class="s4">None,</span>
                 <span class="s1">device=</span><span class="s4">None, </span><span class="s1">channels=</span><span class="s4">None, </span><span class="s1">dtype=</span><span class="s4">None, </span><span class="s1">latency=</span><span class="s4">None,</span>
                 <span class="s1">extra_settings=</span><span class="s4">None, </span><span class="s1">callback=</span><span class="s4">None, </span><span class="s1">finished_callback=</span><span class="s4">None,</span>
                 <span class="s1">clip_off=</span><span class="s4">None, </span><span class="s1">dither_off=</span><span class="s4">None, </span><span class="s1">never_drop_input=</span><span class="s4">None,</span>
                 <span class="s1">prime_output_buffers_using_stream_callback=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;PortAudio input/output stream (using buffer objects). 
 
        This is the same as `Stream`, except that the *callback* 
        function and `read()`/`write()` work on plain Python buffer 
        objects instead of on NumPy arrays. 
        NumPy is not necessary for using this. 
 
        To open a &quot;raw&quot; input-only or output-only stream use 
        `RawInputStream` or `RawOutputStream`, respectively. 
        If you want to handle audio data as NumPy arrays instead of 
        buffer objects, use `Stream`, `InputStream` or `OutputStream`. 
 
        Parameters 
        ---------- 
        dtype : str or pair of str 
            The sample format of the buffers provided to the stream 
            callback, `read()` or `write()`. 
            In addition to the formats supported by `Stream` 
            (``'float32'``, ``'int32'``, ``'int16'``, ``'int8'``, 
            ``'uint8'``), this also supports ``'int24'``, i.e. 
            packed 24 bit format. 
            The default value can be changed with `default.dtype`. 
            See also `samplesize`. 
        callback : callable 
            User-supplied function to consume, process or generate audio 
            data in response to requests from an active stream. 
            The callback must have this signature:: 
 
                callback(indata: buffer, outdata: buffer, frames: int, 
                         time: CData, status: CallbackFlags) -&gt; None 
 
            The arguments are the same as in the *callback* parameter of 
            `Stream`, except that *indata* and *outdata* are plain 
            Python buffer objects instead of NumPy arrays. 
 
        See Also 
        -------- 
        RawInputStream, RawOutputStream, Stream 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_StreamBase.__init__(self</span><span class="s4">, </span><span class="s1">kind=</span><span class="s3">'duplex'</span><span class="s4">, </span><span class="s1">wrap_callback=</span><span class="s3">'buffer'</span><span class="s4">,</span>
                             <span class="s1">**_remove_self(locals()))</span>


<span class="s4">class </span><span class="s1">InputStream(RawInputStream):</span>
    <span class="s2">&quot;&quot;&quot;Stream for input only.  See __init__() and Stream.&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">samplerate=</span><span class="s4">None, </span><span class="s1">blocksize=</span><span class="s4">None,</span>
                 <span class="s1">device=</span><span class="s4">None, </span><span class="s1">channels=</span><span class="s4">None, </span><span class="s1">dtype=</span><span class="s4">None, </span><span class="s1">latency=</span><span class="s4">None,</span>
                 <span class="s1">extra_settings=</span><span class="s4">None, </span><span class="s1">callback=</span><span class="s4">None, </span><span class="s1">finished_callback=</span><span class="s4">None,</span>
                 <span class="s1">clip_off=</span><span class="s4">None, </span><span class="s1">dither_off=</span><span class="s4">None, </span><span class="s1">never_drop_input=</span><span class="s4">None,</span>
                 <span class="s1">prime_output_buffers_using_stream_callback=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;PortAudio input stream (using NumPy). 
 
        This has the same methods and attributes as `Stream`, except 
        :meth:`~Stream.write` and `write_available`. 
        Furthermore, the stream callback is expected to have a different 
        signature (see below). 
 
        Parameters 
        ---------- 
        callback : callable 
            User-supplied function to consume audio in response to 
            requests from an active stream. 
            The callback must have this signature:: 
 
                callback(indata: numpy.ndarray, frames: int, 
                         time: CData, status: CallbackFlags) -&gt; None 
 
            The arguments are the same as in the *callback* parameter of 
            `Stream`, except that *outdata* is missing. 
 
        See Also 
        -------- 
        Stream, RawInputStream 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_StreamBase.__init__(self</span><span class="s4">, </span><span class="s1">kind=</span><span class="s3">'input'</span><span class="s4">, </span><span class="s1">wrap_callback=</span><span class="s3">'array'</span><span class="s4">,</span>
                             <span class="s1">**_remove_self(locals()))</span>

    <span class="s4">def </span><span class="s1">read(self</span><span class="s4">, </span><span class="s1">frames):</span>
        <span class="s2">&quot;&quot;&quot;Read samples from the stream into a NumPy array. 
 
        The function doesn't return until all requested *frames* have 
        been read -- this may involve waiting for the operating system 
        to supply the data (except if no more than `read_available` 
        frames were requested). 
 
        This is the same as `RawStream.read()`, except that it 
        returns a NumPy array instead of a plain Python buffer object. 
 
        Parameters 
        ---------- 
        frames : int 
            The number of frames to be read.  This parameter is not 
            constrained to a specific range, however high performance 
            applications will want to match this parameter to the 
            *blocksize* parameter used when opening the stream. 
 
        Returns 
        ------- 
        data : numpy.ndarray 
            A two-dimensional `numpy.ndarray` with one column per 
            channel (i.e.  with a shape of ``(frames, channels)``) and 
            with a data type specified by `dtype`. 
        overflowed : bool 
            ``True`` if input data was discarded by PortAudio after the 
            previous call and before this call. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">dtype</span><span class="s4">, </span><span class="s1">_ = _split(self._dtype)</span>
        <span class="s1">channels</span><span class="s4">, </span><span class="s1">_ = _split(self._channels)</span>
        <span class="s1">data</span><span class="s4">, </span><span class="s1">overflowed = RawInputStream.read(self</span><span class="s4">, </span><span class="s1">frames)</span>
        <span class="s1">data = _array(data</span><span class="s4">, </span><span class="s1">channels</span><span class="s4">, </span><span class="s1">dtype)</span>
        <span class="s4">return </span><span class="s1">data</span><span class="s4">, </span><span class="s1">overflowed</span>


<span class="s4">class </span><span class="s1">OutputStream(RawOutputStream):</span>
    <span class="s2">&quot;&quot;&quot;Stream for output only.  See __init__() and Stream.&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">samplerate=</span><span class="s4">None, </span><span class="s1">blocksize=</span><span class="s4">None,</span>
                 <span class="s1">device=</span><span class="s4">None, </span><span class="s1">channels=</span><span class="s4">None, </span><span class="s1">dtype=</span><span class="s4">None, </span><span class="s1">latency=</span><span class="s4">None,</span>
                 <span class="s1">extra_settings=</span><span class="s4">None, </span><span class="s1">callback=</span><span class="s4">None, </span><span class="s1">finished_callback=</span><span class="s4">None,</span>
                 <span class="s1">clip_off=</span><span class="s4">None, </span><span class="s1">dither_off=</span><span class="s4">None, </span><span class="s1">never_drop_input=</span><span class="s4">None,</span>
                 <span class="s1">prime_output_buffers_using_stream_callback=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;PortAudio output stream (using NumPy). 
 
        This has the same methods and attributes as `Stream`, except 
        :meth:`~Stream.read` and `read_available`. 
        Furthermore, the stream callback is expected to have a different 
        signature (see below). 
 
        Parameters 
        ---------- 
        callback : callable 
            User-supplied function to generate audio data in response to 
            requests from an active stream. 
            The callback must have this signature:: 
 
                callback(outdata: numpy.ndarray, frames: int, 
                         time: CData, status: CallbackFlags) -&gt; None 
 
            The arguments are the same as in the *callback* parameter of 
            `Stream`, except that *indata* is missing. 
 
        See Also 
        -------- 
        Stream, RawOutputStream 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_StreamBase.__init__(self</span><span class="s4">, </span><span class="s1">kind=</span><span class="s3">'output'</span><span class="s4">, </span><span class="s1">wrap_callback=</span><span class="s3">'array'</span><span class="s4">,</span>
                             <span class="s1">**_remove_self(locals()))</span>

    <span class="s4">def </span><span class="s1">write(self</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s2">&quot;&quot;&quot;Write samples to the stream. 
 
        This function doesn't return until the entire buffer has been 
        consumed -- this may involve waiting for the operating system to 
        consume the data (except if *data* contains no more than 
        `write_available` frames). 
 
        This is the same as `RawStream.write()`, except that it 
        expects a NumPy array instead of a plain Python buffer object. 
 
        Parameters 
        ---------- 
        data : array_like 
            A two-dimensional array-like object with one column per 
            channel (i.e.  with a shape of ``(frames, channels)``) and 
            with a data type specified by `dtype`.  A one-dimensional 
            array can be used for mono data.  The array layout must be 
            C-contiguous (see :func:`numpy.ascontiguousarray`). 
 
            The length of the buffer is not constrained to a specific 
            range, however high performance applications will want to 
            match this parameter to the *blocksize* parameter used when 
            opening the stream. 
 
        Returns 
        ------- 
        underflowed : bool 
            ``True`` if additional output data was inserted after the 
            previous call and before this call. 
 
        &quot;&quot;&quot;</span>
        <span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>
        <span class="s1">data = np.asarray(data)</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">dtype = _split(self._dtype)</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">channels = _split(self._channels)</span>
        <span class="s4">if </span><span class="s1">data.ndim &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">data = data.reshape(-</span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s4">elif </span><span class="s1">data.ndim &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'data must be one- or two-dimensional'</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">data.shape[</span><span class="s5">1</span><span class="s1">] != channels:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'number of channels must match'</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">data.dtype != dtype:</span>
            <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'dtype mismatch: {!r} vs {!r}'</span><span class="s1">.format(</span>
                <span class="s1">data.dtype.name</span><span class="s4">, </span><span class="s1">dtype))</span>
        <span class="s4">if not </span><span class="s1">data.flags.c_contiguous:</span>
            <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'data must be C-contiguous'</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">RawOutputStream.write(self</span><span class="s4">, </span><span class="s1">data)</span>


<span class="s4">class </span><span class="s1">Stream(InputStream</span><span class="s4">, </span><span class="s1">OutputStream):</span>
    <span class="s2">&quot;&quot;&quot;Stream for input and output.  See __init__().&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">samplerate=</span><span class="s4">None, </span><span class="s1">blocksize=</span><span class="s4">None,</span>
                 <span class="s1">device=</span><span class="s4">None, </span><span class="s1">channels=</span><span class="s4">None, </span><span class="s1">dtype=</span><span class="s4">None, </span><span class="s1">latency=</span><span class="s4">None,</span>
                 <span class="s1">extra_settings=</span><span class="s4">None, </span><span class="s1">callback=</span><span class="s4">None, </span><span class="s1">finished_callback=</span><span class="s4">None,</span>
                 <span class="s1">clip_off=</span><span class="s4">None, </span><span class="s1">dither_off=</span><span class="s4">None, </span><span class="s1">never_drop_input=</span><span class="s4">None,</span>
                 <span class="s1">prime_output_buffers_using_stream_callback=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;PortAudio stream for simultaneous input and output (using NumPy). 
 
        To open an input-only or output-only stream use `InputStream` or 
        `OutputStream`, respectively.  If you want to handle audio data 
        as plain buffer objects instead of NumPy arrays, use 
        `RawStream`, `RawInputStream` or `RawOutputStream`. 
 
        A single stream can provide multiple channels of real-time 
        streaming audio input and output to a client application.  A 
        stream provides access to audio hardware represented by one or 
        more devices.  Depending on the underlying host API, it may be 
        possible to open multiple streams using the same device, however 
        this behavior is implementation defined.  Portable applications 
        should assume that a device may be simultaneously used by at 
        most one stream. 
 
        The arguments *device*, *channels*, *dtype* and *latency* can be 
        either single values (which will be used for both input and 
        output parameters) or pairs of values (where the first one is 
        the value for the input and the second one for the output). 
 
        All arguments are optional, the values for unspecified 
        parameters are taken from the `default` object. 
        If one of the values of a parameter pair is ``None``, the 
        corresponding value from `default` will be used instead. 
 
        The created stream is inactive (see `active`, `stopped`). 
        It can be started with `start()`. 
 
        Every stream object is also a 
        :ref:`context manager &lt;python:context-managers&gt;`, i.e. it can be 
        used in a :ref:`with statement &lt;python:with&gt;` to automatically 
        call `start()` in the beginning of the statement and `stop()` 
        and `close()` on exit. 
 
        Parameters 
        ---------- 
        samplerate : float, optional 
            The desired sampling frequency (for both input and output). 
            The default value can be changed with `default.samplerate`. 
        blocksize : int, optional 
            The number of frames passed to the stream callback function, 
            or the preferred block granularity for a blocking read/write 
            stream. 
            The special value ``blocksize=0`` (which is the default) may 
            be used to request that the stream callback will receive an 
            optimal (and possibly varying) number of frames based on 
            host requirements and the requested latency settings. 
            The default value can be changed with `default.blocksize`. 
 
            .. note:: With some host APIs, the use of non-zero 
               *blocksize* for a callback stream may introduce an 
               additional layer of buffering which could introduce 
               additional latency.  PortAudio guarantees that the 
               additional latency will be kept to the theoretical 
               minimum however, it is strongly recommended that a 
               non-zero *blocksize* value only be used when your 
               algorithm requires a fixed number of frames per stream 
               callback. 
        device : int or str or pair thereof, optional 
            Device index(es) or query string(s) specifying the device(s) 
            to be used.  The default value(s) can be changed with 
            `default.device`. 
            If a string is given, the device is selected which contains 
            all space-separated parts in the right order.  Each device 
            string contains the name of the corresponding host API in 
            the end.  The string comparison is case-insensitive. 
        channels : int or pair of int, optional 
            The number of channels of sound to be delivered to the 
            stream callback or accessed by `read()` or `write()`.  It 
            can range from 1 to the value of ``'max_input_channels'`` or 
            ``'max_output_channels'`` in the dict returned by 
            `query_devices()`.  By default, the maximum possible number 
            of channels for the selected device is used (which may not 
            be what you want; see `query_devices()`).  The default 
            value(s) can be changed with `default.channels`. 
        dtype : str or numpy.dtype or pair thereof, optional 
            The sample format of the `numpy.ndarray` provided to the 
            stream callback, `read()` or `write()`. 
            It may be any of *float32*, *int32*, *int16*, *int8*, 
            *uint8*. See `numpy.dtype`. 
            The *float64* data type is not supported, this is only 
            supported for convenience in `play()`/`rec()`/`playrec()`. 
            The packed 24 bit format ``'int24'`` is only supported in 
            the &quot;raw&quot; stream classes, see `RawStream`.  The default 
            value(s) can be changed with `default.dtype`. 
            If NumPy is available, the corresponding `numpy.dtype` 
            objects can be used as well.  The floating point 
            representations ``'float32'`` and ``'float64'`` use ``+1.0`` 
            and ``-1.0`` as the maximum and minimum values, 
            respectively.  ``'uint8'`` is an unsigned 8 bit format where 
            ``128`` is considered &quot;ground&quot;. 
        latency : float or {'low', 'high'} or pair thereof, optional 
            The desired latency in seconds.  The special values 
            ``'low'`` and ``'high'`` (latter being the default) select 
            the device's default low and high latency, respectively (see 
            `query_devices()`).  ``'high'`` is typically more robust 
            (i.e. buffer under-/overflows are less likely), 
            but the latency may be too large for interactive applications. 
 
            .. note:: Specifying the desired latency as ``'high'`` does 
                not *guarantee* a stable audio stream. For reference, by 
                default Audacity_ specifies a desired latency of ``0.1`` 
                seconds and typically achieves robust performance. 
 
            .. _Audacity: https://www.audacityteam.org/ 
 
            The default value(s) can be changed with `default.latency`. 
            Actual latency values for an open stream can be retrieved 
            using the `latency` attribute. 
        extra_settings : settings object or pair thereof, optional 
            This can be used for host-API-specific input/output 
            settings.  See `default.extra_settings`. 
        callback : callable, optional 
            User-supplied function to consume, process or generate audio 
            data in response to requests from an `active` stream. 
            When a stream is running, PortAudio calls the stream 
            callback periodically.  The callback function is responsible 
            for processing and filling input and output buffers, 
            respectively. 
 
            If no *callback* is given, the stream will be opened in 
            &quot;blocking read/write&quot; mode.  In blocking mode, the client 
            can receive sample data using `read()` and write sample 
            data using `write()`, the number of frames that may be 
            read or written without blocking is returned by 
            `read_available` and `write_available`, respectively. 
 
            The callback must have this signature:: 
 
                callback(indata: ndarray, outdata: ndarray, frames: int, 
                         time: CData, status: CallbackFlags) -&gt; None 
 
            The first and second argument are the input and output 
            buffer, respectively, as two-dimensional `numpy.ndarray` 
            with one column per channel (i.e.  with a shape of 
            ``(frames, channels)``) and with a data type specified by 
            `dtype`. 
            The output buffer contains uninitialized data and the 
            *callback* is supposed to fill it with proper audio data. 
            If no data is available, the buffer should be filled with 
            zeros (e.g. by using ``outdata.fill(0)``). 
 
            .. note:: In Python, assigning to an identifier merely 
               re-binds the identifier to another object, so this *will 
               not work* as expected:: 
 
                   outdata = my_data  # Don't do this! 
 
               To actually assign data to the buffer itself, you can use 
               indexing, e.g.:: 
 
                   outdata[:] = my_data 
 
               ... which fills the whole buffer, or:: 
 
                   outdata[:, 1] = my_channel_data 
 
               ... which only fills one channel. 
 
            The third argument holds the number of frames to be 
            processed by the stream callback.  This is the same as the 
            length of the input and output buffers. 
 
            The forth argument provides a CFFI structure with 
            timestamps indicating the ADC capture time of the first 
            sample in the input buffer (``time.inputBufferAdcTime``), 
            the DAC output time of the first sample in the output buffer 
            (``time.outputBufferDacTime``) and the time the callback was 
            invoked (``time.currentTime``). 
            These time values are expressed in seconds and are 
            synchronised with the time base used by `time` for the 
            associated stream. 
 
            The fifth argument is a `CallbackFlags` instance indicating 
            whether input and/or output buffers have been inserted or 
            will be dropped to overcome underflow or overflow 
            conditions. 
 
            If an exception is raised in the *callback*, it will not be 
            called again.  If `CallbackAbort` is raised, the stream will 
            finish as soon as possible.  If `CallbackStop` is raised, 
            the stream will continue until all buffers generated by the 
            callback have been played.  This may be useful in 
            applications such as soundfile players where a specific 
            duration of output is required.  If another exception is 
            raised, its traceback is printed to `sys.stderr`. 
            Exceptions are *not* propagated to the main thread, i.e. the 
            main Python program keeps running as if nothing had 
            happened. 
 
            .. note:: The *callback* must always fill the entire output 
               buffer, no matter if or which exceptions are raised. 
 
            If no exception is raised in the *callback*, it 
            automatically continues to be called until `stop()`, 
            `abort()` or `close()` are used to stop the stream. 
 
            The PortAudio stream callback runs at very high or real-time 
            priority.  It is required to consistently meet its time 
            deadlines.  Do not allocate memory, access the file system, 
            call library functions or call other functions from the 
            stream callback that may block or take an unpredictable 
            amount of time to complete.  With the exception of 
            `cpu_load` it is not permissible to call PortAudio API 
            functions from within the stream callback. 
 
            In order for a stream to maintain glitch-free operation the 
            callback must consume and return audio data faster than it 
            is recorded and/or played.  PortAudio anticipates that each 
            callback invocation may execute for a duration approaching 
            the duration of *frames* audio frames at the stream's 
            sampling frequency.  It is reasonable to expect to be able 
            to utilise 70% or more of the available CPU time in the 
            PortAudio callback.  However, due to buffer size adaption 
            and other factors, not all host APIs are able to guarantee 
            audio stability under heavy CPU load with arbitrary fixed 
            callback buffer sizes.  When high callback CPU utilisation 
            is required the most robust behavior can be achieved by 
            using ``blocksize=0``. 
        finished_callback : callable, optional 
            User-supplied function which will be called when the stream 
            becomes inactive (i.e. once a call to `stop()` will not 
            block). 
 
            A stream will become inactive after the stream callback 
            raises an exception or when `stop()` or `abort()` is called. 
            For a stream providing audio output, if the stream callback 
            raises `CallbackStop`, or `stop()` is called, the stream 
            finished callback will not be called until all generated 
            sample data has been played.  The callback must have this 
            signature:: 
 
                finished_callback() -&gt; None 
 
        clip_off : bool, optional 
            See `default.clip_off`. 
        dither_off : bool, optional 
            See `default.dither_off`. 
        never_drop_input : bool, optional 
            See `default.never_drop_input`. 
        prime_output_buffers_using_stream_callback : bool, optional 
            See `default.prime_output_buffers_using_stream_callback`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_StreamBase.__init__(self</span><span class="s4">, </span><span class="s1">kind=</span><span class="s3">'duplex'</span><span class="s4">, </span><span class="s1">wrap_callback=</span><span class="s3">'array'</span><span class="s4">,</span>
                             <span class="s1">**_remove_self(locals()))</span>


<span class="s4">class </span><span class="s1">DeviceList(tuple):</span>
    <span class="s2">&quot;&quot;&quot;A list with information about all available audio devices. 
 
    This class is not meant to be instantiated by the user. 
    Instead, it is returned by `query_devices()`. 
    It contains a dictionary for each available device, holding the keys 
    described in `query_devices()`. 
 
    This class has a special string representation that is shown as 
    return value of `query_devices()` if used in an interactive 
    Python session.  It will also be shown when using the :func:`print` 
    function.  Furthermore, it can be obtained with :func:`repr` and 
    :class:`str() &lt;str&gt;`. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s4">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">idev = _get_device_id(default.device[</span><span class="s3">'input'</span><span class="s1">]</span><span class="s4">, </span><span class="s3">'input'</span><span class="s1">)</span>
        <span class="s1">odev = _get_device_id(default.device[</span><span class="s3">'output'</span><span class="s1">]</span><span class="s4">, </span><span class="s3">'output'</span><span class="s1">)</span>
        <span class="s1">digits = len(str(_lib.Pa_GetDeviceCount() - </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">hostapi_names = [hostapi[</span><span class="s3">'name'</span><span class="s1">] </span><span class="s4">for </span><span class="s1">hostapi </span><span class="s4">in </span><span class="s1">query_hostapis()]</span>
        <span class="s1">text = </span><span class="s3">'</span><span class="s4">\n</span><span class="s3">'</span><span class="s1">.join(</span>
            <span class="s3">'{mark} {idx:{dig}} {name}, {ha} ({ins} in, {outs} out)'</span><span class="s1">.format(</span>
                <span class="s1">mark=(</span><span class="s3">' '</span><span class="s4">, </span><span class="s3">'&gt;'</span><span class="s4">, </span><span class="s3">'&lt;'</span><span class="s4">, </span><span class="s3">'*'</span><span class="s1">)[(idx == idev) + </span><span class="s5">2 </span><span class="s1">* (idx == odev)]</span><span class="s4">,</span>
                <span class="s1">idx=idx</span><span class="s4">,</span>
                <span class="s1">dig=digits</span><span class="s4">,</span>
                <span class="s1">name=info[</span><span class="s3">'name'</span><span class="s1">]</span><span class="s4">,</span>
                <span class="s1">ha=hostapi_names[info[</span><span class="s3">'hostapi'</span><span class="s1">]]</span><span class="s4">,</span>
                <span class="s1">ins=info[</span><span class="s3">'max_input_channels'</span><span class="s1">]</span><span class="s4">,</span>
                <span class="s1">outs=info[</span><span class="s3">'max_output_channels'</span><span class="s1">])</span>
            <span class="s4">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">info </span><span class="s4">in </span><span class="s1">enumerate(self))</span>
        <span class="s4">return </span><span class="s1">text</span>


<span class="s4">class </span><span class="s1">CallbackFlags:</span>
    <span class="s2">&quot;&quot;&quot;Flag bits for the *status* argument to a stream *callback*. 
 
    If you experience under-/overflows, you can try to increase the 
    ``latency`` and/or ``blocksize`` settings. 
    You should also avoid anything that could block the callback 
    function for a long time, e.g. extensive computations, waiting for 
    another thread, reading/writing files, network connections, etc. 
 
    See Also 
    -------- 
    Stream 
 
    Examples 
    -------- 
    This can be used to collect the errors of multiple *status* objects: 
 
    &gt;&gt;&gt; import sounddevice as sd 
    &gt;&gt;&gt; errors = sd.CallbackFlags() 
    &gt;&gt;&gt; errors |= status1 
    &gt;&gt;&gt; errors |= status2 
    &gt;&gt;&gt; errors |= status3 
    &gt;&gt;&gt; # and so on ... 
    &gt;&gt;&gt; errors.input_overflow 
    True 
 
    The values may also be set and cleared by the user: 
 
    &gt;&gt;&gt; import sounddevice as sd 
    &gt;&gt;&gt; cf = sd.CallbackFlags() 
    &gt;&gt;&gt; cf 
    &lt;sounddevice.CallbackFlags: no flags set&gt; 
    &gt;&gt;&gt; cf.input_underflow = True 
    &gt;&gt;&gt; cf 
    &lt;sounddevice.CallbackFlags: input underflow&gt; 
    &gt;&gt;&gt; cf.input_underflow = False 
    &gt;&gt;&gt; cf 
    &lt;sounddevice.CallbackFlags: no flags set&gt; 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = </span><span class="s3">'_flags'</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">flags=</span><span class="s5">0x0</span><span class="s1">):</span>
        <span class="s1">self._flags = flags</span>

    <span class="s4">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">flags = str(self)</span>
        <span class="s4">if not </span><span class="s1">flags:</span>
            <span class="s1">flags = </span><span class="s3">'no flags set'</span>
        <span class="s4">return </span><span class="s3">f'&lt;sounddevice.CallbackFlags: </span><span class="s4">{</span><span class="s1">flags</span><span class="s4">}</span><span class="s3">&gt;'</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s3">', '</span><span class="s1">.join(name.replace(</span><span class="s3">'_'</span><span class="s4">, </span><span class="s3">' '</span><span class="s1">) </span><span class="s4">for </span><span class="s1">name </span><span class="s4">in </span><span class="s1">dir(self)</span>
                         <span class="s4">if not </span><span class="s1">name.startswith(</span><span class="s3">'_'</span><span class="s1">) </span><span class="s4">and </span><span class="s1">getattr(self</span><span class="s4">, </span><span class="s1">name))</span>

    <span class="s4">def </span><span class="s1">__bool__(self):</span>
        <span class="s4">return </span><span class="s1">bool(self._flags)</span>

    <span class="s4">def </span><span class="s1">__ior__(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s4">if not </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">CallbackFlags):</span>
            <span class="s4">return </span><span class="s1">NotImplemented</span>
        <span class="s1">self._flags |= other._flags</span>
        <span class="s4">return </span><span class="s1">self</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">input_underflow(self):</span>
        <span class="s2">&quot;&quot;&quot;Input underflow. 
 
        In a stream opened with ``blocksize=0``, indicates that input 
        data is all silence (zeros) because no real data is available. 
        In a stream opened with a non-zero *blocksize*, it indicates 
        that one or more zero samples have been inserted into the input 
        buffer to compensate for an input underflow. 
 
        This can only happen in full-duplex streams (including 
        `playrec()`). 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self._hasflag(_lib.paInputUnderflow)</span>

    <span class="s1">@input_underflow.setter</span>
    <span class="s4">def </span><span class="s1">input_underflow(self</span><span class="s4">, </span><span class="s1">value):</span>
        <span class="s1">self._updateflag(_lib.paInputUnderflow</span><span class="s4">, </span><span class="s1">value)</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">input_overflow(self):</span>
        <span class="s2">&quot;&quot;&quot;Input overflow. 
 
        In a stream opened with ``blocksize=0``, indicates that data 
        prior to the first sample of the input buffer was discarded due 
        to an overflow, possibly because the stream callback is using 
        too much CPU time.  In a stream opened with a non-zero 
        *blocksize*, it indicates that data prior to one or more samples 
        in the input buffer was discarded. 
 
        This can happen in full-duplex and input-only streams (including 
        `playrec()` and `rec()`). 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self._hasflag(_lib.paInputOverflow)</span>

    <span class="s1">@input_overflow.setter</span>
    <span class="s4">def </span><span class="s1">input_overflow(self</span><span class="s4">, </span><span class="s1">value):</span>
        <span class="s1">self._updateflag(_lib.paInputOverflow</span><span class="s4">, </span><span class="s1">value)</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">output_underflow(self):</span>
        <span class="s2">&quot;&quot;&quot;Output underflow. 
 
        Indicates that output data (or a gap) was inserted, possibly 
        because the stream callback is using too much CPU time. 
 
        This can happen in full-duplex and output-only streams 
        (including `playrec()` and `play()`). 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self._hasflag(_lib.paOutputUnderflow)</span>

    <span class="s1">@output_underflow.setter</span>
    <span class="s4">def </span><span class="s1">output_underflow(self</span><span class="s4">, </span><span class="s1">value):</span>
        <span class="s1">self._updateflag(_lib.paOutputUnderflow</span><span class="s4">, </span><span class="s1">value)</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">output_overflow(self):</span>
        <span class="s2">&quot;&quot;&quot;Output overflow. 
 
        Indicates that output data will be discarded because no room is 
        available. 
 
        This can only happen in full-duplex streams (including 
        `playrec()`), but only when ``never_drop_input=True`` was 
        specified.  See `default.never_drop_input`. 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self._hasflag(_lib.paOutputOverflow)</span>

    <span class="s1">@output_overflow.setter</span>
    <span class="s4">def </span><span class="s1">output_overflow(self</span><span class="s4">, </span><span class="s1">value):</span>
        <span class="s1">self._updateflag(_lib.paOutputOverflow</span><span class="s4">, </span><span class="s1">value)</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">priming_output(self):</span>
        <span class="s2">&quot;&quot;&quot;Priming output. 
 
        Some of all of the output data will be used to prime the stream, 
        input data may be zero. 
 
        This will only take place with some of the host APIs, and only 
        if ``prime_output_buffers_using_stream_callback=True`` was 
        specified. 
        See `default.prime_output_buffers_using_stream_callback`. 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self._hasflag(_lib.paPrimingOutput)</span>

    <span class="s4">def </span><span class="s1">_hasflag(self</span><span class="s4">, </span><span class="s1">flag):</span>
        <span class="s2">&quot;&quot;&quot;Check a given flag.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">bool(self._flags &amp; flag)</span>

    <span class="s4">def </span><span class="s1">_updateflag(self</span><span class="s4">, </span><span class="s1">flag</span><span class="s4">, </span><span class="s1">value):</span>
        <span class="s2">&quot;&quot;&quot;Set/clear a given flag.&quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">value:</span>
            <span class="s1">self._flags |= flag</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self._flags &amp;= ~flag</span>


<span class="s4">class </span><span class="s1">_InputOutputPair:</span>
    <span class="s2">&quot;&quot;&quot;Parameter pairs for device, channels, dtype and latency.&quot;&quot;&quot;</span>

    <span class="s1">_indexmapping = {</span><span class="s3">'input'</span><span class="s1">: </span><span class="s5">0</span><span class="s4">, </span><span class="s3">'output'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">parent</span><span class="s4">, </span><span class="s1">default_attr):</span>
        <span class="s1">self._pair = [</span><span class="s4">None, None</span><span class="s1">]</span>
        <span class="s1">self._parent = parent</span>
        <span class="s1">self._default_attr = default_attr</span>

    <span class="s4">def </span><span class="s1">__getitem__(self</span><span class="s4">, </span><span class="s1">index):</span>
        <span class="s1">index = self._indexmapping.get(index</span><span class="s4">, </span><span class="s1">index)</span>
        <span class="s1">value = self._pair[index]</span>
        <span class="s4">if </span><span class="s1">value </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">value = getattr(self._parent</span><span class="s4">, </span><span class="s1">self._default_attr)[index]</span>
        <span class="s4">return </span><span class="s1">value</span>

    <span class="s4">def </span><span class="s1">__setitem__(self</span><span class="s4">, </span><span class="s1">index</span><span class="s4">, </span><span class="s1">value):</span>
        <span class="s1">index = self._indexmapping.get(index</span><span class="s4">, </span><span class="s1">index)</span>
        <span class="s1">self._pair[index] = value</span>

    <span class="s4">def </span><span class="s1">__repr__(self):</span>
        <span class="s4">return </span><span class="s3">'[{0[0]!r}, {0[1]!r}]'</span><span class="s1">.format(self)</span>


<span class="s4">class </span><span class="s1">default:</span>
    <span class="s2">&quot;&quot;&quot;Get/set defaults for the *sounddevice* module. 
 
    The attributes `device`, `channels`, `dtype`, `latency` and 
    `extra_settings` accept single values which specify the given 
    property for both input and output.  However, if the property 
    differs between input and output, pairs of values can be used, where 
    the first value specifies the input and the second value specifies 
    the output.  All other attributes are always single values. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import sounddevice as sd 
    &gt;&gt;&gt; sd.default.samplerate = 48000 
    &gt;&gt;&gt; sd.default.dtype 
    ['float32', 'float32'] 
 
    Different values for input and output: 
 
    &gt;&gt;&gt; sd.default.channels = 1, 2 
 
    A single value sets both input and output at the same time: 
 
    &gt;&gt;&gt; sd.default.device = 5 
    &gt;&gt;&gt; sd.default.device 
    [5, 5] 
 
    An attribute can be set to the &quot;factory default&quot; by assigning 
    ``None``: 
 
    &gt;&gt;&gt; sd.default.samplerate = None 
    &gt;&gt;&gt; sd.default.device = None, 4 
 
    Use `reset()` to reset all attributes: 
 
    &gt;&gt;&gt; sd.default.reset() 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_pairs = </span><span class="s3">'device'</span><span class="s4">, </span><span class="s3">'channels'</span><span class="s4">, </span><span class="s3">'dtype'</span><span class="s4">, </span><span class="s3">'latency'</span><span class="s4">, </span><span class="s3">'extra_settings'</span>
    <span class="s0"># The class attributes listed in _pairs are only provided here for static</span>
    <span class="s0"># analysis tools and for the docs.  They're overwritten in __init__().</span>
    <span class="s1">device = </span><span class="s4">None, None</span>
    <span class="s3">&quot;&quot;&quot;Index or query string of default input/output device. 
 
    See the *device* argument of `Stream`. 
 
    If not overwritten, this is queried from PortAudio. 
 
    See Also 
    -------- 
    :func:`query_devices` 
 
    &quot;&quot;&quot;</span>
    <span class="s1">channels = _default_channels = </span><span class="s4">None, None</span>
    <span class="s3">&quot;&quot;&quot;Default number of input/output channels. 
 
    See the *channels* argument of `Stream`. 
 
    See Also 
    -------- 
    :func:`query_devices` 
 
    &quot;&quot;&quot;</span>
    <span class="s1">dtype = _default_dtype = </span><span class="s3">'float32'</span><span class="s4">, </span><span class="s3">'float32'</span>
    <span class="s3">&quot;&quot;&quot;Default data type used for input/output samples. 
 
    See the *dtype* argument of `Stream`. 
 
    The types ``'float32'``, ``'int32'``, ``'int16'``, ``'int8'`` and 
    ``'uint8'`` can be used for all streams and functions. 
    Additionally, `play()`, `rec()` and `playrec()` support 
    ``'float64'`` (for convenience, data is merely converted from/to 
    ``'float32'``) and `RawInputStream`, `RawOutputStream` and 
    `RawStream` support ``'int24'`` (packed 24 bit format, which is 
    *not* supported in NumPy!). 
 
    &quot;&quot;&quot;</span>
    <span class="s1">latency = _default_latency = </span><span class="s3">'high'</span><span class="s4">, </span><span class="s3">'high'</span>
    <span class="s3">&quot;&quot;&quot;See the *latency* argument of `Stream`.&quot;&quot;&quot;</span>
    <span class="s1">extra_settings = _default_extra_settings = </span><span class="s4">None, None</span>
    <span class="s3">&quot;&quot;&quot;Host-API-specific input/output settings. 
 
    See Also 
    -------- 
    AsioSettings, CoreAudioSettings, WasapiSettings 
 
    &quot;&quot;&quot;</span>
    <span class="s1">samplerate = </span><span class="s4">None</span>
    <span class="s3">&quot;&quot;&quot;Sampling frequency in Hertz (= frames per second). 
 
    See Also 
    -------- 
    :func:`query_devices` 
 
    &quot;&quot;&quot;</span>
    <span class="s1">blocksize = _lib.paFramesPerBufferUnspecified</span>
    <span class="s3">&quot;&quot;&quot;See the *blocksize* argument of `Stream`.&quot;&quot;&quot;</span>
    <span class="s1">clip_off = </span><span class="s4">False</span>
    <span class="s3">&quot;&quot;&quot;Disable clipping. 
 
    Set to ``True`` to disable default clipping of out of range samples. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">dither_off = </span><span class="s4">False</span>
    <span class="s3">&quot;&quot;&quot;Disable dithering. 
 
    Set to ``True`` to disable default dithering. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">never_drop_input = </span><span class="s4">False</span>
    <span class="s3">&quot;&quot;&quot;Set behavior for input overflow of full-duplex streams. 
 
    Set to ``True`` to request that where possible a full duplex stream 
    will not discard overflowed input samples without calling the stream 
    callback.  This flag is only valid for full-duplex callback streams 
    (i.e. only `Stream` and `RawStream` and only if *callback* was 
    specified; this includes `playrec()`) and only when used in 
    combination with ``blocksize=0`` (the default).  Using this flag 
    incorrectly results in an error being raised.  See also 
    http://www.portaudio.com/docs/proposals/001-UnderflowOverflowHandling.html. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">prime_output_buffers_using_stream_callback = </span><span class="s4">False</span>
    <span class="s3">&quot;&quot;&quot;How to fill initial output buffers. 
 
    Set to ``True`` to call the stream callback to fill initial output 
    buffers, rather than the default behavior of priming the buffers 
    with zeros (silence).  This flag has no effect for input-only 
    (`InputStream` and `RawInputStream`) and blocking read/write streams 
    (i.e. if *callback* wasn't specified).  See also 
    http://www.portaudio.com/docs/proposals/020-AllowCallbackToPrimeStream.html. 
 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self):</span>
        <span class="s4">for </span><span class="s1">attr </span><span class="s4">in </span><span class="s1">self._pairs:</span>
            <span class="s0"># __setattr__() must be avoided here</span>
            <span class="s1">vars(self)[attr] = _InputOutputPair(self</span><span class="s4">, </span><span class="s3">'_default_' </span><span class="s1">+ attr)</span>

    <span class="s4">def </span><span class="s1">__setattr__(self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">value):</span>
        <span class="s2">&quot;&quot;&quot;Only allow setting existing attributes.&quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">name </span><span class="s4">in </span><span class="s1">self._pairs:</span>
            <span class="s1">getattr(self</span><span class="s4">, </span><span class="s1">name)._pair[:] = _split(value)</span>
        <span class="s4">elif </span><span class="s1">name </span><span class="s4">in </span><span class="s1">dir(self) </span><span class="s4">and </span><span class="s1">name != </span><span class="s3">'reset'</span><span class="s1">:</span>
            <span class="s1">object.__setattr__(self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">value)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">AttributeError(</span>
                <span class="s3">&quot;'default' object has no attribute &quot; </span><span class="s1">+ repr(name))</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">_default_device(self):</span>
        <span class="s4">return </span><span class="s1">(_lib.Pa_GetDefaultInputDevice()</span><span class="s4">,</span>
                <span class="s1">_lib.Pa_GetDefaultOutputDevice())</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">hostapi(self):</span>
        <span class="s2">&quot;&quot;&quot;Index of the default host API (read-only).&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">_check(_lib.Pa_GetDefaultHostApi())</span>

    <span class="s4">def </span><span class="s1">reset(self):</span>
        <span class="s2">&quot;&quot;&quot;Reset all attributes to their &quot;factory default&quot;.&quot;&quot;&quot;</span>
        <span class="s1">vars(self).clear()</span>
        <span class="s1">self.__init__()</span>


<span class="s4">if not </span><span class="s1">hasattr(_ffi</span><span class="s4">, </span><span class="s3">'I_AM_FAKE'</span><span class="s1">):</span>
    <span class="s0"># This object shadows the 'default' class, except when building the docs.</span>
    <span class="s1">default = default()</span>


<span class="s4">class </span><span class="s1">PortAudioError(Exception):</span>
    <span class="s2">&quot;&quot;&quot;This exception will be raised on PortAudio errors. 
 
    Attributes 
    ---------- 
    args 
        A variable length tuple containing the following elements when 
        available: 
 
        1) A string describing the error 
        2) The PortAudio ``PaErrorCode`` value 
        3) A 3-tuple containing the host API index, host error code, and the 
           host error message (which may be an empty string) 
 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s1">errormsg = self.args[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">if </span><span class="s1">self.args </span><span class="s4">else </span><span class="s3">''</span>
        <span class="s4">if </span><span class="s1">len(self.args) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">errormsg = </span><span class="s3">f'</span><span class="s4">{</span><span class="s1">errormsg</span><span class="s4">} </span><span class="s3">[PaErrorCode </span><span class="s4">{</span><span class="s1">self.args[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">}</span><span class="s3">]'</span>
        <span class="s4">if </span><span class="s1">len(self.args) &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">host_api</span><span class="s4">, </span><span class="s1">hosterror_code</span><span class="s4">, </span><span class="s1">hosterror_text = self.args[</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s1">hostname = query_hostapis(host_api)[</span><span class="s3">'name'</span><span class="s1">]</span>
            <span class="s1">errormsg = </span><span class="s3">&quot;{}: '{}' [{} error {}]&quot;</span><span class="s1">.format(</span>
                <span class="s1">errormsg</span><span class="s4">, </span><span class="s1">hosterror_text</span><span class="s4">, </span><span class="s1">hostname</span><span class="s4">, </span><span class="s1">hosterror_code)</span>

        <span class="s4">return </span><span class="s1">errormsg</span>


<span class="s4">class </span><span class="s1">CallbackStop(Exception):</span>
    <span class="s2">&quot;&quot;&quot;Exception to be raised by the user to stop callback processing. 
 
    If this is raised in the stream callback, the callback will not be 
    invoked anymore (but all pending audio buffers will be played). 
 
    See Also 
    -------- 
    CallbackAbort, :meth:`Stream.stop`, Stream 
 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">CallbackAbort(Exception):</span>
    <span class="s2">&quot;&quot;&quot;Exception to be raised by the user to abort callback processing. 
 
    If this is raised in the stream callback, all pending buffers are 
    discarded and the callback will not be invoked anymore. 
 
    See Also 
    -------- 
    CallbackStop, :meth:`Stream.abort`, Stream 
 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">AsioSettings:</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">channel_selectors):</span>
        <span class="s2">&quot;&quot;&quot;ASIO-specific input/output settings. 
 
        Objects of this class can be used as *extra_settings* argument 
        to `Stream()` (and variants) or as `default.extra_settings`. 
 
        Parameters 
        ---------- 
        channel_selectors : list of int 
            Support for opening only specific channels of an ASIO 
            device.  *channel_selectors* is a list of integers 
            specifying the (zero-based) channel numbers to use. 
            The length of *channel_selectors* must match the 
            corresponding *channels* parameter of `Stream()` (or 
            variants), otherwise a crash may result. 
            The values in the *channel_selectors* array must specify 
            channels within the range of supported channels. 
 
        Examples 
        -------- 
        Setting output channels when calling `play()`: 
 
        &gt;&gt;&gt; import sounddevice as sd 
        &gt;&gt;&gt; asio_out = sd.AsioSettings(channel_selectors=[12, 13]) 
        &gt;&gt;&gt; sd.play(..., extra_settings=asio_out) 
 
        Setting default output channels: 
 
        &gt;&gt;&gt; sd.default.extra_settings = asio_out 
        &gt;&gt;&gt; sd.play(...) 
 
        Setting input channels as well: 
 
        &gt;&gt;&gt; asio_in = sd.AsioSettings(channel_selectors=[8]) 
        &gt;&gt;&gt; sd.default.extra_settings = asio_in, asio_out 
        &gt;&gt;&gt; sd.playrec(..., channels=1, ...) 
 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">isinstance(channel_selectors</span><span class="s4">, </span><span class="s1">int):</span>
            <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'channel_selectors must be a list or tuple'</span><span class="s1">)</span>
        <span class="s0"># int array must be kept alive!</span>
        <span class="s1">self._selectors = _ffi.new(</span><span class="s3">'int[]'</span><span class="s4">, </span><span class="s1">channel_selectors)</span>
        <span class="s1">self._streaminfo = _ffi.new(</span><span class="s3">'PaAsioStreamInfo*'</span><span class="s4">, </span><span class="s1">dict(</span>
            <span class="s1">size=_ffi.sizeof(</span><span class="s3">'PaAsioStreamInfo'</span><span class="s1">)</span><span class="s4">,</span>
            <span class="s1">hostApiType=_lib.paASIO</span><span class="s4">,</span>
            <span class="s1">version=</span><span class="s5">1</span><span class="s4">,</span>
            <span class="s1">flags=_lib.paAsioUseChannelSelectors</span><span class="s4">,</span>
            <span class="s1">channelSelectors=self._selectors))</span>


<span class="s4">class </span><span class="s1">CoreAudioSettings:</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">channel_map=</span><span class="s4">None, </span><span class="s1">change_device_parameters=</span><span class="s4">False,</span>
                 <span class="s1">fail_if_conversion_required=</span><span class="s4">False, </span><span class="s1">conversion_quality=</span><span class="s3">'max'</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Mac Core Audio-specific input/output settings. 
 
        Objects of this class can be used as *extra_settings* argument 
        to `Stream()` (and variants) or as `default.extra_settings`. 
 
        Parameters 
        ---------- 
        channel_map : sequence of int, optional 
            Support for opening only specific channels of a Core Audio 
            device.  Note that *channel_map* is treated differently 
            between input and output channels. 
 
            For input devices, *channel_map* is a list of integers 
            specifying the (zero-based) channel numbers to use. 
 
            For output devices, *channel_map* must have the same length 
            as the number of output channels of the device.  Specify 
            unused channels with -1, and a 0-based index for any desired 
            channels. 
 
            See the example below.  For additional information, see the 
            `PortAudio documentation`__. 
 
            __ https://app.assembla.com/spaces/portaudio/git/source/ 
               master/src/hostapi/coreaudio/notes.txt 
        change_device_parameters : bool, optional 
            If ``True``, allows PortAudio to change things like the 
            device's frame size, which allows for much lower latency, 
            but might disrupt the device if other programs are using it, 
            even when you are just querying the device.  ``False`` is 
            the default. 
        fail_if_conversion_required : bool, optional 
            In combination with the above flag, ``True`` causes the 
            stream opening to fail, unless the exact sample rates are 
            supported by the device. 
        conversion_quality : {'min', 'low', 'medium', 'high', 'max'}, optional 
            This sets Core Audio's sample rate conversion quality. 
            ``'max'`` is the default. 
 
        Example 
        ------- 
        This example assumes a device having 6 input and 6 output 
        channels.  Input is from the second and fourth channels, and 
        output is to the device's third and fifth channels: 
 
        &gt;&gt;&gt; import sounddevice as sd 
        &gt;&gt;&gt; ca_in = sd.CoreAudioSettings(channel_map=[1, 3]) 
        &gt;&gt;&gt; ca_out = sd.CoreAudioSettings(channel_map=[-1, -1, 0, -1, 1, -1]) 
        &gt;&gt;&gt; sd.playrec(..., channels=2, extra_settings=(ca_in, ca_out)) 
 
        &quot;&quot;&quot;</span>
        <span class="s1">conversion_dict = {</span>
            <span class="s3">'min'</span><span class="s1">:    _lib.paMacCoreConversionQualityMin</span><span class="s4">,</span>
            <span class="s3">'low'</span><span class="s1">:    _lib.paMacCoreConversionQualityLow</span><span class="s4">,</span>
            <span class="s3">'medium'</span><span class="s1">: _lib.paMacCoreConversionQualityMedium</span><span class="s4">,</span>
            <span class="s3">'high'</span><span class="s1">:   _lib.paMacCoreConversionQualityHigh</span><span class="s4">,</span>
            <span class="s3">'max'</span><span class="s1">:    _lib.paMacCoreConversionQualityMax</span><span class="s4">,</span>
        <span class="s1">}</span>

        <span class="s0"># Minimal checking on channel_map to catch errors that might</span>
        <span class="s0"># otherwise go unnoticed:</span>
        <span class="s4">if </span><span class="s1">isinstance(channel_map</span><span class="s4">, </span><span class="s1">int):</span>
            <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'channel_map must be a list or tuple'</span><span class="s1">)</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">self._flags = conversion_dict[conversion_quality.lower()]</span>
        <span class="s4">except </span><span class="s1">(KeyError</span><span class="s4">, </span><span class="s1">AttributeError) </span><span class="s4">as </span><span class="s1">e:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'conversion_quality must be one of ' </span><span class="s1">+</span>
                             <span class="s1">repr(list(conversion_dict))) </span><span class="s4">from </span><span class="s1">e</span>
        <span class="s4">if </span><span class="s1">change_device_parameters:</span>
            <span class="s1">self._flags |= _lib.paMacCoreChangeDeviceParameters</span>
        <span class="s4">if </span><span class="s1">fail_if_conversion_required:</span>
            <span class="s1">self._flags |= _lib.paMacCoreFailIfConversionRequired</span>

        <span class="s0"># this struct must be kept alive!</span>
        <span class="s1">self._streaminfo = _ffi.new(</span><span class="s3">'PaMacCoreStreamInfo*'</span><span class="s1">)</span>
        <span class="s1">_lib.PaMacCore_SetupStreamInfo(self._streaminfo</span><span class="s4">, </span><span class="s1">self._flags)</span>

        <span class="s4">if </span><span class="s1">channel_map </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s0"># this array must be kept alive!</span>
            <span class="s1">self._channel_map = _ffi.new(</span><span class="s3">'SInt32[]'</span><span class="s4">, </span><span class="s1">channel_map)</span>
            <span class="s4">if </span><span class="s1">len(self._channel_map) == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'channel_map must not be empty'</span><span class="s1">)</span>
            <span class="s1">_lib.PaMacCore_SetupChannelMap(self._streaminfo</span><span class="s4">,</span>
                                           <span class="s1">self._channel_map</span><span class="s4">,</span>
                                           <span class="s1">len(self._channel_map))</span>


<span class="s4">class </span><span class="s1">WasapiSettings:</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">exclusive=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;WASAPI-specific input/output settings. 
 
        Objects of this class can be used as *extra_settings* argument 
        to `Stream()` (and variants) or as `default.extra_settings`. 
        They can also be used in `check_input_settings()` and 
        `check_output_settings()`. 
 
        Parameters 
        ---------- 
        exclusive : bool 
            Exclusive mode allows to deliver audio data directly to 
            hardware bypassing software mixing. 
 
        Examples 
        -------- 
        Setting exclusive mode when calling `play()`: 
 
        &gt;&gt;&gt; import sounddevice as sd 
        &gt;&gt;&gt; wasapi_exclusive = sd.WasapiSettings(exclusive=True) 
        &gt;&gt;&gt; sd.play(..., extra_settings=wasapi_exclusive) 
 
        Setting exclusive mode as default: 
 
        &gt;&gt;&gt; sd.default.extra_settings = wasapi_exclusive 
        &gt;&gt;&gt; sd.play(...) 
 
        &quot;&quot;&quot;</span>
        <span class="s1">flags = </span><span class="s5">0x0</span>
        <span class="s4">if </span><span class="s1">exclusive:</span>
            <span class="s1">flags |= _lib.paWinWasapiExclusive</span>
        <span class="s1">self._streaminfo = _ffi.new(</span><span class="s3">'PaWasapiStreamInfo*'</span><span class="s4">, </span><span class="s1">dict(</span>
            <span class="s1">size=_ffi.sizeof(</span><span class="s3">'PaWasapiStreamInfo'</span><span class="s1">)</span><span class="s4">,</span>
            <span class="s1">hostApiType=_lib.paWASAPI</span><span class="s4">,</span>
            <span class="s1">version=</span><span class="s5">1</span><span class="s4">,</span>
            <span class="s1">flags=flags</span><span class="s4">,</span>
        <span class="s1">))</span>


<span class="s4">class </span><span class="s1">_CallbackContext:</span>
    <span class="s2">&quot;&quot;&quot;Helper class for re-use in play()/rec()/playrec() callbacks.&quot;&quot;&quot;</span>

    <span class="s1">blocksize = </span><span class="s4">None</span>
    <span class="s1">data = </span><span class="s4">None</span>
    <span class="s1">out = </span><span class="s4">None</span>
    <span class="s1">frame = </span><span class="s5">0</span>
    <span class="s1">input_channels = output_channels = </span><span class="s4">None</span>
    <span class="s1">input_dtype = output_dtype = </span><span class="s4">None</span>
    <span class="s1">input_mapping = output_mapping = </span><span class="s4">None</span>
    <span class="s1">silent_channels = </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">loop=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s4">import </span><span class="s1">threading</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">import </span><span class="s1">numpy</span>
            <span class="s4">assert </span><span class="s1">numpy  </span><span class="s0"># avoid &quot;imported but unused&quot; message (W0611)</span>
        <span class="s4">except </span><span class="s1">ImportError </span><span class="s4">as </span><span class="s1">e:</span>
            <span class="s4">raise </span><span class="s1">ImportError(</span>
                <span class="s3">'NumPy must be installed for play()/rec()/playrec()'</span><span class="s1">) </span><span class="s4">from </span><span class="s1">e</span>
        <span class="s1">self.loop = loop</span>
        <span class="s1">self.event = threading.Event()</span>
        <span class="s1">self.status = CallbackFlags()</span>

    <span class="s4">def </span><span class="s1">check_data(self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">mapping</span><span class="s4">, </span><span class="s1">device):</span>
        <span class="s2">&quot;&quot;&quot;Check data and output mapping.&quot;&quot;&quot;</span>
        <span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>
        <span class="s1">data = np.asarray(data)</span>
        <span class="s4">if </span><span class="s1">data.ndim &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">data = data.reshape(-</span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s4">elif </span><span class="s1">data.ndim &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span>
                <span class="s3">'audio data to be played back must be one- or two-dimensional'</span><span class="s1">)</span>
        <span class="s1">frames</span><span class="s4">, </span><span class="s1">channels = data.shape</span>
        <span class="s1">dtype = _check_dtype(data.dtype)</span>
        <span class="s1">mapping_is_explicit = mapping </span><span class="s4">is not None</span>
        <span class="s1">mapping</span><span class="s4">, </span><span class="s1">channels = _check_mapping(mapping</span><span class="s4">, </span><span class="s1">channels)</span>
        <span class="s4">if </span><span class="s1">data.shape[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">pass  </span><span class="s0"># No problem, mono data is duplicated into arbitrary channels</span>
        <span class="s4">elif </span><span class="s1">data.shape[</span><span class="s5">1</span><span class="s1">] != len(mapping):</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span>
                <span class="s3">'number of output channels != size of output mapping'</span><span class="s1">)</span>
        <span class="s0"># Apparently, some PortAudio host APIs duplicate mono streams to the</span>
        <span class="s0"># first two channels, which is unexpected when specifying mapping=[1].</span>
        <span class="s0"># In this case, we play silence on the second channel, but only if the</span>
        <span class="s0"># device actually supports a second channel:</span>
        <span class="s4">if </span><span class="s1">(mapping_is_explicit </span><span class="s4">and </span><span class="s1">np.array_equal(mapping</span><span class="s4">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]) </span><span class="s4">and</span>
                <span class="s1">query_devices(device</span><span class="s4">, </span><span class="s3">'output'</span><span class="s1">)[</span><span class="s3">'max_output_channels'</span><span class="s1">] &gt;= </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s1">channels = </span><span class="s5">2</span>
        <span class="s1">silent_channels = np.setdiff1d(np.arange(channels)</span><span class="s4">, </span><span class="s1">mapping)</span>
        <span class="s4">if </span><span class="s1">len(mapping) + len(silent_channels) != channels:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'each channel may only appear once in mapping'</span><span class="s1">)</span>

        <span class="s1">self.data = data</span>
        <span class="s1">self.output_channels = channels</span>
        <span class="s1">self.output_dtype = dtype</span>
        <span class="s1">self.output_mapping = mapping</span>
        <span class="s1">self.silent_channels = silent_channels</span>
        <span class="s4">return </span><span class="s1">frames</span>

    <span class="s4">def </span><span class="s1">check_out(self</span><span class="s4">, </span><span class="s1">out</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">channels</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">mapping):</span>
        <span class="s2">&quot;&quot;&quot;Check out, frames, channels, dtype and input mapping.&quot;&quot;&quot;</span>
        <span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>
        <span class="s4">if </span><span class="s1">out </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">frames </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'frames must be specified'</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">channels </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">channels = default.channels[</span><span class="s3">'input'</span><span class="s1">]</span>
            <span class="s4">if </span><span class="s1">channels </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s4">if </span><span class="s1">mapping </span><span class="s4">is None</span><span class="s1">:</span>
                    <span class="s4">raise </span><span class="s1">TypeError(</span>
                        <span class="s3">'Unable to determine number of input channels'</span><span class="s1">)</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">channels = len(np.atleast_1d(mapping))</span>
            <span class="s4">if </span><span class="s1">dtype </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">dtype = default.dtype[</span><span class="s3">'input'</span><span class="s1">]</span>
            <span class="s1">out = np.empty((frames</span><span class="s4">, </span><span class="s1">channels)</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">order=</span><span class="s3">'C'</span><span class="s1">)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">frames</span><span class="s4">, </span><span class="s1">channels = out.shape</span>
            <span class="s1">dtype = out.dtype</span>
        <span class="s1">dtype = _check_dtype(dtype)</span>
        <span class="s1">mapping</span><span class="s4">, </span><span class="s1">channels = _check_mapping(mapping</span><span class="s4">, </span><span class="s1">channels)</span>
        <span class="s4">if </span><span class="s1">out.shape[</span><span class="s5">1</span><span class="s1">] != len(mapping):</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span>
                <span class="s3">'number of input channels != size of input mapping'</span><span class="s1">)</span>

        <span class="s1">self.out = out</span>
        <span class="s1">self.input_channels = channels</span>
        <span class="s1">self.input_dtype = dtype</span>
        <span class="s1">self.input_mapping = mapping</span>
        <span class="s4">return </span><span class="s1">out</span><span class="s4">, </span><span class="s1">frames</span>

    <span class="s4">def </span><span class="s1">callback_enter(self</span><span class="s4">, </span><span class="s1">status</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s2">&quot;&quot;&quot;Check status and blocksize.&quot;&quot;&quot;</span>
        <span class="s1">self.status |= status</span>
        <span class="s1">self.blocksize = min(self.frames - self.frame</span><span class="s4">, </span><span class="s1">len(data))</span>

    <span class="s4">def </span><span class="s1">read_indata(self</span><span class="s4">, </span><span class="s1">indata):</span>
        <span class="s0"># We manually iterate over each channel in mapping because</span>
        <span class="s0"># numpy.take(..., out=...) has a bug:</span>
        <span class="s0"># https://github.com/numpy/numpy/pull/4246.</span>
        <span class="s0"># Note: using indata[:blocksize, mapping] (a.k.a. 'fancy' indexing)</span>
        <span class="s0"># would create unwanted copies (and probably memory allocations).</span>
        <span class="s4">for </span><span class="s1">target</span><span class="s4">, </span><span class="s1">source </span><span class="s4">in </span><span class="s1">enumerate(self.input_mapping):</span>
            <span class="s0"># If out.dtype is 'float64', 'float32' data is &quot;upgraded&quot; here:</span>
            <span class="s1">self.out[self.frame:self.frame + self.blocksize</span><span class="s4">, </span><span class="s1">target] = \</span>
                <span class="s1">indata[:self.blocksize</span><span class="s4">, </span><span class="s1">source]</span>

    <span class="s4">def </span><span class="s1">write_outdata(self</span><span class="s4">, </span><span class="s1">outdata):</span>
        <span class="s0"># 'float64' data is cast to 'float32' here:</span>
        <span class="s1">outdata[:self.blocksize</span><span class="s4">, </span><span class="s1">self.output_mapping] = \</span>
            <span class="s1">self.data[self.frame:self.frame + self.blocksize]</span>
        <span class="s1">outdata[:self.blocksize</span><span class="s4">, </span><span class="s1">self.silent_channels] = </span><span class="s5">0</span>
        <span class="s4">if </span><span class="s1">self.loop </span><span class="s4">and </span><span class="s1">self.blocksize &lt; len(outdata):</span>
            <span class="s1">self.frame = </span><span class="s5">0</span>
            <span class="s1">outdata = outdata[self.blocksize:]</span>
            <span class="s1">self.blocksize = min(self.frames</span><span class="s4">, </span><span class="s1">len(outdata))</span>
            <span class="s1">self.write_outdata(outdata)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">outdata[self.blocksize:] = </span><span class="s5">0</span>

    <span class="s4">def </span><span class="s1">callback_exit(self):</span>
        <span class="s4">if not </span><span class="s1">self.blocksize:</span>
            <span class="s4">raise </span><span class="s1">CallbackAbort</span>
        <span class="s1">self.frame += self.blocksize</span>

    <span class="s4">def </span><span class="s1">finished_callback(self):</span>
        <span class="s1">self.event.set()</span>
        <span class="s0"># Drop temporary audio buffers to free memory</span>
        <span class="s1">self.data = </span><span class="s4">None</span>
        <span class="s1">self.out = </span><span class="s4">None</span>
        <span class="s0"># Drop CFFI objects to avoid reference cycles</span>
        <span class="s1">self.stream._callback = </span><span class="s4">None</span>
        <span class="s1">self.stream._finished_callback = </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">start_stream(self</span><span class="s4">, </span><span class="s1">StreamClass</span><span class="s4">, </span><span class="s1">samplerate</span><span class="s4">, </span><span class="s1">channels</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">callback</span><span class="s4">,</span>
                     <span class="s1">blocking</span><span class="s4">, </span><span class="s1">**kwargs):</span>
        <span class="s1">stop()  </span><span class="s0"># Stop previous playback/recording</span>
        <span class="s1">self.stream = StreamClass(samplerate=samplerate</span><span class="s4">,</span>
                                  <span class="s1">channels=channels</span><span class="s4">,</span>
                                  <span class="s1">dtype=dtype</span><span class="s4">,</span>
                                  <span class="s1">callback=callback</span><span class="s4">,</span>
                                  <span class="s1">finished_callback=self.finished_callback</span><span class="s4">,</span>
                                  <span class="s1">**kwargs)</span>
        <span class="s1">self.stream.start()</span>
        <span class="s4">global </span><span class="s1">_last_callback</span>
        <span class="s1">_last_callback = self</span>
        <span class="s4">if </span><span class="s1">blocking:</span>
            <span class="s1">self.wait()</span>

    <span class="s4">def </span><span class="s1">wait(self</span><span class="s4">, </span><span class="s1">ignore_errors=</span><span class="s4">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Wait for finished_callback. 
 
        Can be interrupted with a KeyboardInterrupt. 
 
        &quot;&quot;&quot;</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">self.event.wait()</span>
        <span class="s4">finally</span><span class="s1">:</span>
            <span class="s1">self.stream.close(ignore_errors)</span>
        <span class="s4">return </span><span class="s1">self.status </span><span class="s4">if </span><span class="s1">self.status </span><span class="s4">else None</span>


<span class="s4">def </span><span class="s1">_remove_self(d):</span>
    <span class="s2">&quot;&quot;&quot;Return a copy of d without the 'self' entry.&quot;&quot;&quot;</span>
    <span class="s1">d = d.copy()</span>
    <span class="s4">del </span><span class="s1">d[</span><span class="s3">'self'</span><span class="s1">]</span>
    <span class="s4">return </span><span class="s1">d</span>


<span class="s4">def </span><span class="s1">_check_mapping(mapping</span><span class="s4">, </span><span class="s1">channels):</span>
    <span class="s2">&quot;&quot;&quot;Check mapping, obtain channels.&quot;&quot;&quot;</span>
    <span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>
    <span class="s4">if </span><span class="s1">mapping </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">mapping = np.arange(channels)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">mapping = np.array(mapping</span><span class="s4">, </span><span class="s1">copy=</span><span class="s4">True</span><span class="s1">)</span>
        <span class="s1">mapping = np.atleast_1d(mapping)</span>
        <span class="s4">if </span><span class="s1">mapping.min() &lt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'channel numbers must not be &lt; 1'</span><span class="s1">)</span>
        <span class="s1">channels = mapping.max()</span>
        <span class="s1">mapping -= </span><span class="s5">1  </span><span class="s0"># channel numbers start with 1</span>
    <span class="s4">return </span><span class="s1">mapping</span><span class="s4">, </span><span class="s1">channels</span>


<span class="s4">def </span><span class="s1">_check_dtype(dtype):</span>
    <span class="s2">&quot;&quot;&quot;Check dtype.&quot;&quot;&quot;</span>
    <span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>
    <span class="s1">dtype = np.dtype(dtype).name</span>
    <span class="s4">if </span><span class="s1">dtype </span><span class="s4">in </span><span class="s1">_sampleformats:</span>
        <span class="s4">pass</span>
    <span class="s4">elif </span><span class="s1">dtype == </span><span class="s3">'float64'</span><span class="s1">:</span>
        <span class="s1">dtype = </span><span class="s3">'float32'</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'Unsupported data type: ' </span><span class="s1">+ repr(dtype))</span>
    <span class="s4">return </span><span class="s1">dtype</span>


<span class="s4">def </span><span class="s1">_get_stream_parameters(kind</span><span class="s4">, </span><span class="s1">device</span><span class="s4">, </span><span class="s1">channels</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">latency</span><span class="s4">,</span>
                           <span class="s1">extra_settings</span><span class="s4">, </span><span class="s1">samplerate):</span>
    <span class="s2">&quot;&quot;&quot;Get parameters for one direction (input or output) of a stream.&quot;&quot;&quot;</span>
    <span class="s4">assert </span><span class="s1">kind </span><span class="s4">in </span><span class="s1">(</span><span class="s3">'input'</span><span class="s4">, </span><span class="s3">'output'</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">device </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">device = default.device[kind]</span>
    <span class="s4">if </span><span class="s1">channels </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">channels = default.channels[kind]</span>
    <span class="s4">if </span><span class="s1">dtype </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">dtype = default.dtype[kind]</span>
    <span class="s4">if </span><span class="s1">latency </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">latency = default.latency[kind]</span>
    <span class="s4">if </span><span class="s1">extra_settings </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">extra_settings = default.extra_settings[kind]</span>
    <span class="s4">if </span><span class="s1">samplerate </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">samplerate = default.samplerate</span>

    <span class="s1">device = _get_device_id(device</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">, </span><span class="s1">raise_on_error=</span><span class="s4">True</span><span class="s1">)</span>
    <span class="s1">info = query_devices(device)</span>
    <span class="s4">if </span><span class="s1">channels </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">channels = info[</span><span class="s3">'max_' </span><span class="s1">+ kind + </span><span class="s3">'_channels'</span><span class="s1">]</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s0"># If NumPy is available, get canonical dtype name</span>
        <span class="s1">dtype = _sys.modules[</span><span class="s3">'numpy'</span><span class="s1">].dtype(dtype).name</span>
    <span class="s4">except </span><span class="s1">Exception:</span>
        <span class="s4">pass  </span><span class="s0"># NumPy not available or invalid dtype (e.g. 'int24') or ...</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">sampleformat = _sampleformats[dtype]</span>
    <span class="s4">except </span><span class="s1">KeyError </span><span class="s4">as </span><span class="s1">e:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Invalid ' </span><span class="s1">+ kind + </span><span class="s3">' sample format'</span><span class="s1">) </span><span class="s4">from </span><span class="s1">e</span>
    <span class="s1">samplesize = _check(_lib.Pa_GetSampleSize(sampleformat))</span>
    <span class="s4">if </span><span class="s1">latency </span><span class="s4">in </span><span class="s1">(</span><span class="s3">'low'</span><span class="s4">, </span><span class="s3">'high'</span><span class="s1">):</span>
        <span class="s1">latency = info[</span><span class="s3">'default_' </span><span class="s1">+ latency + </span><span class="s3">'_' </span><span class="s1">+ kind + </span><span class="s3">'_latency'</span><span class="s1">]</span>
    <span class="s4">if </span><span class="s1">samplerate </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">samplerate = info[</span><span class="s3">'default_samplerate'</span><span class="s1">]</span>
    <span class="s1">parameters = _ffi.new(</span><span class="s3">'PaStreamParameters*'</span><span class="s4">, </span><span class="s1">(</span>
        <span class="s1">device</span><span class="s4">, </span><span class="s1">channels</span><span class="s4">, </span><span class="s1">sampleformat</span><span class="s4">, </span><span class="s1">latency</span><span class="s4">,</span>
        <span class="s1">extra_settings._streaminfo </span><span class="s4">if </span><span class="s1">extra_settings </span><span class="s4">else </span><span class="s1">_ffi.NULL))</span>
    <span class="s4">return </span><span class="s1">parameters</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">samplesize</span><span class="s4">, </span><span class="s1">samplerate</span>


<span class="s4">def </span><span class="s1">_wrap_callback(callback</span><span class="s4">, </span><span class="s1">*args):</span>
    <span class="s2">&quot;&quot;&quot;Invoke callback function and check for custom exceptions.&quot;&quot;&quot;</span>
    <span class="s1">args = args[:-</span><span class="s5">1</span><span class="s1">] + (CallbackFlags(args[-</span><span class="s5">1</span><span class="s1">])</span><span class="s4">,</span><span class="s1">)</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">callback(*args)</span>
    <span class="s4">except </span><span class="s1">CallbackStop:</span>
        <span class="s4">return </span><span class="s1">_lib.paComplete</span>
    <span class="s4">except </span><span class="s1">CallbackAbort:</span>
        <span class="s4">return </span><span class="s1">_lib.paAbort</span>
    <span class="s4">return </span><span class="s1">_lib.paContinue</span>


<span class="s4">def </span><span class="s1">_buffer(ptr</span><span class="s4">, </span><span class="s1">frames</span><span class="s4">, </span><span class="s1">channels</span><span class="s4">, </span><span class="s1">samplesize):</span>
    <span class="s2">&quot;&quot;&quot;Create a buffer object from a pointer to some memory.&quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">_ffi.buffer(ptr</span><span class="s4">, </span><span class="s1">frames * channels * samplesize)</span>


<span class="s4">def </span><span class="s1">_array(buffer</span><span class="s4">, </span><span class="s1">channels</span><span class="s4">, </span><span class="s1">dtype):</span>
    <span class="s2">&quot;&quot;&quot;Create NumPy array from a buffer object.&quot;&quot;&quot;</span>
    <span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>
    <span class="s1">data = np.frombuffer(buffer</span><span class="s4">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">data.shape = -</span><span class="s5">1</span><span class="s4">, </span><span class="s1">channels</span>
    <span class="s4">return </span><span class="s1">data</span>


<span class="s4">def </span><span class="s1">_split(value):</span>
    <span class="s2">&quot;&quot;&quot;Split input/output value into two values. 
 
    This can be useful for generic code that allows using the same value 
    for input and output but also a pair of two separate values. 
 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">(str</span><span class="s4">, </span><span class="s1">bytes)):</span>
        <span class="s0"># iterable, but not meant for splitting</span>
        <span class="s4">return </span><span class="s1">value</span><span class="s4">, </span><span class="s1">value</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">invalue</span><span class="s4">, </span><span class="s1">outvalue = value</span>
    <span class="s4">except </span><span class="s1">TypeError:</span>
        <span class="s1">invalue = outvalue = value</span>
    <span class="s4">except </span><span class="s1">ValueError </span><span class="s4">as </span><span class="s1">e:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Only single values and pairs are allowed'</span><span class="s1">) </span><span class="s4">from </span><span class="s1">e</span>
    <span class="s4">return </span><span class="s1">invalue</span><span class="s4">, </span><span class="s1">outvalue</span>


<span class="s4">def </span><span class="s1">_check(err</span><span class="s4">, </span><span class="s1">msg=</span><span class="s3">''</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Raise PortAudioError for below-zero error codes.&quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">err &gt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">err</span>

    <span class="s1">errormsg = _ffi.string(_lib.Pa_GetErrorText(err)).decode()</span>
    <span class="s4">if </span><span class="s1">msg:</span>
        <span class="s1">errormsg = </span><span class="s3">f'</span><span class="s4">{</span><span class="s1">msg</span><span class="s4">}</span><span class="s3">: </span><span class="s4">{</span><span class="s1">errormsg</span><span class="s4">}</span><span class="s3">'</span>

    <span class="s4">if </span><span class="s1">err == _lib.paUnanticipatedHostError:</span>
        <span class="s0"># (gh82) We grab the host error info here rather than inside</span>
        <span class="s0"># PortAudioError since _check should only ever be called after a</span>
        <span class="s0"># failing API function call. This way we can avoid any potential issues</span>
        <span class="s0"># in scenarios where multiple APIs are being used simultaneously.</span>
        <span class="s1">info = _lib.Pa_GetLastHostErrorInfo()</span>
        <span class="s1">host_api = _lib.Pa_HostApiTypeIdToHostApiIndex(info.hostApiType)</span>
        <span class="s1">hosterror_text = _ffi.string(info.errorText).decode()</span>
        <span class="s1">hosterror_info = host_api</span><span class="s4">, </span><span class="s1">info.errorCode</span><span class="s4">, </span><span class="s1">hosterror_text</span>
        <span class="s4">raise </span><span class="s1">PortAudioError(errormsg</span><span class="s4">, </span><span class="s1">err</span><span class="s4">, </span><span class="s1">hosterror_info)</span>

    <span class="s4">raise </span><span class="s1">PortAudioError(errormsg</span><span class="s4">, </span><span class="s1">err)</span>


<span class="s4">def </span><span class="s1">_get_device_id(id_or_query_string</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">, </span><span class="s1">raise_on_error=</span><span class="s4">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Return device ID given space-separated substrings.&quot;&quot;&quot;</span>
    <span class="s4">assert </span><span class="s1">kind </span><span class="s4">in </span><span class="s1">(</span><span class="s3">'input'</span><span class="s4">, </span><span class="s3">'output'</span><span class="s4">, None</span><span class="s1">)</span>

    <span class="s4">if </span><span class="s1">id_or_query_string </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">id_or_query_string = default.device</span>

    <span class="s1">idev</span><span class="s4">, </span><span class="s1">odev = _split(id_or_query_string)</span>
    <span class="s4">if </span><span class="s1">kind == </span><span class="s3">'input'</span><span class="s1">:</span>
        <span class="s1">id_or_query_string = idev</span>
    <span class="s4">elif </span><span class="s1">kind == </span><span class="s3">'output'</span><span class="s1">:</span>
        <span class="s1">id_or_query_string = odev</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">idev == odev:</span>
            <span class="s1">id_or_query_string = idev</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Input and output device are different: {!r}'</span>
                             <span class="s1">.format(id_or_query_string))</span>

    <span class="s4">if </span><span class="s1">isinstance(id_or_query_string</span><span class="s4">, </span><span class="s1">int):</span>
        <span class="s4">return </span><span class="s1">id_or_query_string</span>
    <span class="s1">device_list = []</span>
    <span class="s4">for </span><span class="s1">id</span><span class="s4">, </span><span class="s1">info </span><span class="s4">in </span><span class="s1">enumerate(query_devices()):</span>
        <span class="s4">if not </span><span class="s1">kind </span><span class="s4">or </span><span class="s1">info[</span><span class="s3">'max_' </span><span class="s1">+ kind + </span><span class="s3">'_channels'</span><span class="s1">] &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">hostapi_info = query_hostapis(info[</span><span class="s3">'hostapi'</span><span class="s1">])</span>
            <span class="s1">device_list.append((id</span><span class="s4">, </span><span class="s1">info[</span><span class="s3">'name'</span><span class="s1">]</span><span class="s4">, </span><span class="s1">hostapi_info[</span><span class="s3">'name'</span><span class="s1">]))</span>

    <span class="s1">query_string = id_or_query_string.lower()</span>
    <span class="s1">substrings = query_string.split()</span>
    <span class="s1">matches = []</span>
    <span class="s1">exact_device_matches = []</span>
    <span class="s4">for </span><span class="s1">id</span><span class="s4">, </span><span class="s1">device_string</span><span class="s4">, </span><span class="s1">hostapi_string </span><span class="s4">in </span><span class="s1">device_list:</span>
        <span class="s1">full_string = device_string + </span><span class="s3">', ' </span><span class="s1">+ hostapi_string</span>
        <span class="s1">pos = </span><span class="s5">0</span>
        <span class="s4">for </span><span class="s1">substring </span><span class="s4">in </span><span class="s1">substrings:</span>
            <span class="s1">pos = full_string.lower().find(substring</span><span class="s4">, </span><span class="s1">pos)</span>
            <span class="s4">if </span><span class="s1">pos &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">break</span>
            <span class="s1">pos += len(substring)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">matches.append((id</span><span class="s4">, </span><span class="s1">full_string))</span>
            <span class="s4">if </span><span class="s1">query_string </span><span class="s4">in </span><span class="s1">[device_string.lower()</span><span class="s4">, </span><span class="s1">full_string.lower()]:</span>
                <span class="s1">exact_device_matches.append(id)</span>

    <span class="s4">if </span><span class="s1">kind </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">kind = </span><span class="s3">'input/output'  </span><span class="s0"># Just used for error messages</span>

    <span class="s4">if not </span><span class="s1">matches:</span>
        <span class="s4">if </span><span class="s1">raise_on_error:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span>
                <span class="s3">'No ' </span><span class="s1">+ kind + </span><span class="s3">' device matching ' </span><span class="s1">+ repr(id_or_query_string))</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">-</span><span class="s5">1</span>
    <span class="s4">if </span><span class="s1">len(matches) &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">len(exact_device_matches) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">exact_device_matches[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s4">if </span><span class="s1">raise_on_error:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Multiple ' </span><span class="s1">+ kind + </span><span class="s3">' devices found for ' </span><span class="s1">+</span>
                             <span class="s1">repr(id_or_query_string) + </span><span class="s3">':</span><span class="s4">\n</span><span class="s3">' </span><span class="s1">+</span>
                             <span class="s3">'</span><span class="s4">\n</span><span class="s3">'</span><span class="s1">.join(</span><span class="s3">f'[</span><span class="s4">{</span><span class="s1">id</span><span class="s4">}</span><span class="s3">] </span><span class="s4">{</span><span class="s1">name</span><span class="s4">}</span><span class="s3">'</span>
                                       <span class="s4">for </span><span class="s1">id</span><span class="s4">, </span><span class="s1">name </span><span class="s4">in </span><span class="s1">matches))</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">-</span><span class="s5">1</span>
    <span class="s4">return </span><span class="s1">matches[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>


<span class="s4">def </span><span class="s1">_initialize():</span>
    <span class="s2">&quot;&quot;&quot;Initialize PortAudio. 
 
    This temporarily forwards messages from stderr to ``/dev/null`` 
    (where supported). 
 
    In most cases, this doesn't have to be called explicitly, because it 
    is automatically called with the ``import sounddevice`` statement. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">old_stderr = </span><span class="s4">None</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">old_stderr = _os.dup(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">devnull = _os.open(_os.devnull</span><span class="s4">, </span><span class="s1">_os.O_WRONLY)</span>
        <span class="s1">_os.dup2(devnull</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">_os.close(devnull)</span>
    <span class="s4">except </span><span class="s1">OSError:</span>
        <span class="s4">pass</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">_check(_lib.Pa_Initialize()</span><span class="s4">, </span><span class="s3">'Error initializing PortAudio'</span><span class="s1">)</span>
        <span class="s4">global </span><span class="s1">_initialized</span>
        <span class="s1">_initialized += </span><span class="s5">1</span>
    <span class="s4">finally</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">old_stderr </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">_os.dup2(old_stderr</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">_os.close(old_stderr)</span>


<span class="s4">def </span><span class="s1">_terminate():</span>
    <span class="s2">&quot;&quot;&quot;Terminate PortAudio. 
 
    In most cases, this doesn't have to be called explicitly. 
 
    &quot;&quot;&quot;</span>
    <span class="s4">global </span><span class="s1">_initialized</span>
    <span class="s1">_check(_lib.Pa_Terminate()</span><span class="s4">, </span><span class="s3">'Error terminating PortAudio'</span><span class="s1">)</span>
    <span class="s1">_initialized -= </span><span class="s5">1</span>


<span class="s4">def </span><span class="s1">_exit_handler():</span>
    <span class="s4">assert </span><span class="s1">_initialized &gt;= </span><span class="s5">0</span>

    <span class="s0"># We cleanup any open streams here since older versions of portaudio don't</span>
    <span class="s0"># manage this (see github issue #1)</span>
    <span class="s4">if </span><span class="s1">_last_callback:</span>
        <span class="s0"># NB: calling stop() first is required; without it portaudio hangs when</span>
        <span class="s0"># calling close()</span>
        <span class="s1">_last_callback.stream.stop()</span>
        <span class="s1">_last_callback.stream.close()</span>

    <span class="s4">while </span><span class="s1">_initialized:</span>
        <span class="s1">_terminate()</span>


<span class="s1">_atexit.register(_exit_handler)</span>
<span class="s1">_initialize()</span>

<span class="s4">if </span><span class="s1">__name__ == </span><span class="s3">'__main__'</span><span class="s1">:</span>
    <span class="s1">print(query_devices())</span>
</pre>
</body>
</html>