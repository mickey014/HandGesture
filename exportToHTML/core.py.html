<html>
<head>
<title>core.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
core.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2018 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">collections</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">namedtuple</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">contextmanager</span>
<span class="s2">from </span><span class="s1">dataclasses </span><span class="s2">import </span><span class="s1">dataclass</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span><span class="s2">, </span><span class="s1">partialmethod</span><span class="s2">, </span><span class="s1">total_ordering</span>
<span class="s2">import </span><span class="s1">gc</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">itertools </span><span class="s2">as </span><span class="s1">it</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">from </span><span class="s1">operator </span><span class="s2">import </span><span class="s1">attrgetter</span>
<span class="s2">import </span><span class="s1">threading</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(Any</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">ClassVar</span><span class="s2">, </span><span class="s1">DefaultDict</span><span class="s2">, </span><span class="s1">Dict</span><span class="s2">, </span><span class="s1">FrozenSet</span><span class="s2">,</span>
                    <span class="s1">Generator</span><span class="s2">, </span><span class="s1">Generic</span><span class="s2">, </span><span class="s1">Hashable</span><span class="s2">, </span><span class="s1">Iterable</span><span class="s2">, </span><span class="s1">Iterator</span><span class="s2">, </span><span class="s1">List</span><span class="s2">,</span>
                    <span class="s1">NamedTuple</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">, </span><span class="s1">Set</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">Type</span><span class="s2">, </span><span class="s1">TypeVar</span><span class="s2">,</span>
                    <span class="s1">Union</span><span class="s2">, </span><span class="s1">cast</span><span class="s2">, </span><span class="s1">overload)</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">weakref </span><span class="s2">import </span><span class="s1">ref</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">dtypes</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">config </span><span class="s2">as </span><span class="s1">jax_config</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">effects</span>
<span class="s2">from </span><span class="s1">jax._src.config </span><span class="s2">import </span><span class="s1">FLAGS</span><span class="s2">, </span><span class="s1">config</span>
<span class="s2">from </span><span class="s1">jax._src.errors </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ConcretizationTypeError</span><span class="s2">, </span><span class="s1">TracerArrayConversionError</span><span class="s2">,</span>
    <span class="s1">TracerIntegerConversionError</span><span class="s2">, </span><span class="s1">UnexpectedTracerError)</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">linear_util </span><span class="s2">as </span><span class="s1">lu</span>

<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">source_info_util</span>
<span class="s2">from </span><span class="s1">jax._src.util </span><span class="s2">import </span><span class="s1">(safe_zip</span><span class="s2">, </span><span class="s1">safe_map</span><span class="s2">, </span><span class="s1">curry</span><span class="s2">, </span><span class="s1">tuple_insert</span><span class="s2">,</span>
                           <span class="s1">tuple_delete</span><span class="s2">, </span><span class="s1">as_hashable_function</span><span class="s2">,</span>
                           <span class="s1">HashableFunction</span><span class="s2">, </span><span class="s1">HashableWrapper</span><span class="s2">, </span><span class="s1">weakref_lru_cache</span><span class="s2">,</span>
                           <span class="s1">partition_list)</span>
<span class="s2">import </span><span class="s1">jax._src.pretty_printer </span><span class="s2">as </span><span class="s1">pp</span>
<span class="s2">from </span><span class="s1">jax._src.lib </span><span class="s2">import </span><span class="s1">jax_jit</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">traceback_util</span>
<span class="s2">from </span><span class="s1">jax._src.typing </span><span class="s2">import </span><span class="s1">Array</span><span class="s2">, </span><span class="s1">DimSize</span><span class="s2">, </span><span class="s1">Shape</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">typing</span>
<span class="s1">traceback_util.register_exclusion(__file__)</span>

<span class="s1">zip</span><span class="s2">, </span><span class="s1">unsafe_zip = safe_zip</span><span class="s2">, </span><span class="s1">zip</span>
<span class="s1">map</span><span class="s2">, </span><span class="s1">unsafe_map = safe_map</span><span class="s2">, </span><span class="s1">map</span>


<span class="s0"># -------------------- jaxprs --------------------</span>

<span class="s1">Effect = effects.Effect</span>
<span class="s1">Effects = effects.Effects</span>
<span class="s1">EffectTypeSet = effects.EffectTypeSet</span>
<span class="s1">no_effects: Effects = effects.no_effects</span>

<span class="s2">class </span><span class="s1">JaxprDebugInfo(NamedTuple):</span>
  <span class="s1">traced_for: str     </span><span class="s0"># e.g. 'jit', 'scan', etc</span>
  <span class="s1">func_src_info: str  </span><span class="s0"># e.g. f'{fun.__name__} at {filename}:{lineno}'</span>
  <span class="s1">arg_names: Tuple[Optional[str]</span><span class="s2">, </span><span class="s1">...]     </span><span class="s0"># e.g. ('args[0]', ... )</span>
  <span class="s1">result_paths: Tuple[Optional[str]</span><span class="s2">, </span><span class="s1">...]  </span><span class="s0"># e.g. ('[0]', '[1]', ...)</span>

<span class="s2">class </span><span class="s1">Jaxpr:</span>
  <span class="s1">__slots__ = [</span><span class="s3">'__weakref__'</span><span class="s2">, </span><span class="s3">'_constvars'</span><span class="s2">, </span><span class="s3">'_invars'</span><span class="s2">, </span><span class="s3">'_outvars'</span><span class="s2">, </span><span class="s3">'_eqns'</span><span class="s2">,</span>
               <span class="s3">'_effects'</span><span class="s2">, </span><span class="s3">'_debug_info'</span><span class="s1">]</span>

  <span class="s1">_constvars: List[Var]</span>
  <span class="s1">_invars: List[Var]</span>
  <span class="s1">_outvars: List[Atom]</span>
  <span class="s1">_eqns: List[JaxprEqn]</span>
  <span class="s1">_effects: Effects</span>
  <span class="s1">_debug_info: Optional[JaxprDebugInfo]</span>

  <span class="s1">constvars = property(</span><span class="s2">lambda </span><span class="s1">self: self._constvars)</span>
  <span class="s1">invars = property(</span><span class="s2">lambda </span><span class="s1">self: self._invars)</span>
  <span class="s1">outvars = property(</span><span class="s2">lambda </span><span class="s1">self: self._outvars)</span>
  <span class="s1">eqns = property(</span><span class="s2">lambda </span><span class="s1">self: self._eqns)</span>
  <span class="s1">effects = property(</span><span class="s2">lambda </span><span class="s1">self: self._effects)</span>
  <span class="s1">debug_info = property(</span><span class="s2">lambda </span><span class="s1">self: self._debug_info)</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">constvars: Sequence[Var]</span><span class="s2">, </span><span class="s1">invars: Sequence[Var]</span><span class="s2">,</span>
               <span class="s1">outvars: Sequence[Atom]</span><span class="s2">, </span><span class="s1">eqns: Sequence[JaxprEqn]</span><span class="s2">,</span>
               <span class="s1">effects: Effects = no_effects</span><span class="s2">,</span>
               <span class="s1">debug_info: Optional[JaxprDebugInfo] = </span><span class="s2">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Args: 
      constvars: list of variables introduced for constants. Array constants are 
        replaced with such variables while scalar constants are kept inline. 
      invars: list of input variables. Together, `constvars` and `invars` are 
        the inputs to the Jaxpr. 
      outvars: list of output atoms. 
      eqns: list of equations. 
      effects: set of effects. The effects on a jaxpr are a superset of the 
        union of the effects for each equation. 
      debug_info: optional JaxprDebugInfo. 
    &quot;&quot;&quot;</span>
    <span class="s1">self._constvars = list(constvars)</span>
    <span class="s1">self._invars = list(invars)</span>
    <span class="s1">self._outvars = list(outvars)</span>
    <span class="s1">self._eqns = list(eqns)</span>
    <span class="s1">self._effects = effects</span>
    <span class="s1">self._debug_info = debug_info</span>
    <span class="s2">assert </span><span class="s1">(</span><span class="s2">not </span><span class="s1">debug_info </span><span class="s2">or </span><span class="s1">len(debug_info.arg_names) == len(invars) </span><span class="s2">and</span>
            <span class="s1">len(debug_info.result_paths) == len(outvars))</span>

  <span class="s2">def </span><span class="s1">__str__(self):</span>
    <span class="s2">return </span><span class="s1">str(pp_jaxpr(self</span><span class="s2">, </span><span class="s1">JaxprPpContext()</span><span class="s2">, </span><span class="s1">JaxprPpSettings()))</span>
  <span class="s1">__repr__ = __str__</span>

  <span class="s2">def </span><span class="s1">pretty_print(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">source_info=</span><span class="s2">False, </span><span class="s1">print_shapes=</span><span class="s2">True,</span>
                   <span class="s1">custom_pp_eqn_rules=</span><span class="s2">True, </span><span class="s1">name_stack=</span><span class="s2">False,</span>
                   <span class="s1">print_effects: bool = </span><span class="s2">False, </span><span class="s1">**kw):</span>
    <span class="s1">doc = pp_jaxpr(self</span><span class="s2">, </span><span class="s1">JaxprPpContext()</span><span class="s2">,</span>
                   <span class="s1">JaxprPpSettings(source_info=source_info</span><span class="s2">,</span>
                                   <span class="s1">print_shapes=print_shapes</span><span class="s2">,</span>
                                   <span class="s1">custom_pp_eqn_rules=custom_pp_eqn_rules</span><span class="s2">,</span>
                                   <span class="s1">name_stack=name_stack</span><span class="s2">,</span>
                                   <span class="s1">print_effects=print_effects))</span>
    <span class="s2">return </span><span class="s1">doc.format(**kw)</span>

  <span class="s2">def </span><span class="s1">_repr_pretty_(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">cycle):</span>
    <span class="s2">return </span><span class="s1">p.text(self.pretty_print(use_color=</span><span class="s2">True</span><span class="s1">))</span>

  <span class="s2">def </span><span class="s1">replace(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">constvars=</span><span class="s2">None, </span><span class="s1">invars=</span><span class="s2">None, </span><span class="s1">outvars=</span><span class="s2">None, </span><span class="s1">eqns=</span><span class="s2">None,</span>
              <span class="s1">effects=</span><span class="s2">None, </span><span class="s1">debug_info=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">constvars = self.constvars </span><span class="s2">if </span><span class="s1">constvars </span><span class="s2">is None else </span><span class="s1">constvars</span>
    <span class="s1">invars =  self.invars </span><span class="s2">if </span><span class="s1">invars </span><span class="s2">is None else </span><span class="s1">invars</span>
    <span class="s1">outvars = self.outvars </span><span class="s2">if </span><span class="s1">outvars </span><span class="s2">is None else </span><span class="s1">outvars</span>
    <span class="s1">eqns = self.eqns </span><span class="s2">if </span><span class="s1">eqns </span><span class="s2">is None else </span><span class="s1">eqns</span>
    <span class="s1">effects = self.effects </span><span class="s2">if </span><span class="s1">effects </span><span class="s2">is None else </span><span class="s1">effects</span>
    <span class="s2">return </span><span class="s1">Jaxpr(constvars=constvars</span><span class="s2">, </span><span class="s1">invars=invars</span><span class="s2">, </span><span class="s1">outvars=outvars</span><span class="s2">, </span><span class="s1">eqns=eqns</span><span class="s2">,</span>
                 <span class="s1">effects=effects</span><span class="s2">, </span><span class="s1">debug_info=debug_info)</span>

<span class="s2">def </span><span class="s1">join_effects(*effects: Effects) -&gt; Effects:</span>
  <span class="s2">return </span><span class="s1">set.union(*effects) </span><span class="s2">if </span><span class="s1">effects </span><span class="s2">else </span><span class="s1">no_effects</span>

<span class="s2">def </span><span class="s1">jaxprs_in_params(params) -&gt; Iterator[Jaxpr]:</span>
  <span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">params.values():</span>
    <span class="s1">vals = val </span><span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">tuple) </span><span class="s2">else </span><span class="s1">(val</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vals:</span>
      <span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">Jaxpr):</span>
        <span class="s2">yield </span><span class="s1">v</span>
      <span class="s2">elif </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">ClosedJaxpr):</span>
        <span class="s2">yield </span><span class="s1">v.jaxpr</span>


<span class="s2">def </span><span class="s1">subjaxprs(jaxpr: Jaxpr) -&gt; Iterator[Jaxpr]:</span>
  <span class="s4">&quot;&quot;&quot;Generator for all subjaxprs found in the params of jaxpr.eqns. 
 
  Does not descend recursively into the found subjaxprs. 
  &quot;&quot;&quot;</span>
  <span class="s2">for </span><span class="s1">eqn </span><span class="s2">in </span><span class="s1">jaxpr.eqns:</span>
    <span class="s2">yield from </span><span class="s1">jaxprs_in_params(eqn.params)</span>


<span class="s2">class </span><span class="s1">ClosedJaxpr:</span>
  <span class="s1">__slots__ = [</span><span class="s3">'__weakref__'</span><span class="s2">, </span><span class="s3">'_jaxpr'</span><span class="s2">, </span><span class="s3">'_consts'</span><span class="s1">]</span>

  <span class="s1">_jaxpr: Jaxpr</span>
  <span class="s1">_consts: List[Any]</span>

  <span class="s1">jaxpr = property(</span><span class="s2">lambda </span><span class="s1">self: self._jaxpr)</span>
  <span class="s1">consts = property(</span><span class="s2">lambda </span><span class="s1">self: self._consts)</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">jaxpr: Jaxpr</span><span class="s2">, </span><span class="s1">consts: Sequence):</span>
    <span class="s2">assert </span><span class="s1">len(consts) == len(jaxpr.constvars)</span>
    <span class="s0"># assert not any(isinstance(c, Tracer) for c in consts)  # TODO(mattjj): enable</span>
    <span class="s1">self._jaxpr = jaxpr</span>
    <span class="s1">self._consts = list(consts)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">in_avals(self):</span>
    <span class="s2">return </span><span class="s1">[v.aval </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.jaxpr.invars]</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">out_avals(self):</span>
    <span class="s2">return </span><span class="s1">[v.aval </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.jaxpr.outvars]</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">literals(self):</span>
    <span class="s2">return </span><span class="s1">self.consts  </span><span class="s0"># backwards compatible alias</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">eqns(self):</span>
    <span class="s2">return </span><span class="s1">self.jaxpr.eqns</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">effects(self) -&gt; Effects:</span>
    <span class="s2">return </span><span class="s1">self.jaxpr.effects</span>

  <span class="s2">def </span><span class="s1">map_jaxpr(self</span><span class="s2">, </span><span class="s1">f):</span>
    <span class="s2">return </span><span class="s1">ClosedJaxpr(f(self.jaxpr)</span><span class="s2">, </span><span class="s1">self.consts)</span>

  <span class="s2">def </span><span class="s1">replace(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">jaxpr=</span><span class="s2">None, </span><span class="s1">consts=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">jaxpr = self.jaxpr </span><span class="s2">if </span><span class="s1">jaxpr </span><span class="s2">is None else </span><span class="s1">jaxpr</span>
    <span class="s1">consts = self.consts </span><span class="s2">if </span><span class="s1">consts </span><span class="s2">is None else </span><span class="s1">consts</span>
    <span class="s2">return </span><span class="s1">ClosedJaxpr(jaxpr</span><span class="s2">, </span><span class="s1">consts)</span>

  <span class="s2">def </span><span class="s1">__str__(self): </span><span class="s2">return </span><span class="s1">str(self.jaxpr)</span>
  <span class="s2">def </span><span class="s1">__repr__(self): </span><span class="s2">return </span><span class="s1">repr(self.jaxpr)</span>

  <span class="s2">def </span><span class="s1">pretty_print(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">source_info=</span><span class="s2">False, </span><span class="s1">print_shapes=</span><span class="s2">True,</span>
                   <span class="s1">name_stack=</span><span class="s2">False, </span><span class="s1">custom_pp_eqn_rules=</span><span class="s2">True, </span><span class="s1">**kw):</span>
    <span class="s1">settings = JaxprPpSettings(source_info=source_info</span><span class="s2">,</span>
                               <span class="s1">print_shapes=print_shapes</span><span class="s2">, </span><span class="s1">name_stack=name_stack</span><span class="s2">,</span>
                               <span class="s1">custom_pp_eqn_rules=custom_pp_eqn_rules)</span>
    <span class="s2">return </span><span class="s1">pp_jaxpr(self.jaxpr</span><span class="s2">, </span><span class="s1">JaxprPpContext()</span><span class="s2">, </span><span class="s1">settings).format(**kw)</span>


  <span class="s2">def </span><span class="s1">_repr_pretty_(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">cycle):</span>
    <span class="s2">return </span><span class="s1">p.text(self.pretty_print(use_color=</span><span class="s2">True</span><span class="s1">))</span>

<span class="s1">@curry</span>
<span class="s2">def </span><span class="s1">jaxpr_as_fun(closed_jaxpr: ClosedJaxpr</span><span class="s2">, </span><span class="s1">*args):</span>
  <span class="s2">return </span><span class="s1">eval_jaxpr(closed_jaxpr.jaxpr</span><span class="s2">, </span><span class="s1">closed_jaxpr.consts</span><span class="s2">, </span><span class="s1">*args)</span>


<span class="s2">class </span><span class="s1">JaxprEqn(NamedTuple):</span>
  <span class="s1">invars: List[Atom]</span>
  <span class="s1">outvars: List[Var]</span>
  <span class="s1">primitive: Primitive</span>
  <span class="s1">params: Dict[str</span><span class="s2">, </span><span class="s1">Any]</span>
  <span class="s1">effects: Effects</span>
  <span class="s1">source_info: source_info_util.SourceInfo</span>

  <span class="s2">def </span><span class="s1">__repr__(self):</span>
    <span class="s2">return </span><span class="s1">str(pp_eqn(self</span><span class="s2">, </span><span class="s1">JaxprPpContext()</span><span class="s2">, </span><span class="s1">JaxprPpSettings())).rstrip()</span>

  <span class="s2">def </span><span class="s1">replace(</span>
      <span class="s1">self</span><span class="s2">,</span>
      <span class="s1">invars: Optional[List[Atom]] = </span><span class="s2">None,</span>
      <span class="s1">outvars: Optional[List[Var]] = </span><span class="s2">None,</span>
      <span class="s1">primitive: Optional[Primitive] = </span><span class="s2">None,</span>
      <span class="s1">params: Optional[Dict[str</span><span class="s2">, </span><span class="s1">Any]] = </span><span class="s2">None,</span>
      <span class="s1">effects: Optional[Effects] = </span><span class="s2">None,</span>
      <span class="s1">source_info: Optional[source_info_util.SourceInfo] = </span><span class="s2">None,</span>
  <span class="s1">):</span>
    <span class="s0"># It is slightly faster to rebuild the tuple directly than to call _replace.</span>
    <span class="s2">return </span><span class="s1">JaxprEqn(</span>
      <span class="s1">self.invars </span><span class="s2">if </span><span class="s1">invars </span><span class="s2">is None else </span><span class="s1">invars</span><span class="s2">,</span>
      <span class="s1">self.outvars </span><span class="s2">if </span><span class="s1">outvars </span><span class="s2">is None else </span><span class="s1">outvars</span><span class="s2">,</span>
      <span class="s1">self.primitive </span><span class="s2">if </span><span class="s1">primitive </span><span class="s2">is None else </span><span class="s1">primitive</span><span class="s2">,</span>
      <span class="s1">self.params </span><span class="s2">if </span><span class="s1">params </span><span class="s2">is None else </span><span class="s1">params</span><span class="s2">,</span>
      <span class="s1">self.effects </span><span class="s2">if </span><span class="s1">effects </span><span class="s2">is None else </span><span class="s1">effects</span><span class="s2">,</span>
      <span class="s1">self.source_info </span><span class="s2">if </span><span class="s1">source_info </span><span class="s2">is None else </span><span class="s1">source_info</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s0"># TODO(mattjj): call typecheck rules here, so we don't form bad eqns</span>
<span class="s2">def </span><span class="s1">new_jaxpr_eqn(invars</span><span class="s2">, </span><span class="s1">outvars</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">effects</span><span class="s2">, </span><span class="s1">source_info=</span><span class="s2">None</span><span class="s1">):</span>
  <span class="s1">source_info = source_info </span><span class="s2">or </span><span class="s1">source_info_util.new_source_info()</span>
  <span class="s2">if </span><span class="s1">config.jax_enable_checks:</span>
    <span class="s2">assert </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">(Var</span><span class="s2">, </span><span class="s1">Literal)) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in  </span><span class="s1">invars)</span>
    <span class="s2">assert </span><span class="s1">all(isinstance(v</span><span class="s2">,  </span><span class="s1">Var)           </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">outvars)</span>
  <span class="s2">return </span><span class="s1">JaxprEqn(invars</span><span class="s2">, </span><span class="s1">outvars</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">effects</span><span class="s2">, </span><span class="s1">source_info)</span>

<span class="s1">@total_ordering</span>
<span class="s2">class </span><span class="s1">Var:</span>
  <span class="s1">__slots__ = [</span><span class="s3">&quot;count&quot;</span><span class="s2">, </span><span class="s3">&quot;suffix&quot;</span><span class="s2">, </span><span class="s3">&quot;aval&quot;</span><span class="s1">]</span>

  <span class="s1">count: int</span>
  <span class="s1">suffix: str</span>
  <span class="s1">aval: AbstractValue</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">count: int</span><span class="s2">, </span><span class="s1">suffix: str</span><span class="s2">, </span><span class="s1">aval: AbstractValue):</span>
    <span class="s1">self.count = count</span>
    <span class="s1">self.suffix = suffix</span>
    <span class="s1">self.aval = raise_to_shaped(aval)</span>

  <span class="s2">def </span><span class="s1">__lt__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">Var):</span>
      <span class="s2">return </span><span class="s1">NotImplemented</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">(self.count</span><span class="s2">, </span><span class="s1">self.suffix) &lt; (other.count</span><span class="s2">, </span><span class="s1">other.suffix)</span>

  <span class="s2">def </span><span class="s1">__repr__(self):</span>
    <span class="s2">return </span><span class="s1">_encode_digits_alphabetic(self.count) + self.suffix</span>

<span class="s2">def </span><span class="s1">_encode_digits_alphabetic(n):</span>
  <span class="s2">if </span><span class="s1">n == -</span><span class="s5">1</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s3">'*'</span>
  <span class="s1">s = </span><span class="s3">''</span>
  <span class="s2">while </span><span class="s1">len(s) == </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">n:</span>
    <span class="s1">n</span><span class="s2">, </span><span class="s1">i = n // </span><span class="s5">26</span><span class="s2">, </span><span class="s1">n % </span><span class="s5">26</span>
    <span class="s1">s = chr(</span><span class="s5">97 </span><span class="s1">+ i % </span><span class="s5">26</span><span class="s1">) + s</span>
  <span class="s2">return </span><span class="s1">s</span>

<span class="s2">def </span><span class="s1">_jaxpr_vars(jaxpr):</span>
  <span class="s2">return </span><span class="s1">it.chain(</span>
      <span class="s1">jaxpr.invars</span><span class="s2">, </span><span class="s1">jaxpr.constvars</span><span class="s2">,</span>
      <span class="s1">(v </span><span class="s2">for </span><span class="s1">eqn </span><span class="s2">in </span><span class="s1">jaxpr.eqns </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">eqn.outvars))</span>

<span class="s2">def </span><span class="s1">gensym(jaxprs: Optional[Sequence[Jaxpr]] = </span><span class="s2">None,</span>
           <span class="s1">suffix: str = </span><span class="s3">''</span><span class="s1">) -&gt; Callable[[AbstractValue]</span><span class="s2">, </span><span class="s1">Var]:</span>
  <span class="s4">&quot;&quot;&quot;Produce distinct variables, printed with the optional suffix. 
 
  If `jaxprs` is provided, the variables produced will be distinct from those in 
  any of the given jaxprs. 
  &quot;&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">jaxprs </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">start = </span><span class="s5">0</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">all_vars = it.chain.from_iterable(_jaxpr_vars(j) </span><span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">jaxprs)</span>
    <span class="s1">start = </span><span class="s5">1 </span><span class="s1">+ max((v.count </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">all_vars)</span><span class="s2">, </span><span class="s1">default=-</span><span class="s5">1</span><span class="s1">)</span>
  <span class="s1">counter = it.count(start=start)</span>
  <span class="s2">return lambda </span><span class="s1">aval: Var(next(counter)</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">aval)</span>

<span class="s0"># In a jaxpr, `dropvar` can appear in place of a bound variable to indicate that</span>
<span class="s0"># the assignment is dropped, i.e. that an expression's output value will never</span>
<span class="s0"># be read. In that sense, `dropvar` is not a variable, but it is convenient to</span>
<span class="s0"># treat it as a special case of one. Its `aval` is similarly inexact.</span>
<span class="s2">class </span><span class="s1">DropVar(Var):</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">aval: AbstractValue):</span>
    <span class="s1">super().__init__(-</span><span class="s5">1</span><span class="s2">, </span><span class="s3">''</span><span class="s2">, </span><span class="s1">aval)</span>
  <span class="s2">def </span><span class="s1">__repr__(self): </span><span class="s2">return </span><span class="s3">'_'</span>

<span class="s2">class </span><span class="s1">Literal:</span>
  <span class="s1">__slots__ = [</span><span class="s3">&quot;val&quot;</span><span class="s2">, </span><span class="s3">&quot;aval&quot;</span><span class="s2">, </span><span class="s3">&quot;hash&quot;</span><span class="s1">]</span>

  <span class="s1">val: Any</span>
  <span class="s1">aval: AbstractValue</span>
  <span class="s1">hash: Optional[int]</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">aval):</span>
    <span class="s1">self.val = val</span>
    <span class="s1">self.aval = aval</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s1">self.hash = hash(val)</span>
    <span class="s2">except </span><span class="s1">TypeError:</span>
      <span class="s2">if </span><span class="s1">type(val) </span><span class="s2">in </span><span class="s1">literalable_types:</span>
        <span class="s2">try</span><span class="s1">:</span>
          <span class="s1">self.hash = hash((val.item()</span><span class="s2">, </span><span class="s1">val.dtype))</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">AttributeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
          <span class="s1">self.hash = </span><span class="s2">None</span>

  <span class="s1">__hash__ = </span><span class="s2">None  </span><span class="s0"># type: ignore</span>

  <span class="s2">def </span><span class="s1">__repr__(self):</span>
    <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">'hash'</span><span class="s1">):</span>
      <span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">self.val</span><span class="s2">}</span><span class="s3">'</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s3">f'Literal(val=</span><span class="s2">{</span><span class="s1">self.val</span><span class="s2">}</span><span class="s3">)'</span>

<span class="s1">literalable_types: Set[type] = set()</span>

<span class="s1">Atom = Union[Var</span><span class="s2">, </span><span class="s1">Literal]</span>

<span class="s2">class </span><span class="s1">Primitive:</span>
  <span class="s1">name: str</span>
  <span class="s0"># set for multi-output primitives.</span>
  <span class="s1">multiple_results: bool = </span><span class="s2">False</span>
  <span class="s0"># set for call primitives processed in final style.</span>
  <span class="s1">call_primitive: bool = </span><span class="s2">False</span>
  <span class="s0"># set for map primitives processed in final style.</span>
  <span class="s1">map_primitive: bool = </span><span class="s2">False</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name: str):</span>
    <span class="s1">self.name = name</span>

  <span class="s2">def </span><span class="s1">__repr__(self):</span>
    <span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">}</span><span class="s3">'</span>

  <span class="s2">def </span><span class="s1">bind(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**params):</span>
    <span class="s2">assert </span><span class="s1">(</span><span class="s2">not </span><span class="s1">config.jax_enable_checks </span><span class="s2">or</span>
            <span class="s1">all(isinstance(arg</span><span class="s2">, </span><span class="s1">Tracer) </span><span class="s2">or </span><span class="s1">valid_jaxtype(arg) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args))</span><span class="s2">, </span><span class="s1">args</span>
    <span class="s2">return </span><span class="s1">self.bind_with_trace(find_top_trace(args)</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">params)</span>

  <span class="s2">def </span><span class="s1">bind_with_trace(self</span><span class="s2">, </span><span class="s1">trace</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s1">out = trace.process_primitive(self</span><span class="s2">, </span><span class="s1">map(trace.full_raise</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">, </span><span class="s1">params)</span>
    <span class="s2">return </span><span class="s1">map(full_lower</span><span class="s2">, </span><span class="s1">out) </span><span class="s2">if </span><span class="s1">self.multiple_results </span><span class="s2">else </span><span class="s1">full_lower(out)</span>

  <span class="s2">def </span><span class="s1">def_impl(self</span><span class="s2">, </span><span class="s1">impl):</span>
    <span class="s1">self.impl = impl</span>
    <span class="s2">return </span><span class="s1">impl</span>

  <span class="s2">def </span><span class="s1">def_abstract_eval(self</span><span class="s2">, </span><span class="s1">abstract_eval):</span>
    <span class="s1">self.abstract_eval = _effect_free_abstract_eval(abstract_eval)  </span><span class="s0"># type: ignore[assignment]</span>
    <span class="s2">return </span><span class="s1">abstract_eval</span>

  <span class="s2">def </span><span class="s1">def_effectful_abstract_eval(self</span><span class="s2">, </span><span class="s1">effectful_abstract_eval):</span>
    <span class="s1">self.abstract_eval = effectful_abstract_eval  </span><span class="s0"># type: ignore[assignment]</span>
    <span class="s2">return </span><span class="s1">effectful_abstract_eval</span>

  <span class="s2">def </span><span class="s1">def_custom_bind(self</span><span class="s2">, </span><span class="s1">bind):</span>
    <span class="s1">self.bind = bind</span>
    <span class="s2">return </span><span class="s1">bind</span>

  <span class="s2">def </span><span class="s1">impl(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**params):</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;Evaluation rule for '{}' not implemented&quot;</span>
                              <span class="s1">.format(self.name))</span>

  <span class="s2">def </span><span class="s1">abstract_eval(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**params):</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;Abstract evaluation for '{}' not implemented&quot;</span>
                              <span class="s1">.format(self.name))</span>

  <span class="s2">def </span><span class="s1">get_bind_params(self</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s2">return </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">params</span>


<span class="s2">def </span><span class="s1">_effect_free_abstract_eval(abstract_eval):</span>
  <span class="s2">def </span><span class="s1">abstract_eval_(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s2">return </span><span class="s1">abstract_eval(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span><span class="s2">, </span><span class="s1">no_effects</span>
  <span class="s2">return </span><span class="s1">abstract_eval_</span>

<span class="s0"># -------------------- lifting --------------------</span>

<span class="s0"># TODO(mattjj): replace this approach with a primitive-keyed table of rules</span>
<span class="s2">def </span><span class="s1">traverse_jaxpr_params(f</span><span class="s2">, </span><span class="s1">params):</span>
  <span class="s4">&quot;&quot;&quot;Applies f to each jaxpr parameter and returns a tuple of returned values.&quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">{name: f(p)</span>
          <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">param </span><span class="s2">in </span><span class="s1">params.items()</span>
          <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">(param </span><span class="s2">if </span><span class="s1">isinstance(param</span><span class="s2">, </span><span class="s1">(tuple</span><span class="s2">, </span><span class="s1">list)) </span><span class="s2">else </span><span class="s1">[param])</span>
          <span class="s2">if </span><span class="s1">type(p) </span><span class="s2">in </span><span class="s1">(Jaxpr</span><span class="s2">, </span><span class="s1">ClosedJaxpr)}</span>


<span class="s2">def </span><span class="s1">eval_jaxpr(jaxpr: Jaxpr</span><span class="s2">, </span><span class="s1">consts</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">propagate_source_info=</span><span class="s2">True</span><span class="s1">):</span>
  <span class="s2">def </span><span class="s1">read(v: Atom) -&gt; Any:</span>
    <span class="s2">return </span><span class="s1">v.val </span><span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">Literal) </span><span class="s2">else </span><span class="s1">env[v]</span>

  <span class="s2">def </span><span class="s1">write(v: Var</span><span class="s2">, </span><span class="s1">val: Any) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">config.jax_enable_checks </span><span class="s2">and not </span><span class="s1">config.jax_dynamic_shapes:</span>
      <span class="s2">assert </span><span class="s1">typecheck(v.aval</span><span class="s2">, </span><span class="s1">val)</span><span class="s2">, </span><span class="s1">(v.aval</span><span class="s2">, </span><span class="s1">val)</span>
    <span class="s1">env[v] = val</span>

  <span class="s1">env: Dict[Var</span><span class="s2">, </span><span class="s1">Any] = {}</span>
  <span class="s1">map(write</span><span class="s2">, </span><span class="s1">jaxpr.constvars</span><span class="s2">, </span><span class="s1">consts)</span>
  <span class="s1">map(write</span><span class="s2">, </span><span class="s1">jaxpr.invars</span><span class="s2">, </span><span class="s1">args)</span>
  <span class="s2">for </span><span class="s1">eqn </span><span class="s2">in </span><span class="s1">jaxpr.eqns:</span>
    <span class="s1">subfuns</span><span class="s2">, </span><span class="s1">bind_params = eqn.primitive.get_bind_params(eqn.params)</span>
    <span class="s1">name_stack = source_info_util.current_name_stack() + eqn.source_info.name_stack</span>
    <span class="s1">traceback = eqn.source_info.traceback </span><span class="s2">if </span><span class="s1">propagate_source_info </span><span class="s2">else None</span>
    <span class="s2">with </span><span class="s1">source_info_util.user_context(traceback</span><span class="s2">, </span><span class="s1">name_stack=name_stack):</span>
      <span class="s1">ans = eqn.primitive.bind(*subfuns</span><span class="s2">, </span><span class="s1">*map(read</span><span class="s2">, </span><span class="s1">eqn.invars)</span><span class="s2">, </span><span class="s1">**bind_params)</span>
    <span class="s2">if </span><span class="s1">eqn.primitive.multiple_results:</span>
      <span class="s1">map(write</span><span class="s2">, </span><span class="s1">eqn.outvars</span><span class="s2">, </span><span class="s1">ans)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">write(eqn.outvars[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ans)</span>
  <span class="s2">return </span><span class="s1">map(read</span><span class="s2">, </span><span class="s1">jaxpr.outvars)</span>


<span class="s0"># -------------------- tracing --------------------</span>

<span class="s1">TracerType = TypeVar(</span><span class="s3">'TracerType'</span><span class="s2">, </span><span class="s1">bound=</span><span class="s3">'Tracer'</span><span class="s1">)</span>

<span class="s2">class </span><span class="s1">Trace(Generic[TracerType]):</span>
  <span class="s1">__slots__ = [</span><span class="s3">'main'</span><span class="s2">, </span><span class="s3">'level'</span><span class="s2">, </span><span class="s3">'sublevel'</span><span class="s1">]</span>

  <span class="s1">main: MainTrace</span>
  <span class="s1">level: int</span>
  <span class="s1">sublevel: Sublevel</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">main: MainTrace</span><span class="s2">, </span><span class="s1">sublevel: Sublevel) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s1">self.main = main</span>
    <span class="s1">self.level = main.level</span>
    <span class="s1">self.sublevel = sublevel</span>

  <span class="s2">def </span><span class="s1">full_raise(self</span><span class="s2">, </span><span class="s1">val) -&gt; TracerType:</span>
    <span class="s2">if </span><span class="s1">hasattr(val</span><span class="s2">, </span><span class="s3">&quot;dimension_as_value&quot;</span><span class="s1">):  </span><span class="s0"># Used for shape_poly._DimPolynomial</span>
      <span class="s1">val = val.dimension_as_value()</span>
    <span class="s2">if not </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">Tracer):</span>
      <span class="s2">return </span><span class="s1">self.pure(val)</span>
    <span class="s1">val._assert_live()</span>
    <span class="s1">level = self.level</span>
    <span class="s1">sublevel = self.sublevel</span>
    <span class="s2">if </span><span class="s1">val._trace.main </span><span class="s2">is </span><span class="s1">self.main:</span>
      <span class="s2">if </span><span class="s1">val._trace.sublevel == sublevel:</span>
        <span class="s2">return </span><span class="s1">cast(TracerType</span><span class="s2">, </span><span class="s1">val)</span>
      <span class="s2">elif </span><span class="s1">val._trace.sublevel &lt; sublevel:</span>
        <span class="s2">return </span><span class="s1">self.sublift(val)</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">escaped_tracer_error(</span>
            <span class="s1">val</span><span class="s2">, </span><span class="s3">f&quot;Can't lift sublevels </span><span class="s2">{</span><span class="s1">val._trace.sublevel</span><span class="s2">} </span><span class="s3">to </span><span class="s2">{</span><span class="s1">sublevel</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">val._trace.level &lt; level:</span>
      <span class="s2">if </span><span class="s1">val._trace.sublevel &gt; sublevel:</span>
        <span class="s2">raise </span><span class="s1">escaped_tracer_error(</span>
            <span class="s1">val</span><span class="s2">, </span><span class="s3">f&quot;Incompatible sublevel: </span><span class="s2">{</span><span class="s1">val._trace</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">(level</span><span class="s2">, </span><span class="s1">sublevel)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
      <span class="s2">return </span><span class="s1">self.lift(val)</span>
    <span class="s2">elif </span><span class="s1">val._trace.level &gt; level:</span>
      <span class="s2">raise </span><span class="s1">escaped_tracer_error(</span>
          <span class="s1">val</span><span class="s2">, </span><span class="s3">f&quot;Can't lift level </span><span class="s2">{</span><span class="s1">val</span><span class="s2">} </span><span class="s3">to </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:  </span><span class="s0"># val._trace.level == self.level:</span>
      <span class="s2">raise </span><span class="s1">escaped_tracer_error(</span>
          <span class="s1">val</span><span class="s2">, </span><span class="s3">f&quot;Different traces at same level: </span><span class="s2">{</span><span class="s1">val</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">pure(self</span><span class="s2">, </span><span class="s1">val) -&gt; TracerType:</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;must override&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">lift(self</span><span class="s2">, </span><span class="s1">tracer) -&gt; TracerType:</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;must override&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">sublift(self</span><span class="s2">, </span><span class="s1">tracer) -&gt; TracerType:</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;must override&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">process_primitive(self</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;must override&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">__repr__(self):</span>
    <span class="s2">return </span><span class="s3">'{}(level={}/{})'</span><span class="s1">.format(</span>
        <span class="s1">self.__class__.__name__</span><span class="s2">, </span><span class="s1">self.level</span><span class="s2">, </span><span class="s1">self.sublevel)</span>

  <span class="s2">def </span><span class="s1">process_call(self</span><span class="s2">, </span><span class="s1">call_primitive</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s1">msg = (</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(self)</span><span class="s2">} </span><span class="s3">must override process_call to handle call-like &quot;</span>
           <span class="s3">&quot;primitives&quot;</span><span class="s1">)</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(msg)</span>

  <span class="s2">def </span><span class="s1">process_map(self</span><span class="s2">, </span><span class="s1">map_primitive</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s1">msg = (</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(self)</span><span class="s2">} </span><span class="s3">must override process_map to handle map-like &quot;</span>
           <span class="s3">&quot;primitives&quot;</span><span class="s1">)</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(msg)</span>

  <span class="s2">def </span><span class="s1">process_custom_jvp_call(self</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">jvp</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
                              <span class="s1">symbolic_zeros):</span>
    <span class="s1">msg = (</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(self)</span><span class="s2">} </span><span class="s3">must override process_custom_jvp_call &quot;</span>
           <span class="s3">&quot;to handle custom_jvp primitives&quot;</span><span class="s1">)</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(msg)</span>

  <span class="s2">def </span><span class="s1">process_custom_transpose(self</span><span class="s2">, </span><span class="s1">prim</span><span class="s2">, </span><span class="s1">call</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">**params):</span>
    <span class="s1">msg = (</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(self)</span><span class="s2">} </span><span class="s3">must override process_custom_transpose &quot;</span>
           <span class="s3">&quot;to handle custom_transpose_call primitives&quot;</span><span class="s1">)</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(msg)</span>

  <span class="s2">def </span><span class="s1">process_custom_vjp_call(self</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">fwd</span><span class="s2">, </span><span class="s1">bwd</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">,</span>
                              <span class="s1">out_trees</span><span class="s2">, </span><span class="s1">symbolic_zeros):</span>
    <span class="s1">msg = (</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(self)</span><span class="s2">} </span><span class="s3">must override process_custom_vjp_call &quot;</span>
           <span class="s3">&quot;to handle custom_vjp primitives&quot;</span><span class="s1">)</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(msg)</span>


<span class="s2">def </span><span class="s1">raise_as_much_as_possible(tracer) -&gt; Tracer:</span>
  <span class="s0"># Find effective bottom of trace stack (highest dynamic Trace on the stack).</span>
  <span class="s1">trace_stack = thread_local_state.trace_state.trace_stack.stack</span>
  <span class="s1">idx = next(i </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">m </span><span class="s2">in </span><span class="s1">enumerate(trace_stack) </span><span class="s2">if </span><span class="s1">m </span><span class="s2">is</span>
             <span class="s1">thread_local_state.trace_state.trace_stack.dynamic)</span>

  <span class="s0"># Only pay attention to effective part of trace stack.</span>
  <span class="s1">trace_stack = trace_stack[idx:]</span>

  <span class="s0"># Lift tracer into everything in the effective stack higher than its level</span>
  <span class="s2">for </span><span class="s1">trace </span><span class="s2">in </span><span class="s1">trace_stack:</span>
    <span class="s1">trace = trace.with_cur_sublevel()</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">isinstance(tracer</span><span class="s2">, </span><span class="s1">Tracer) </span><span class="s2">or </span><span class="s1">tracer._trace.level &lt; trace.level):</span>
      <span class="s1">tracer = trace.full_raise(tracer)</span>

  <span class="s2">return </span><span class="s1">tracer</span>


<span class="s2">def </span><span class="s1">escaped_tracer_error(tracer</span><span class="s2">, </span><span class="s1">detail=</span><span class="s2">None</span><span class="s1">):</span>
  <span class="s1">num_frames = FLAGS.jax_tracer_error_num_traceback_frames</span>
  <span class="s1">msg = (</span><span class="s3">'Encountered an unexpected tracer. A function transformed by JAX '</span>
         <span class="s3">'had a side effect, allowing for a reference to an intermediate value '</span>
         <span class="s3">f'with type </span><span class="s2">{</span><span class="s1">tracer.aval.str_short()</span><span class="s2">} </span><span class="s3">wrapped in a '</span>
         <span class="s3">f'</span><span class="s2">{</span><span class="s1">type(tracer).__name__</span><span class="s2">} </span><span class="s3">to escape the scope of the transformation.</span><span class="s2">\n</span><span class="s3">'</span>
         <span class="s3">'JAX transformations require that functions explicitly return their '</span>
         <span class="s3">'outputs, and disallow saving intermediate values to global state.'</span><span class="s1">)</span>
  <span class="s1">dbg = getattr(tracer</span><span class="s2">, </span><span class="s3">'_debug_info'</span><span class="s2">, None</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s1">dbg </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s1">msg += (</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">The function being traced when the value leaked was '</span>
            <span class="s3">f'</span><span class="s2">{</span><span class="s1">dbg.func_src_info</span><span class="s2">} </span><span class="s3">traced for </span><span class="s2">{</span><span class="s1">dbg.traced_for</span><span class="s2">}</span><span class="s3">.'</span><span class="s1">)</span>
  <span class="s1">line_info = getattr(tracer</span><span class="s2">, </span><span class="s3">'_line_info'</span><span class="s2">, None</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s1">line_info </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s1">divider = </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'-'</span><span class="s1">*</span><span class="s5">30 </span><span class="s1">+ </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span>
    <span class="s1">msg += divider</span>
    <span class="s1">msg += (</span><span class="s3">'The leaked intermediate value was created on line '</span>
            <span class="s3">f'</span><span class="s2">{</span><span class="s1">source_info_util.summarize(line_info)</span><span class="s2">}</span><span class="s3">. '</span><span class="s1">)</span>
    <span class="s1">msg += divider</span>
    <span class="s2">if </span><span class="s1">num_frames &gt; </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">msg += (</span><span class="s3">f'When the value was created, the final </span><span class="s2">{</span><span class="s1">num_frames</span><span class="s2">} </span><span class="s3">stack '</span>
              <span class="s3">'frames (most recent last) excluding JAX-internal frames were:'</span><span class="s1">)</span>
      <span class="s1">msg += divider + source_info_util.summarize(</span>
          <span class="s1">line_info</span><span class="s2">, </span><span class="s1">num_frames=num_frames) + divider</span>
  <span class="s1">msg += (</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">To catch the leak earlier, try setting the environment variable '</span>
          <span class="s3">'JAX_CHECK_TRACER_LEAKS or using the `jax.checking_leaks` context '</span>
          <span class="s3">'manager.'</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s1">detail:</span>
    <span class="s1">msg += </span><span class="s3">f'Detail: </span><span class="s2">{</span><span class="s1">detail</span><span class="s2">}</span><span class="s3">'</span>
  <span class="s2">return </span><span class="s1">UnexpectedTracerError(msg)</span>


<span class="s2">class </span><span class="s1">Tracer(typing.Array):</span>
  <span class="s1">__array_priority__ = </span><span class="s5">1000</span>
  <span class="s1">__slots__ = [</span><span class="s3">'_trace'</span><span class="s2">, </span><span class="s3">'_line_info'</span><span class="s1">]</span>

  <span class="s2">def </span><span class="s1">__array__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw):</span>
    <span class="s2">raise </span><span class="s1">TracerArrayConversionError(self)</span>

  <span class="s2">def </span><span class="s1">__dlpack__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The __dlpack__() method was called on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">__index__(self):</span>
    <span class="s2">raise </span><span class="s1">TracerIntegerConversionError(self)</span>

  <span class="s2">def </span><span class="s1">tolist(self):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The tolist() method was called on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">tobytes(self</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;C&quot;</span><span class="s1">):</span>
    <span class="s2">del </span><span class="s1">order</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The tobytes() method was called on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">trace: Trace):</span>
    <span class="s1">self._trace = trace</span>

  <span class="s2">def </span><span class="s1">__iter__(self):</span>
    <span class="s2">return </span><span class="s1">iter(self.aval._iter(self))</span>

  <span class="s2">def </span><span class="s1">__reversed__(self):</span>
    <span class="s2">return </span><span class="s1">iter(self[::-</span><span class="s5">1</span><span class="s1">])</span>

  <span class="s2">def </span><span class="s1">__len__(self):</span>
    <span class="s2">return </span><span class="s1">self.aval._len(self)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">sharding(self):</span>
    <span class="s0"># This attribute is part of the jax.Array API, but only defined on concrete arrays.</span>
    <span class="s0"># Raising a ConcretizationTypeError would make sense, but for backward compatibility</span>
    <span class="s0"># we raise an AttributeError so that hasattr() and getattr() work as expected.</span>
    <span class="s2">raise </span><span class="s1">AttributeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The 'sharding' attribute is not available on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">addressable_shards(self):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The 'addressable_shards' attribute is not available on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">at(self):</span>
    <span class="s2">return </span><span class="s1">self.aval.at.fget(self)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">aval(self):</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;must override&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">_assert_live(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">pass  </span><span class="s0"># Override for liveness checking</span>

  <span class="s2">def </span><span class="s1">get_referent(self) -&gt; Any:</span>
    <span class="s2">return </span><span class="s1">self  </span><span class="s0"># Override for object equivalence checking</span>

  <span class="s2">def </span><span class="s1">__bool__(self): </span><span class="s2">return </span><span class="s1">self.aval._bool(self)</span>
  <span class="s2">def </span><span class="s1">__int__(self): </span><span class="s2">return </span><span class="s1">self.aval._int(self)</span>
  <span class="s2">def </span><span class="s1">__hex__(self): </span><span class="s2">return </span><span class="s1">self.aval._hex(self)</span>
  <span class="s2">def </span><span class="s1">__oct__(self): </span><span class="s2">return </span><span class="s1">self.aval._oct(self)</span>
  <span class="s2">def </span><span class="s1">__float__(self): </span><span class="s2">return </span><span class="s1">self.aval._float(self)</span>
  <span class="s2">def </span><span class="s1">__complex__(self): </span><span class="s2">return </span><span class="s1">self.aval._complex(self)</span>

  <span class="s0"># raises a useful error on attempts to pickle a Tracer.</span>
  <span class="s2">def </span><span class="s1">__reduce__(self):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(</span>
      <span class="s1">self</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;The error occurred in the __reduce__ method, which may &quot;</span>
             <span class="s3">&quot;indicate an attempt to serialize/pickle a traced value.&quot;</span><span class="s1">))</span>

  <span class="s0"># raises the better error message from ShapedArray</span>
  <span class="s2">def </span><span class="s1">__setitem__(self</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">val): </span><span class="s2">return </span><span class="s1">self.aval._setitem(self</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">val)</span>

  <span class="s0"># NumPy also only looks up special methods on classes.</span>
  <span class="s2">def </span><span class="s1">__array_module__(self</span><span class="s2">, </span><span class="s1">types): </span><span class="s2">return </span><span class="s1">self.aval._array_module(self</span><span class="s2">, </span><span class="s1">types)</span>

  <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name):</span>
    <span class="s0"># if the aval property raises an AttributeError, gets caught here</span>
    <span class="s2">assert not </span><span class="s1">config.jax_enable_checks </span><span class="s2">or </span><span class="s1">name != </span><span class="s3">&quot;aval&quot;</span>

    <span class="s2">try</span><span class="s1">:</span>
      <span class="s1">attr = getattr(self.aval</span><span class="s2">, </span><span class="s1">name)</span>
    <span class="s2">except </span><span class="s1">AttributeError </span><span class="s2">as </span><span class="s1">err:</span>
      <span class="s2">raise </span><span class="s1">AttributeError(</span>
          <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self.__class__.__name__</span><span class="s2">} </span><span class="s3">has no attribute </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">&quot;</span>
      <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">t = type(attr)</span>
      <span class="s2">if </span><span class="s1">t </span><span class="s2">is </span><span class="s1">aval_property:</span>
        <span class="s2">return </span><span class="s1">attr.fget(self)</span>
      <span class="s2">elif </span><span class="s1">t </span><span class="s2">is </span><span class="s1">aval_method:</span>
        <span class="s2">return </span><span class="s1">types.MethodType(attr.fun</span><span class="s2">, </span><span class="s1">self)</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">attr</span>

  <span class="s2">def </span><span class="s1">_pretty_print(self):</span>
    <span class="s1">base = pp.text(</span><span class="s3">f'Traced&lt;</span><span class="s2">{</span><span class="s1">self.aval</span><span class="s2">}</span><span class="s3">&gt;with&lt;</span><span class="s2">{</span><span class="s1">self._trace</span><span class="s2">}</span><span class="s3">&gt;'</span><span class="s1">)</span>
    <span class="s1">contents = [(name</span><span class="s2">, </span><span class="s1">attr._pretty_print() </span><span class="s2">if </span><span class="s1">isinstance(attr</span><span class="s2">, </span><span class="s1">Tracer)</span>
                 <span class="s2">else </span><span class="s1">pp.text(repr(attr))) </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">self._contents()]</span>
    <span class="s2">if </span><span class="s1">contents:</span>
      <span class="s1">base = pp.group(pp.nest(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">pp.concat([</span>
        <span class="s1">base</span><span class="s2">, </span><span class="s1">pp.text(</span><span class="s3">' with'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">pp.brk()</span><span class="s2">, </span><span class="s1">pp.join(pp.brk()</span><span class="s2">, </span><span class="s1">[</span>
          <span class="s1">pp.text(</span><span class="s3">f'</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">= '</span><span class="s1">) + pp_payload</span>
          <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">pp_payload </span><span class="s2">in </span><span class="s1">contents])</span>
      <span class="s1">])))</span>
    <span class="s2">return </span><span class="s1">base</span>

  <span class="s2">def </span><span class="s1">__repr__(self):</span>
    <span class="s2">return </span><span class="s1">self._pretty_print().format()</span>

  <span class="s2">def </span><span class="s1">_contents(self):</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">[(name</span><span class="s2">, </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">name)) </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.__slots__]</span>
    <span class="s2">except </span><span class="s1">AttributeError:</span>
      <span class="s2">return </span><span class="s1">()</span>

  <span class="s2">def </span><span class="s1">_origin_msg(self) -&gt; str:</span>
    <span class="s2">return </span><span class="s3">&quot;&quot;</span>

  <span class="s0"># Methods that are only valid for materialized arrays</span>
  <span class="s2">def </span><span class="s1">addressable_data(self</span><span class="s2">, </span><span class="s1">index):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The addressable_data() method was called on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">block_until_ready(self):</span>
    <span class="s0"># Raise AttribureError for backward compatibility with hasattr() and getattr() checks.</span>
    <span class="s2">raise </span><span class="s1">AttributeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The 'block_until_ready' method is not available on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">copy_to_host_async(self):</span>
    <span class="s0"># Raise AttribureError for backward compatibility with hasattr() and getattr() checks.</span>
    <span class="s2">raise </span><span class="s1">AttributeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The 'copy_to_host_async' method is not available on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">delete(self):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The delete() method was called on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">device(self):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The device() method was called on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">devices(self):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The devices() method was called on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">global_shards(self):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The global_shards property was called on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">is_deleted(self):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The is_deleted() method was called on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">is_fully_addressable(self):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The is_fully_addressable property was called on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">is_fully_replicated(self):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The is_fully_replicated property was called on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">on_device_size_in_bytes(self):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The on_device_size_in_bytes() method was called on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">traceback(self):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The traceback property was called on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">unsafe_buffer_pointer(self):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(self</span><span class="s2">,</span>
      <span class="s3">f&quot;The unsafe_buffer_pointer() method was called on the JAX Tracer object </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

<span class="s0"># these can be used to set up forwarding of properties and instance methods from</span>
<span class="s0"># Tracer instances to the underlying avals</span>
<span class="s1">aval_property = namedtuple(</span><span class="s3">&quot;aval_property&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;fget&quot;</span><span class="s1">])</span>
<span class="s1">aval_method = namedtuple(</span><span class="s3">&quot;aval_method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;fun&quot;</span><span class="s1">])</span>


<span class="s2">class </span><span class="s1">EvalTrace(Trace):</span>
  <span class="s0"># See comments in https://github.com/google/jax/pull/3370</span>
  <span class="s2">def </span><span class="s1">pure(self</span><span class="s2">, </span><span class="s1">x): </span><span class="s2">return </span><span class="s1">x</span>
  <span class="s1">lift = sublift = pure</span>

  <span class="s2">def </span><span class="s1">process_primitive(self</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s2">return </span><span class="s1">primitive.impl(*tracers</span><span class="s2">, </span><span class="s1">**params)</span>

  <span class="s2">def </span><span class="s1">process_call(self</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s2">return </span><span class="s1">primitive.impl(f</span><span class="s2">, </span><span class="s1">*tracers</span><span class="s2">, </span><span class="s1">**params)</span>
  <span class="s1">process_map = process_call</span>

  <span class="s2">def </span><span class="s1">process_custom_transpose(self</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">call</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">**_):</span>
    <span class="s2">del </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">_</span>
    <span class="s2">with </span><span class="s1">new_sublevel():</span>
      <span class="s2">return </span><span class="s1">call.call_wrapped(*tracers)</span>

  <span class="s2">def </span><span class="s1">process_custom_jvp_call(self</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">jvp</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">**_):</span>
    <span class="s2">del </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">jvp</span><span class="s2">, </span><span class="s1">_  </span><span class="s0"># Unused.</span>
    <span class="s2">with </span><span class="s1">new_sublevel():</span>
      <span class="s2">return </span><span class="s1">fun.call_wrapped(*tracers)</span>

  <span class="s2">def </span><span class="s1">process_custom_vjp_call(self</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">fwd</span><span class="s2">, </span><span class="s1">bwd</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">**_):  </span><span class="s0"># pytype: disable=signature-mismatch</span>
    <span class="s2">del </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">fwd</span><span class="s2">, </span><span class="s1">bwd</span><span class="s2">, </span><span class="s1">_  </span><span class="s0"># Unused.</span>
    <span class="s2">with </span><span class="s1">new_sublevel():</span>
      <span class="s2">return </span><span class="s1">fun.call_wrapped(*tracers)</span>


<span class="s2">class </span><span class="s1">MainTrace:</span>
  <span class="s1">level: int</span>
  <span class="s1">trace_type: Type[Trace]</span>
  <span class="s1">payload: Dict[str</span><span class="s2">, </span><span class="s1">Any]</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">level</span><span class="s2">, </span><span class="s1">trace_type</span><span class="s2">, </span><span class="s1">**payload) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s1">self.level = level</span>
    <span class="s1">self.trace_type = trace_type</span>
    <span class="s1">self.payload = payload</span>

  <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
    <span class="s2">return </span><span class="s3">f&quot;MainTrace(</span><span class="s2">{</span><span class="s1">self.level</span><span class="s2">}</span><span class="s3">,</span><span class="s2">{</span><span class="s1">self.trace_type.__name__</span><span class="s2">}</span><span class="s3">)&quot;</span>

  <span class="s2">def </span><span class="s1">__hash__(self) -&gt; int:</span>
    <span class="s2">return </span><span class="s1">hash((self.level</span><span class="s2">, </span><span class="s1">self.trace_type))</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other: object) -&gt; bool:</span>
    <span class="s2">return </span><span class="s1">(isinstance(other</span><span class="s2">, </span><span class="s1">MainTrace) </span><span class="s2">and</span>
            <span class="s1">self.level == other.level </span><span class="s2">and</span>
            <span class="s1">self.trace_type == other.trace_type </span><span class="s2">and</span>
            <span class="s1">self.payload == other.payload)</span>

  <span class="s2">def </span><span class="s1">with_cur_sublevel(self):</span>
    <span class="s2">return </span><span class="s1">self.trace_type(self</span><span class="s2">, </span><span class="s1">cur_sublevel()</span><span class="s2">, </span><span class="s1">**self.payload)</span>

<span class="s2">class </span><span class="s1">TraceStack:</span>
  <span class="s0"># See comments in https://github.com/google/jax/pull/3370</span>
  <span class="s1">stack: List[MainTrace]</span>
  <span class="s1">dynamic: MainTrace</span>

  <span class="s2">def </span><span class="s1">__init__(self):</span>
    <span class="s1">eval_trace = MainTrace(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">EvalTrace)</span>
    <span class="s1">self.stack = [eval_trace]</span>
    <span class="s1">self.dynamic = eval_trace</span>

  <span class="s2">def </span><span class="s1">next_level(self) -&gt; int:</span>
    <span class="s2">return </span><span class="s1">len(self.stack)</span>

  <span class="s2">def </span><span class="s1">push(self</span><span class="s2">, </span><span class="s1">main_trace: MainTrace) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s1">self.stack.append(main_trace)</span>

  <span class="s2">def </span><span class="s1">pop(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s1">self.stack.pop()</span>

  <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
    <span class="s1">stack_str = map(</span><span class="s3">'  {}</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.format</span><span class="s2">, </span><span class="s1">self.stack[::-</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s2">return </span><span class="s3">f'Trace stack</span><span class="s2">\n{</span><span class="s1">stack_str</span><span class="s2">}\n{</span><span class="s1">self.dynamic</span><span class="s2">}</span><span class="s3">'</span>

  <span class="s2">def </span><span class="s1">copy(self):</span>
    <span class="s1">new = self.__new__(TraceStack)</span>
    <span class="s1">new.stack = self.stack[:]</span>
    <span class="s1">new.dynamic = self.dynamic</span>
    <span class="s2">return </span><span class="s1">new</span>


<span class="s1">@total_ordering</span>
<span class="s2">class </span><span class="s1">Sublevel:</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">level: int):</span>
    <span class="s1">self.level = level</span>

  <span class="s2">def </span><span class="s1">__repr__(self):</span>
    <span class="s2">return </span><span class="s1">str(self.level)</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return </span><span class="s1">type(other) </span><span class="s2">is </span><span class="s1">Sublevel </span><span class="s2">and </span><span class="s1">self.level == other.level</span>

  <span class="s2">def </span><span class="s1">__lt__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return </span><span class="s1">type(other) </span><span class="s2">is </span><span class="s1">Sublevel </span><span class="s2">and </span><span class="s1">self.level &lt; other.level</span>


<span class="s1">AxisEnvFrame = namedtuple(</span><span class="s3">'AxisEnvFrame'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'name'</span><span class="s2">, </span><span class="s3">'size'</span><span class="s2">, </span><span class="s3">'main_trace'</span><span class="s1">])</span>
<span class="s1">AxisName = Hashable</span>

<span class="s1">no_axis_name = object()</span>

<span class="s2">class </span><span class="s1">TraceState:</span>
  <span class="s1">trace_stack: TraceStack</span>
  <span class="s1">substack: List[Sublevel]</span>
  <span class="s1">axis_env: List[AxisEnvFrame]</span>

  <span class="s2">def </span><span class="s1">__init__(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s1">self.trace_stack = TraceStack()</span>
    <span class="s1">self.substack = [Sublevel(</span><span class="s5">0</span><span class="s1">)]</span>
    <span class="s1">self.axis_env = []</span>

  <span class="s2">def </span><span class="s1">copy(self):</span>
    <span class="s1">new = self.__new__(TraceState)</span>
    <span class="s1">new.trace_stack = self.trace_stack.copy()</span>
    <span class="s1">new.substack = self.substack[:]</span>
    <span class="s1">new.axis_env = self.axis_env[:]</span>
    <span class="s2">return </span><span class="s1">new</span>


<span class="s2">def </span><span class="s1">_update_thread_local_jit_state(dynamic):</span>
  <span class="s0"># Copies the MainTrace instance, removing any .debug_info or .jaxpr_stack</span>
  <span class="s0"># fields that should not be kept alive as part of a cache key.</span>
  <span class="s0"># TODO(mattjj): split debug_info and jaxpr_stack out of MainTrace.</span>
  <span class="s0"># TODO(mattjj): add a test that verifies that JIT-ted functions are not kept</span>
  <span class="s0"># alive by the JIT cache, particularly for nested JIT-ted functions.</span>
  <span class="s1">copy = MainTrace(dynamic.level</span><span class="s2">, </span><span class="s1">dynamic.trace_type</span><span class="s2">, </span><span class="s1">**dynamic.payload)</span>
  <span class="s1">jax_config.update_thread_local_jit_state(dynamic_trace_state=copy)</span>


<span class="s0"># The global state of the tracer is accessed by a thread-local object.</span>
<span class="s0"># This allows concurrent tracing in separate threads; passing traced objects</span>
<span class="s0"># between threads is forbidden.</span>
<span class="s2">class </span><span class="s1">ThreadLocalState(threading.local):</span>
  <span class="s2">def </span><span class="s1">__init__(self):</span>
    <span class="s1">self.trace_state = TraceState()</span>

<span class="s1">thread_local_state = ThreadLocalState()</span>


<span class="s2">def </span><span class="s1">_initialize_jax_jit_thread_local_state():</span>
  <span class="s4">&quot;&quot;&quot;Initializes the C++ thread-local context. 
 
  When the user spawns threads, the C++ `jax_jit.thread_local_state` is None. 
  The C++ accessor calls this function if it realizes the thread_local_state 
  is None (which means it's not yet initialized for this thread). 
 
  This function does not live in `config.py`, to prevent circular imports. 
  &quot;&quot;&quot;</span>
  <span class="s1">tls = jax_jit.thread_local_state()</span>
  <span class="s2">if </span><span class="s1">tls.extra_jit_context </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">dynamic = thread_local_state.trace_state.trace_stack.dynamic</span>
    <span class="s1">copy = MainTrace(dynamic.level</span><span class="s2">, </span><span class="s1">dynamic.trace_type</span><span class="s2">, </span><span class="s1">**dynamic.payload)</span>
    <span class="s1">jax_config.update_thread_local_jit_state(dynamic_trace_state=copy)</span>


<span class="s1">jax_jit.set_thread_local_state_initialization_callback(</span>
    <span class="s1">_initialize_jax_jit_thread_local_state)</span>

<span class="s2">def </span><span class="s1">trace_state_clean() -&gt; bool:</span>
  <span class="s1">trace_state = thread_local_state.trace_state</span>
  <span class="s2">return </span><span class="s1">(trace_state.substack == [Sublevel(</span><span class="s5">0</span><span class="s1">)] </span><span class="s2">and</span>
          <span class="s1">trace_state.axis_env == [] </span><span class="s2">and</span>
          <span class="s1">trace_state.trace_stack.stack == [MainTrace(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">EvalTrace)] </span><span class="s2">and</span>
          <span class="s1">trace_state.trace_stack.dynamic == MainTrace(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">EvalTrace))</span>

<span class="s2">def </span><span class="s1">reset_trace_state() -&gt; bool:</span>
  <span class="s4">&quot;&quot;&quot;Resets the global trace state and returns True if it was already clean.&quot;&quot;&quot;</span>
  <span class="s2">if not </span><span class="s1">trace_state_clean():</span>
    <span class="s1">thread_local_state.trace_state.__init__()  </span><span class="s0"># type: ignore</span>
    <span class="s2">return False</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return True</span>

<span class="s2">def </span><span class="s1">cur_sublevel() -&gt; Sublevel:</span>
  <span class="s2">return </span><span class="s1">thread_local_state.trace_state.substack[-</span><span class="s5">1</span><span class="s1">]</span>

<span class="s1">TRACER_LEAK_DEBUGGER_WARNING = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">JAX check_tracer_leaks behavior can trigger false positives when used with a debugger. 
To avoid false positives and silence this warning, you can disable thread tracing using 
the following: 
 
  import threading 
  threading.current_thread().pydev_do_not_trace = True 
&quot;&quot;&quot;</span>

<span class="s2">def </span><span class="s1">maybe_find_leaked_tracers(x: Optional[Union[MainTrace</span><span class="s2">, </span><span class="s1">Sublevel]]</span>
                              <span class="s1">) -&gt; List[Tracer]:</span>
  <span class="s4">&quot;&quot;&quot;Find the leaked tracers holding a reference to the MainTrace or SubLevel. 
 
  It's possible there's none! eg. there's some cases where JAX itself holds a 
  reference to `x` inside of a lambda closure, and no tracers were leaked 
  by the user. In this case an empty list is returned. 
  &quot;&quot;&quot;</span>
  <span class="s2">if not </span><span class="s1">getattr(threading.current_thread()</span><span class="s2">, </span><span class="s3">'pydev_do_not_trace'</span><span class="s2">, True</span><span class="s1">):</span>
    <span class="s1">warnings.warn(TRACER_LEAK_DEBUGGER_WARNING)</span>
  <span class="s0"># Trigger garbage collection to filter out unreachable objects that are alive</span>
  <span class="s0"># only due to cyclical dependencies. (We don't care about unreachable leaked</span>
  <span class="s0"># tracers since they can't interact with user code and cause a problem.)</span>
  <span class="s1">gc.collect()</span>
  <span class="s1">traces = list(filter(</span><span class="s2">lambda </span><span class="s1">x: isinstance(x</span><span class="s2">, </span><span class="s1">Trace)</span><span class="s2">, </span><span class="s1">gc.get_referrers(x)))</span>
  <span class="s1">tracers = list(filter(</span><span class="s2">lambda </span><span class="s1">x: isinstance(x</span><span class="s2">, </span><span class="s1">Tracer)</span><span class="s2">, </span><span class="s1">gc.get_referrers(*traces)))</span>
  <span class="s2">return </span><span class="s1">tracers</span>

<span class="s2">def </span><span class="s1">leaked_tracer_error(name: str</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">tracers: List[Tracer]) -&gt; Exception:</span>
  <span class="s2">assert </span><span class="s1">tracers</span>
  <span class="s1">why = partial(_why_alive</span><span class="s2">, </span><span class="s1">{id(tracers)})</span>
  <span class="s1">msgs = </span><span class="s3">'</span><span class="s2">\n\n</span><span class="s3">'</span><span class="s1">.join(</span><span class="s3">f'</span><span class="s2">{</span><span class="s1">tracers[i]</span><span class="s2">}{</span><span class="s1">tracers[i]._origin_msg()</span><span class="s2">}{</span><span class="s1">why(tracers[i])</span><span class="s2">}</span><span class="s3">'</span>
                     <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(tracers)))</span>
  <span class="s2">return </span><span class="s1">Exception(</span><span class="s3">f'Leaked </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} {</span><span class="s1">t</span><span class="s2">}</span><span class="s3">. Leaked tracer(s):</span><span class="s2">\n\n{</span><span class="s1">msgs</span><span class="s2">}\n</span><span class="s3">'</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">_why_alive(ignore_ids: Set[int]</span><span class="s2">, </span><span class="s1">x: Any) -&gt; str:</span>
  <span class="s1">parents = </span><span class="s2">lambda </span><span class="s1">x: [r </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">gc.get_referrers(x) </span><span class="s2">if </span><span class="s1">id(r) </span><span class="s2">not in </span><span class="s1">ignore_ids]</span>
  <span class="s1">child</span><span class="s2">, </span><span class="s1">lines</span><span class="s2">, </span><span class="s1">seen = x</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">set()</span>
  <span class="s2">while </span><span class="s1">(id(child) </span><span class="s2">not in </span><span class="s1">seen </span><span class="s2">and </span><span class="s1">type(child) </span><span class="s2">is not </span><span class="s1">types.ModuleType</span>
         <span class="s2">and </span><span class="s1">parents(child)):</span>
    <span class="s1">parent = parents(child)[</span><span class="s5">0</span><span class="s1">]  </span><span class="s0"># just pick one parent</span>

    <span class="s0"># For namespaces (like modules and class instances) and closures, the</span>
    <span class="s0"># references may form a simple chain: e.g. instance refers to its own</span>
    <span class="s0"># __dict__ which refers to child, or function refers to its __closure__</span>
    <span class="s0"># which refers to cells which refer to child. In these cases, we can provide</span>
    <span class="s0"># a more intuitive description by collapsing the chain into a single</span>
    <span class="s0"># parent-&gt;child jump. We do that by setting `parent` here to be a</span>
    <span class="s0"># grandparent (or great-grandparent) of `child`, and then handling that case</span>
    <span class="s0"># in _why_alive_container_info. See example:</span>
    <span class="s0">#  https://github.com/google/jax/pull/13022#discussion_r1008456599</span>
    <span class="s0"># To prevent this collapsing behavior, just comment out this code block.</span>
    <span class="s2">if </span><span class="s1">(isinstance(parent</span><span class="s2">, </span><span class="s1">dict) </span><span class="s2">and</span>
        <span class="s1">getattr(parents(parent)[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'__dict__'</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is </span><span class="s1">parents(child)[</span><span class="s5">0</span><span class="s1">]):</span>
      <span class="s1">parent = parents(parent)[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">elif </span><span class="s1">type(parent) </span><span class="s2">is </span><span class="s1">types.CellType:</span>
      <span class="s1">parent = parents(parents(parent)[</span><span class="s5">0</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">line = </span><span class="s3">f'&lt;</span><span class="s2">{</span><span class="s1">type(child).__name__</span><span class="s2">} {</span><span class="s1">id(child)</span><span class="s2">}</span><span class="s3">&gt; is referred to by '</span>
    <span class="s1">lines.append(line + _why_alive_container_info(parent</span><span class="s2">, </span><span class="s1">id(child)))</span>
    <span class="s1">seen.add(id(child))</span>
    <span class="s1">child = parent</span>
  <span class="s2">return </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(lines) </span><span class="s2">if </span><span class="s1">lines </span><span class="s2">else </span><span class="s3">''</span>

<span class="s2">def </span><span class="s1">_why_alive_container_info(container</span><span class="s2">, </span><span class="s1">obj_id) -&gt; str:</span>
  <span class="s1">name = </span><span class="s3">f'&lt;</span><span class="s2">{</span><span class="s1">type(container).__name__</span><span class="s2">} {</span><span class="s1">id(container)</span><span class="s2">}</span><span class="s3">&gt;'</span>
  <span class="s2">if </span><span class="s1">type(container) </span><span class="s2">is </span><span class="s1">types.ModuleType:</span>
    <span class="s1">name = getattr(container</span><span class="s2">, </span><span class="s3">'__name__'</span><span class="s2">, </span><span class="s1">name)</span>
  <span class="s2">if </span><span class="s1">type(container) </span><span class="s2">is </span><span class="s1">types.FunctionType:</span>
    <span class="s1">name_ = getattr(container</span><span class="s2">, </span><span class="s3">'__name__'</span><span class="s2">, </span><span class="s3">'&lt;no-name&gt;'</span><span class="s1">)</span>
    <span class="s1">closure = inspect.getclosurevars(container)</span>
    <span class="s1">keys = [k </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">dict(closure.nonlocals</span><span class="s2">, </span><span class="s1">**closure.globals).items()</span>
            <span class="s2">if </span><span class="s1">id(v) == obj_id]</span>
    <span class="s2">if </span><span class="s1">len(keys) == </span><span class="s5">1</span><span class="s1">: </span><span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">(</span><span class="s2">{</span><span class="s1">name_</span><span class="s2">}</span><span class="s3">) closed-over variable </span><span class="s2">{</span><span class="s1">keys[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">}</span><span class="s3">'</span>
    <span class="s2">elif </span><span class="s1">len(keys) &gt; </span><span class="s5">1</span><span class="s1">: </span><span class="s2">return </span><span class="s1">(</span><span class="s3">f'</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">in closed-over variables ' </span><span class="s1">+</span>
                                <span class="s3">', '</span><span class="s1">.join(map(repr</span><span class="s2">, </span><span class="s1">keys)))</span>
  <span class="s2">if </span><span class="s1">hasattr(container</span><span class="s2">, </span><span class="s3">'__dict__'</span><span class="s1">):</span>
    <span class="s1">keys = [k </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">vars(container) </span><span class="s2">if </span><span class="s1">id(vars(container)[k]) == obj_id]</span>
    <span class="s2">if </span><span class="s1">len(keys) == </span><span class="s5">1</span><span class="s1">: </span><span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">.</span><span class="s2">{</span><span class="s1">str(keys[</span><span class="s5">0</span><span class="s1">])</span><span class="s2">}</span><span class="s3">'</span>
    <span class="s2">elif </span><span class="s1">len(keys) &gt; </span><span class="s5">1</span><span class="s1">: </span><span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">in vars ' </span><span class="s1">+ </span><span class="s3">', '</span><span class="s1">.join(map(repr</span><span class="s2">, </span><span class="s1">keys))</span>
  <span class="s2">if </span><span class="s1">isinstance(container</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
    <span class="s1">idxs = [i </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(container) </span><span class="s2">if </span><span class="s1">id(x) == obj_id]</span>
    <span class="s2">if </span><span class="s1">len(idxs) == </span><span class="s5">1</span><span class="s1">: </span><span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">[</span><span class="s2">{</span><span class="s1">idxs[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">}</span><span class="s3">]'</span>
    <span class="s2">else</span><span class="s1">: </span><span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">at indices ' </span><span class="s1">+ </span><span class="s3">', '</span><span class="s1">.join(map(str</span><span class="s2">, </span><span class="s1">idxs))</span>
  <span class="s2">if </span><span class="s1">isinstance(container</span><span class="s2">, </span><span class="s1">dict):</span>
    <span class="s1">keys = [k </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">container </span><span class="s2">if </span><span class="s1">id(container[k]) == obj_id]</span>
    <span class="s2">if </span><span class="s1">len(keys) == </span><span class="s5">1</span><span class="s1">: </span><span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">[</span><span class="s2">{</span><span class="s1">repr(keys[</span><span class="s5">0</span><span class="s1">])</span><span class="s2">}</span><span class="s3">]'</span>
    <span class="s2">else</span><span class="s1">: </span><span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">at keys ' </span><span class="s1">+ </span><span class="s3">', '</span><span class="s1">.join(map(repr</span><span class="s2">, </span><span class="s1">keys))</span>
  <span class="s2">if </span><span class="s1">isinstance(container</span><span class="s2">, </span><span class="s1">types.ModuleType):</span>
    <span class="s2">return </span><span class="s3">f' named </span><span class="s2">{</span><span class="s1">container.__name__</span><span class="s2">}</span><span class="s3">'</span>
  <span class="s2">return </span><span class="s1">name</span>


<span class="s1">@contextmanager</span>
<span class="s2">def </span><span class="s1">new_main(trace_type: Type[Trace]</span><span class="s2">,</span>
             <span class="s1">dynamic: bool = </span><span class="s2">False,</span>
             <span class="s1">**payload) -&gt; Generator[MainTrace</span><span class="s2">, None, None</span><span class="s1">]:</span>
  <span class="s0"># See comments in https://github.com/google/jax/pull/3370</span>
  <span class="s1">stack = thread_local_state.trace_state.trace_stack</span>
  <span class="s1">level = stack.next_level()</span>
  <span class="s1">main = MainTrace(level</span><span class="s2">, </span><span class="s1">trace_type</span><span class="s2">, </span><span class="s1">**payload)</span>
  <span class="s1">stack.push(main)</span>
  <span class="s2">if </span><span class="s1">dynamic:</span>
    <span class="s1">prev_dynamic</span><span class="s2">, </span><span class="s1">stack.dynamic = stack.dynamic</span><span class="s2">, </span><span class="s1">main</span>
    <span class="s1">_update_thread_local_jit_state(stack.dynamic)</span>

  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">yield </span><span class="s1">main</span>
  <span class="s2">finally</span><span class="s1">:</span>
    <span class="s1">stack.pop()</span>
    <span class="s2">if </span><span class="s1">dynamic:</span>
      <span class="s1">stack.dynamic = prev_dynamic</span>
      <span class="s1">_update_thread_local_jit_state(stack.dynamic)</span>

  <span class="s2">if </span><span class="s1">config.jax_check_tracer_leaks:</span>
    <span class="s1">t = ref(main)</span>
    <span class="s2">del </span><span class="s1">main</span>
    <span class="s2">if </span><span class="s1">t() </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s1">leaked_tracers = maybe_find_leaked_tracers(t())</span>
      <span class="s2">if </span><span class="s1">leaked_tracers: </span><span class="s2">raise </span><span class="s1">leaked_tracer_error(</span><span class="s3">&quot;trace&quot;</span><span class="s2">, </span><span class="s1">t()</span><span class="s2">, </span><span class="s1">leaked_tracers)</span>

<span class="s1">@contextmanager</span>
<span class="s2">def </span><span class="s1">new_base_main(trace_type: Type[Trace]</span><span class="s2">,</span>
                  <span class="s1">**payload) -&gt; Generator[MainTrace</span><span class="s2">, None, None</span><span class="s1">]:</span>
  <span class="s0"># See comments in https://github.com/google/jax/pull/3370</span>
  <span class="s1">stack = thread_local_state.trace_state.trace_stack</span>
  <span class="s1">main = MainTrace(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">trace_type</span><span class="s2">, </span><span class="s1">**payload)</span>
  <span class="s1">prev_dynamic</span><span class="s2">, </span><span class="s1">stack.dynamic = stack.dynamic</span><span class="s2">, </span><span class="s1">main</span>
  <span class="s1">prev_base</span><span class="s2">, </span><span class="s1">stack.stack[</span><span class="s5">0</span><span class="s1">] = stack.stack[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">main</span>
  <span class="s1">_update_thread_local_jit_state(stack.dynamic)</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">yield </span><span class="s1">main</span>
  <span class="s2">finally</span><span class="s1">:</span>
    <span class="s1">stack.dynamic = prev_dynamic</span>
    <span class="s1">stack.stack[</span><span class="s5">0</span><span class="s1">] = prev_base</span>
    <span class="s1">_update_thread_local_jit_state(stack.dynamic)</span>

  <span class="s2">if </span><span class="s1">config.jax_check_tracer_leaks:</span>
    <span class="s1">t = ref(main)</span>
    <span class="s2">del </span><span class="s1">main</span>
    <span class="s2">if </span><span class="s1">t() </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s1">leaked_tracers = maybe_find_leaked_tracers(t())</span>
      <span class="s2">if </span><span class="s1">leaked_tracers: </span><span class="s2">raise </span><span class="s1">leaked_tracer_error(</span><span class="s3">&quot;trace&quot;</span><span class="s2">, </span><span class="s1">t()</span><span class="s2">, </span><span class="s1">leaked_tracers)</span>

<span class="s1">@contextmanager</span>
<span class="s2">def </span><span class="s1">ensure_compile_time_eval():</span>
  <span class="s4">&quot;&quot;&quot;Context manager to ensure evaluation at trace/compile time (or error). 
 
  Some JAX APIs like :func:`jax.jit`` and :func:`jax.lax.scan` involve staging, 
  i.e., delaying the evaluation of numerical expressions (like :mod:`jax.numpy` 
  function applications) so that instead of performing those computations 
  eagerly while evaluating the corresponding Python expressions, their 
  computation is carried out separately, e.g. after optimized compilation. But 
  this delay can be undesirable. For example, numerical values might be needed 
  to evaluate Python control flow and so their evaluation cannot be delayed. As 
  another example, it may be beneficial to ensure compile time evaluation (or 
  &quot;constant folding&quot;) for performance reasons. 
 
  This context manager ensures that JAX computations are evaluated eagerly. If 
  eager evaluation is not possible, a ``ConcretizationError`` is raised. 
 
  Here's a contrived example:: 
 
    import jax 
    import jax.numpy as jnp 
 
    @jax.jit 
    def f(x): 
      with jax.ensure_compile_time_eval(): 
        y = jnp.sin(3.0) 
        z = jnp.sin(y) 
        z_positive = z &gt; 0 
      if z_positive:  # z_positive is usable in Python control flow 
        return jnp.sin(x) 
      else: 
        return jnp.cos(x) 
 
  Here's a real-world example from https://github.com/google/jax/issues/3974:: 
 
    import jax 
    import jax.numpy as jnp 
    from jax import random 
 
    @jax.jit 
    def jax_fn(x): 
      with jax.ensure_compile_time_eval(): 
        y = random.randint(random.PRNGKey(0), (1000,1000), 0, 100) 
      y2 = y @ y 
      x2 = jnp.sum(y2) * x 
      return x2 
 
  A similar behavior can often be achieved simply by 'hoisting' the constant 
  expression out of the corresponding staging API:: 
 
    y = random.randint(random.PRNGKey(0), (1000,1000), 0, 100) 
 
    @jax.jit 
    def jax_fn(x): 
      y2 = y @ y 
      x2 = jnp.sum(y2)*x 
      return x2 
 
  But in some cases it can be more convenient to use this context manager. 
  &quot;&quot;&quot;</span>
  <span class="s2">with </span><span class="s1">new_base_main(EvalTrace):</span>
    <span class="s2">yield</span>
<span class="s1">eval_context = ensure_compile_time_eval  </span><span class="s0"># alias, backward compatibility</span>

<span class="s1">@contextmanager</span>
<span class="s2">def </span><span class="s1">new_sublevel() -&gt; Generator[</span><span class="s2">None, None, None</span><span class="s1">]:</span>
  <span class="s1">sublevel = Sublevel(len(thread_local_state.trace_state.substack))</span>
  <span class="s1">thread_local_state.trace_state.substack.append(sublevel)</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">yield</span>
  <span class="s2">finally</span><span class="s1">:</span>
    <span class="s1">thread_local_state.trace_state.substack.pop()</span>

  <span class="s2">if </span><span class="s1">config.jax_check_tracer_leaks:</span>
    <span class="s1">t = ref(sublevel)</span>
    <span class="s2">del </span><span class="s1">sublevel</span>
    <span class="s2">if </span><span class="s1">t() </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s1">leaked_tracers = maybe_find_leaked_tracers(t())</span>
      <span class="s2">if </span><span class="s1">leaked_tracers:</span>
        <span class="s2">raise </span><span class="s1">leaked_tracer_error(</span><span class="s3">&quot;sublevel&quot;</span><span class="s2">, </span><span class="s1">t()</span><span class="s2">, </span><span class="s1">leaked_tracers)</span>

<span class="s2">def </span><span class="s1">full_lower(val):</span>
  <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">Tracer):</span>
    <span class="s2">return </span><span class="s1">val.full_lower()</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">val</span>

<span class="s2">def </span><span class="s1">find_top_trace(xs) -&gt; Trace:</span>
  <span class="s1">top_tracer = max((x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">xs </span><span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">Tracer))</span><span class="s2">,</span>
                    <span class="s1">default=</span><span class="s2">None, </span><span class="s1">key=attrgetter(</span><span class="s3">'_trace.level'</span><span class="s1">))</span>
  <span class="s2">if </span><span class="s1">top_tracer </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s1">top_tracer._assert_live()</span>
    <span class="s1">top_main = top_tracer._trace.main</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">top_main = </span><span class="s2">None  </span><span class="s0"># type: ignore</span>
  <span class="s1">dynamic = thread_local_state.trace_state.trace_stack.dynamic</span>
  <span class="s1">top_main = (dynamic </span><span class="s2">if </span><span class="s1">top_main </span><span class="s2">is None or </span><span class="s1">dynamic.level &gt; top_main.level</span>
              <span class="s2">else </span><span class="s1">top_main)</span>
  <span class="s2">return </span><span class="s1">top_main.with_cur_sublevel()  </span><span class="s0"># type: ignore</span>

<span class="s2">def </span><span class="s1">get_referent(x: Any) -&gt; Any:</span>
  <span class="s2">return </span><span class="s1">x.get_referent() </span><span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">Tracer) </span><span class="s2">else </span><span class="s1">x</span>

<span class="s2">def </span><span class="s1">same_referent(x: Any</span><span class="s2">, </span><span class="s1">y: Any) -&gt; bool:</span>
  <span class="s2">return </span><span class="s1">get_referent(x) </span><span class="s2">is </span><span class="s1">get_referent(y)</span>

<span class="s2">def </span><span class="s1">dedup_referents(itr: Iterable[Any]) -&gt; List[Any]:</span>
  <span class="s2">return </span><span class="s1">list({HashableWrapper(get_referent(x)):x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">itr}.values())</span>

<span class="s2">def </span><span class="s1">definitely_equal(x</span><span class="s2">, </span><span class="s1">y):</span>
  <span class="s2">return </span><span class="s1">x </span><span class="s2">is </span><span class="s1">y </span><span class="s2">or </span><span class="s1">same_referent(x</span><span class="s2">, </span><span class="s1">y) </span><span class="s2">or </span><span class="s1">symbolic_equal_dim(x</span><span class="s2">, </span><span class="s1">y)</span>


<span class="s0"># -------------------- abstract values --------------------</span>

<span class="s2">class </span><span class="s1">AbstractValue:</span>
  <span class="s1">__slots__: List[str] = []</span>

  <span class="s2">def </span><span class="s1">at_least_vspace(self):</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;must override&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">__repr__(self):</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s1">kv_pairs = (</span><span class="s3">f'</span><span class="s2">{</span><span class="s1">k</span><span class="s2">}</span><span class="s3">=</span><span class="s2">{</span><span class="s1">v</span><span class="s2">}</span><span class="s3">' </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.__dict__.items())</span>
      <span class="s2">return </span><span class="s3">'{}({})'</span><span class="s1">.format(self.__class__.__name__</span><span class="s2">, </span><span class="s3">','</span><span class="s1">.join(kv_pairs))</span>
    <span class="s2">except </span><span class="s1">AttributeError:</span>
      <span class="s2">return </span><span class="s1">self.__class__.__name__</span>

  <span class="s2">def </span><span class="s1">strip_weak_type(self) -&gt; AbstractValue:</span>
    <span class="s2">return </span><span class="s1">self</span>

  <span class="s2">def </span><span class="s1">strip_named_shape(self) -&gt; AbstractValue:</span>
    <span class="s2">return </span><span class="s1">self</span>

  <span class="s2">def </span><span class="s1">join(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;must override&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;must override&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">str_short(self</span><span class="s2">, </span><span class="s1">short_dtypes=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">str(self)</span>


<span class="s0"># For type signatures involving dynamic shapes, we use lists of abstract values</span>
<span class="s0"># which may contain (reverse) de Bruijn indices in their shapes.</span>
<span class="s2">class </span><span class="s1">DBIdx(NamedTuple):</span>
  <span class="s1">val: int</span>

<span class="s1">@dataclass(frozen=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">InDBIdx:</span>
  <span class="s1">val: int</span>

<span class="s1">@dataclass(frozen=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">OutDBIdx:</span>
  <span class="s1">val: int</span>

<span class="s0"># For annotating input types of callables (i.e. linear_util.WrappedFuns), we use</span>
<span class="s0"># a sequence of pairs where the first element of each pair is an AbstractValue</span>
<span class="s0"># (possibly containing DBIdx instances in its shape) and the second is a boolean</span>
<span class="s0"># indicating whether that argument is explicit (i.e. passed to the callable).</span>
<span class="s1">InputType = Tuple[Tuple[AbstractValue</span><span class="s2">, </span><span class="s1">bool]</span><span class="s2">, </span><span class="s1">...]  </span><span class="s0"># DBIdx in shapes</span>

<span class="s0"># For annotating jaxpr output types, we use a sequence of pairs where the first</span>
<span class="s0"># element of each pair is an AbstractValue (possibly containing InDBIdx and/or</span>
<span class="s0"># OutDBIdx instances in its shape) and the second is a boolean indicating</span>
<span class="s0"># whether that argument is explicit (i.e. returned by the callable).</span>
<span class="s1">OutputType = Tuple[Tuple[AbstractValue</span><span class="s2">, </span><span class="s1">bool]</span><span class="s2">, </span><span class="s1">...]  </span><span class="s0"># InDBIdx / OutDBIdx shapes</span>


<span class="s2">def </span><span class="s1">_jaxpr_type_to_callable_annotation(jaxpr: Jaxpr) -&gt; InputType:</span>
  <span class="s1">idxs = {v: DBIdx(i) </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate((*jaxpr.constvars</span><span class="s2">, </span><span class="s1">*jaxpr.invars))}</span>
  <span class="s1">out = [(v.aval.update(shape=tuple(idxs.get(d</span><span class="s2">, </span><span class="s1">d) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">v.aval.shape))  </span><span class="s0"># type: ignore</span>
          <span class="s2">if </span><span class="s1">type(v.aval) </span><span class="s2">is </span><span class="s1">DShapedArray </span><span class="s2">else </span><span class="s1">v.aval</span><span class="s2">, True</span><span class="s1">)</span>
         <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">jaxpr.invars]</span>
  <span class="s2">return </span><span class="s1">tuple(out)</span>

<span class="s2">class </span><span class="s1">Bot(AbstractValue): </span><span class="s2">pass</span>
<span class="s1">bot = Bot()</span>


<span class="s2">def </span><span class="s1">lattice_join(x: Optional[AbstractValue]</span><span class="s2">,</span>
                 <span class="s1">y: Optional[AbstractValue]) -&gt; AbstractValue:</span>
  <span class="s2">if </span><span class="s1">x </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">cast(AbstractValue</span><span class="s2">, </span><span class="s1">y)</span>
  <span class="s2">elif </span><span class="s1">y </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">cast(AbstractValue</span><span class="s2">, </span><span class="s1">x)</span>
  <span class="s2">elif </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">type(y)):</span>
    <span class="s2">return </span><span class="s1">y.join(x)</span>
  <span class="s2">elif </span><span class="s1">isinstance(y</span><span class="s2">, </span><span class="s1">type(x)):</span>
    <span class="s2">return </span><span class="s1">x.join(y)</span>
  <span class="s2">elif </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">DShapedArray) </span><span class="s2">and </span><span class="s1">isinstance(y</span><span class="s2">, </span><span class="s1">ShapedArray):</span>
    <span class="s0"># TODO(mattjj): remove this special case after dynamic shapes are integrated</span>
    <span class="s2">return </span><span class="s1">x.join(y)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">TypeError(x</span><span class="s2">, </span><span class="s1">y)</span>

<span class="s0"># For use in typing annotations to denote either a Tracer or a `valid_jaxtype`.</span>
<span class="s1">Value = Any</span>

<span class="s2">def </span><span class="s1">valid_jaxtype(x) -&gt; bool:</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s1">concrete_aval(x)</span>
  <span class="s2">except </span><span class="s1">TypeError:</span>
    <span class="s2">return False</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return True</span>

<span class="s2">def </span><span class="s1">check_valid_jaxtype(x):</span>
  <span class="s2">if not </span><span class="s1">valid_jaxtype(x):</span>
    <span class="s2">raise </span><span class="s1">TypeError(</span>
      <span class="s3">f&quot;Value </span><span class="s2">{</span><span class="s1">repr(x)</span><span class="s2">} </span><span class="s3">of type </span><span class="s2">{</span><span class="s1">type(x)</span><span class="s2">} </span><span class="s3">is not a valid JAX type&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">concrete_aval(x):</span>
  <span class="s2">for </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">type(x).__mro__:</span>
    <span class="s1">handler = pytype_aval_mappings.get(typ)</span>
    <span class="s2">if </span><span class="s1">handler: </span><span class="s2">return </span><span class="s1">handler(x)</span>
  <span class="s2">if </span><span class="s1">hasattr(x</span><span class="s2">, </span><span class="s3">'__jax_array__'</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">concrete_aval(x.__jax_array__())</span>
  <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Value </span><span class="s2">{</span><span class="s1">repr(x)</span><span class="s2">} </span><span class="s3">with type </span><span class="s2">{</span><span class="s1">type(x)</span><span class="s2">} </span><span class="s3">is not a valid JAX &quot;</span>
                   <span class="s3">&quot;type&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_aval(x):</span>
  <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">Tracer):</span>
    <span class="s2">return </span><span class="s1">x.aval</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">concrete_aval(x)</span>


<span class="s2">def </span><span class="s1">concretization_function_error(fun</span><span class="s2">, </span><span class="s1">suggest_astype=</span><span class="s2">False</span><span class="s1">):</span>
  <span class="s1">fname = getattr(fun</span><span class="s2">, </span><span class="s3">&quot;__name__&quot;</span><span class="s2">, </span><span class="s1">fun)</span>
  <span class="s1">fname_context = </span><span class="s3">f&quot;The problem arose with the `</span><span class="s2">{</span><span class="s1">fname</span><span class="s2">}</span><span class="s3">` function. &quot;</span>
  <span class="s2">if </span><span class="s1">suggest_astype:</span>
    <span class="s1">fname_context += (</span><span class="s3">&quot;If trying to convert the data type of a value, &quot;</span>
                      <span class="s3">f&quot;try using `x.astype(</span><span class="s2">{</span><span class="s1">fun.__name__</span><span class="s2">}</span><span class="s3">)` &quot;</span>
                      <span class="s3">f&quot;or `jnp.array(x, </span><span class="s2">{</span><span class="s1">fun.__name__</span><span class="s2">}</span><span class="s3">)` instead.&quot;</span><span class="s1">)</span>
  <span class="s2">def </span><span class="s1">error(self</span><span class="s2">, </span><span class="s1">arg):</span>
    <span class="s2">raise </span><span class="s1">ConcretizationTypeError(arg</span><span class="s2">, </span><span class="s1">fname_context)</span>
  <span class="s2">return </span><span class="s1">error</span>

<span class="s2">def </span><span class="s1">concrete_or_error(force: Any</span><span class="s2">, </span><span class="s1">val: Any</span><span class="s2">, </span><span class="s1">context=</span><span class="s3">&quot;&quot;</span><span class="s1">):</span>
  <span class="s4">&quot;&quot;&quot;Like force(val), but gives the context in the error message.&quot;&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">force </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">force = </span><span class="s2">lambda </span><span class="s1">x: x</span>
  <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">Tracer):</span>
    <span class="s2">if </span><span class="s1">isinstance(val.aval</span><span class="s2">, </span><span class="s1">ConcreteArray):</span>
      <span class="s2">return </span><span class="s1">force(val.aval.val)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">ConcretizationTypeError(val</span><span class="s2">, </span><span class="s1">context)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">force(val)</span>


<span class="s0">### Opaque dtypes</span>
<span class="s0">#</span>
<span class="s0"># Opaque dtypes are JAX-specific dtypes that allow us to represent logical</span>
<span class="s0"># arrays of element types that do not have an obvious direct correspondence</span>
<span class="s0"># to (&quot;physical&quot;) arrays of basic types in a compiler. In particular, their</span>
<span class="s0"># element types differ from those of XLA and NumPy (e.g. int32). These dtypes</span>
<span class="s0"># are only known to JAX. Their implementation is determined by:</span>
<span class="s0"># a) an object representing the opaque dtype, accessible via the `dtype`</span>
<span class="s0">#    attribute on corresponding JAX arrays and, internally, on avals such</span>
<span class="s0">#    as ShapedArrays that correspond to such JAX arrays;</span>
<span class="s0"># b) a set of rules, available via a private attribute on the opaque dtype</span>
<span class="s0">#    object in (a).</span>
<span class="s0"># The rules in (b) tell JAX internals how to ground out the element</span>
<span class="s0"># type for interaction with the compiler and runtime, e.g. when lowering</span>
<span class="s0"># to the compiler's language.</span>


<span class="s0"># TODO(frostig): update inliners of the four functions below to call them</span>
<span class="s2">def </span><span class="s1">has_opaque_dtype(x: Any) -&gt; bool:</span>
  <span class="s2">return </span><span class="s1">dtypes.is_opaque_dtype(get_aval(x).dtype)</span>

<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">physical_aval(aval: ShapedArray) -&gt; ShapedArray: ...</span>
<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">physical_aval(aval: DShapedArray) -&gt; DShapedArray: ...</span>
<span class="s1">@overload                       </span><span class="s0"># TODO(frostig): remove this case</span>
<span class="s2">def </span><span class="s1">physical_aval(aval: AbstractValue) -&gt; AbstractValue: ...</span>

<span class="s2">def </span><span class="s1">physical_aval(aval):</span>
  <span class="s1">aval_dtype = getattr(aval</span><span class="s2">, </span><span class="s3">'dtype'</span><span class="s2">, None</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s1">aval_dtype </span><span class="s2">and </span><span class="s1">dtypes.is_opaque_dtype(aval_dtype):</span>
    <span class="s1">ctor = type(aval)</span>
    <span class="s1">aval_shape = getattr(aval</span><span class="s2">, </span><span class="s3">'shape'</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">aval_shape </span><span class="s2">is not None, </span><span class="s1">(ctor</span><span class="s2">, </span><span class="s1">aval)</span>
    <span class="s1">elt_aval = aval_dtype._rules.physical_element_aval(aval_dtype)</span>
    <span class="s2">assert </span><span class="s1">type(elt_aval) </span><span class="s2">is </span><span class="s1">ShapedArray</span>
    <span class="s2">return </span><span class="s1">ctor((*aval_shape</span><span class="s2">, </span><span class="s1">*elt_aval.shape)</span><span class="s2">, </span><span class="s1">elt_aval.dtype)  </span><span class="s0"># pytype: disable=wrong-arg-count</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">aval</span>

<span class="s2">def </span><span class="s1">_short_dtype_name(dtype) -&gt; str:</span>
  <span class="s2">if </span><span class="s1">type(dtype) </span><span class="s2">in </span><span class="s1">dtypes.opaque_dtypes:</span>
    <span class="s2">return </span><span class="s1">str(dtype)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">(dtype.name.replace(</span><span class="s3">'float'</span><span class="s2">, </span><span class="s3">'f'</span><span class="s1">).replace(</span><span class="s3">'uint'   </span><span class="s2">, </span><span class="s3">'u'</span><span class="s1">)</span>
                      <span class="s1">.replace(</span><span class="s3">'int'  </span><span class="s2">, </span><span class="s3">'i'</span><span class="s1">).replace(</span><span class="s3">'complex'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s1">))</span>

<span class="s2">def </span><span class="s1">_dtype_object(dtype):</span>
  <span class="s2">return </span><span class="s1">dtype </span><span class="s2">if </span><span class="s1">type(dtype) </span><span class="s2">in </span><span class="s1">dtypes.opaque_dtypes </span><span class="s2">else </span><span class="s1">np.dtype(dtype)</span>

<span class="s2">class </span><span class="s1">UnshapedArray(AbstractValue):</span>
  <span class="s1">__slots__ = [</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s3">'weak_type'</span><span class="s1">]</span>
  <span class="s1">array_abstraction_level = </span><span class="s5">4</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">weak_type=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s1">self.dtype = _dtype_object(dtype)</span>
    <span class="s1">self.weak_type = weak_type</span>

  <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s2">None, </span><span class="s1">weak_type=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s1">dtype = self.dtype</span>
    <span class="s2">if </span><span class="s1">weak_type </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s1">weak_type = self.weak_type</span>
    <span class="s2">return </span><span class="s1">UnshapedArray(dtype</span><span class="s2">, </span><span class="s1">weak_type)</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return </span><span class="s1">(type(self) </span><span class="s2">is </span><span class="s1">type(other) </span><span class="s2">and </span><span class="s1">self.dtype == other.dtype </span><span class="s2">and</span>
            <span class="s1">self.weak_type == other.weak_type)</span>

  <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return not </span><span class="s1">self == other</span>

  <span class="s2">def </span><span class="s1">__hash__(self):</span>
    <span class="s0"># can use hash(self.dtype) and rely on the fact that numpy reuses base dtype</span>
    <span class="s0"># objects, e.g. `np.zeros(3).dtype is np.zeros(4).dtype`, or we can use</span>
    <span class="s0"># the unique character code via hash(self.dtype.char)</span>
    <span class="s2">return </span><span class="s1">hash((self.dtype</span><span class="s2">, </span><span class="s1">self.weak_type))</span>

  <span class="s2">def </span><span class="s1">__repr__(self):</span>
    <span class="s2">return </span><span class="s3">'{}({}{})'</span><span class="s1">.format(self.__class__.__name__</span><span class="s2">, </span><span class="s1">self.str_short()</span><span class="s2">,</span>
                             <span class="s3">&quot;, weak_type=True&quot; </span><span class="s2">if </span><span class="s1">self.weak_type </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>

  <span class="s1">_bool = _nonzero = concretization_function_error(bool)</span>
  <span class="s1">_float   = concretization_function_error(float</span><span class="s2">, True</span><span class="s1">)</span>
  <span class="s1">_int     = concretization_function_error(int</span><span class="s2">, True</span><span class="s1">)</span>
  <span class="s1">_complex = concretization_function_error(complex</span><span class="s2">, True</span><span class="s1">)</span>
  <span class="s1">_hex     = concretization_function_error(hex)</span>
  <span class="s1">_oct     = concretization_function_error(oct)</span>

  <span class="s2">def </span><span class="s1">at_least_vspace(self) -&gt; AbstractValue:</span>
    <span class="s2">return </span><span class="s1">UnshapedArray(primal_dtype_to_tangent_dtype(self.dtype)</span><span class="s2">,</span>
                         <span class="s1">self.weak_type)</span>

  <span class="s2">def </span><span class="s1">join(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">if </span><span class="s1">self.dtype == other.dtype:</span>
      <span class="s2">if </span><span class="s1">self.weak_type == other.weak_type:</span>
        <span class="s2">return </span><span class="s1">self</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">UnshapedArray(self.dtype</span><span class="s2">, </span><span class="s1">weak_type=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">TypeError(self</span><span class="s2">, </span><span class="s1">other)</span>

  <span class="s2">def </span><span class="s1">str_short(self</span><span class="s2">, </span><span class="s1">short_dtypes=</span><span class="s2">False</span><span class="s1">) -&gt; str:</span>
    <span class="s2">return </span><span class="s1">_short_dtype_name(self.dtype) </span><span class="s2">if </span><span class="s1">short_dtypes </span><span class="s2">else </span><span class="s1">self.dtype.name</span>

  <span class="s2">def </span><span class="s1">strip_weak_type(self):</span>
    <span class="s4">&quot;&quot;&quot;Returns a copy of the aval with weak_type=False.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">self.update(weak_type=</span><span class="s2">False</span><span class="s1">)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">shape(self):</span>
    <span class="s1">msg = (</span><span class="s3">&quot;UnshapedArray has no shape. Please open an issue at &quot;</span>
           <span class="s3">&quot;https://github.com/google/jax/issues because it's unexpected for &quot;</span>
           <span class="s3">&quot;UnshapedArray instances to ever be produced.&quot;</span><span class="s1">)</span>
    <span class="s2">raise </span><span class="s1">TypeError(msg)</span>


<span class="s2">class </span><span class="s1">ShapedArray(UnshapedArray):</span>
  <span class="s1">__slots__ = [</span><span class="s3">'shape'</span><span class="s2">, </span><span class="s3">'named_shape'</span><span class="s1">]</span>
  <span class="s1">array_abstraction_level = </span><span class="s5">2</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">weak_type=</span><span class="s2">False, </span><span class="s1">named_shape=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">self.shape = canonicalize_shape(shape)</span>
    <span class="s1">self.dtype = _dtype_object(dtype)</span>
    <span class="s1">self.weak_type = weak_type</span>
    <span class="s1">self.named_shape = {} </span><span class="s2">if </span><span class="s1">named_shape </span><span class="s2">is None else </span><span class="s1">dict(named_shape)</span>

  <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">shape=</span><span class="s2">None, </span><span class="s1">dtype=</span><span class="s2">None, </span><span class="s1">weak_type=</span><span class="s2">None, </span><span class="s1">named_shape=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">shape </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s1">shape = self.shape</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s1">dtype = self.dtype</span>
    <span class="s2">if </span><span class="s1">weak_type </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s1">weak_type = self.weak_type</span>
    <span class="s2">if </span><span class="s1">named_shape </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s1">named_shape = self.named_shape</span>
    <span class="s2">return </span><span class="s1">ShapedArray(shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">weak_type</span><span class="s2">, </span><span class="s1">named_shape)</span>

  <span class="s1">ndim = property(</span><span class="s2">lambda </span><span class="s1">self: len(self.shape))</span>
  <span class="s1">size = property(</span><span class="s2">lambda </span><span class="s1">self:</span>
                  <span class="s5">0 </span><span class="s2">if </span><span class="s1">any(type(d) </span><span class="s2">is </span><span class="s1">int </span><span class="s2">and </span><span class="s1">d == </span><span class="s5">0 </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">self.shape)</span>
                  <span class="s2">else </span><span class="s1">math.prod(self.shape))</span>

  <span class="s1">broadcast: ClassVar[Optional[aval_method]] = </span><span class="s2">None</span>
  <span class="s1">transpose: ClassVar[Optional[aval_method]] = </span><span class="s2">None</span>
  <span class="s1">reshape: ClassVar[Optional[aval_method]] = </span><span class="s2">None</span>
  <span class="s1">_iter: ClassVar[Optional[staticmethod]] = </span><span class="s2">None</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return </span><span class="s1">(type(self) </span><span class="s2">is </span><span class="s1">type(other)</span>
            <span class="s2">and </span><span class="s1">self.dtype == other.dtype </span><span class="s2">and </span><span class="s1">self.shape == other.shape</span>
            <span class="s2">and </span><span class="s1">self.weak_type == other.weak_type</span>
            <span class="s2">and </span><span class="s1">self.named_shape == other.named_shape)</span>

  <span class="s2">def </span><span class="s1">__hash__(self):</span>
    <span class="s0"># can use hash(self.dtype) and rely on the fact that numpy reuses base dtype</span>
    <span class="s0"># objects, e.g. `np.zeros(3).dtype is np.zeros(4).dtype`, or we can use</span>
    <span class="s0"># the unique character code via hash(self.dtype.char)</span>
    <span class="s2">return </span><span class="s1">hash((self.shape</span><span class="s2">, </span><span class="s1">self.dtype</span><span class="s2">, </span><span class="s1">self.weak_type</span><span class="s2">,</span>
                 <span class="s1">tuple(self.named_shape.items())))</span>

  <span class="s2">def </span><span class="s1">at_least_vspace(self):</span>
    <span class="s2">return </span><span class="s1">ShapedArray(self.shape</span><span class="s2">, </span><span class="s1">primal_dtype_to_tangent_dtype(self.dtype)</span><span class="s2">,</span>
                       <span class="s1">self.weak_type</span><span class="s2">, </span><span class="s1">self.named_shape)</span>

  <span class="s2">def </span><span class="s1">join(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">if </span><span class="s1">symbolic_equal_shape(self.shape</span><span class="s2">, </span><span class="s1">other.shape) </span><span class="s2">and </span><span class="s1">self.dtype == other.dtype:</span>
      <span class="s1">weak_type = self.weak_type </span><span class="s2">and </span><span class="s1">other.weak_type</span>
      <span class="s1">named_shape = join_named_shapes(self.named_shape</span><span class="s2">, </span><span class="s1">other.named_shape)</span>
      <span class="s2">return </span><span class="s1">self.update(weak_type=weak_type</span><span class="s2">, </span><span class="s1">named_shape=named_shape)</span>
    <span class="s2">elif </span><span class="s1">self.dtype == other.dtype:</span>
      <span class="s2">return </span><span class="s1">UnshapedArray(self.dtype)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">TypeError(self</span><span class="s2">, </span><span class="s1">other)</span>

  <span class="s2">def </span><span class="s1">str_short(self</span><span class="s2">, </span><span class="s1">short_dtypes=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s1">dt_str =  _short_dtype_name(self.dtype) </span><span class="s2">if </span><span class="s1">short_dtypes </span><span class="s2">else </span><span class="s1">self.dtype.name</span>
    <span class="s1">shapestr = </span><span class="s3">','</span><span class="s1">.join(map(str</span><span class="s2">, </span><span class="s1">self.shape))</span>
    <span class="s2">if </span><span class="s1">self.named_shape:</span>
      <span class="s1">named_shapestr = </span><span class="s3">','</span><span class="s1">.join(</span><span class="s3">f'</span><span class="s2">{</span><span class="s1">k</span><span class="s2">}</span><span class="s3">:</span><span class="s2">{</span><span class="s1">v</span><span class="s2">}</span><span class="s3">' </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.named_shape.items())</span>
      <span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">dt_str</span><span class="s2">}</span><span class="s3">[</span><span class="s2">{</span><span class="s1">shapestr</span><span class="s2">}</span><span class="s3">;</span><span class="s2">{</span><span class="s1">named_shapestr</span><span class="s2">}</span><span class="s3">]'</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">dt_str</span><span class="s2">}</span><span class="s3">[</span><span class="s2">{</span><span class="s1">shapestr</span><span class="s2">}</span><span class="s3">]'</span>

  <span class="s2">def </span><span class="s1">strip_named_shape(self):</span>
    <span class="s2">return </span><span class="s1">self.update(named_shape={})</span>

  <span class="s2">def </span><span class="s1">_len(self</span><span class="s2">, </span><span class="s1">ignored_tracer):</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">self.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">except </span><span class="s1">IndexError </span><span class="s2">as </span><span class="s1">err:</span>
      <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;len() of unsized object&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err  </span><span class="s0"># same as numpy error</span>


<span class="s2">def </span><span class="s1">_forward_to_value(self</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">ignored_tracer</span><span class="s2">, </span><span class="s1">*args):</span>
  <span class="s2">return </span><span class="s1">fun(self.val</span><span class="s2">, </span><span class="s1">*args)</span>


<span class="s2">class </span><span class="s1">ConcreteArray(ShapedArray):</span>
  <span class="s1">__slots__ = [</span><span class="s3">'val'</span><span class="s1">]</span>
  <span class="s1">array_abstraction_level = </span><span class="s5">0</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">weak_type=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">super().__init__(</span>
        <span class="s1">np.shape(val)</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">,</span>
        <span class="s1">weak_type=dtypes.is_weakly_typed(val) </span><span class="s2">if </span><span class="s1">weak_type </span><span class="s2">is None else </span><span class="s1">weak_type)</span>
    <span class="s0"># Note: canonicalized self.dtype doesn't necessarily match self.val</span>
    <span class="s2">assert </span><span class="s1">self.dtype == dtypes.canonicalize_dtype(np.result_type(val))</span><span class="s2">, </span><span class="s1">(val</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s1">self.val = val</span>
    <span class="s2">assert </span><span class="s1">self.dtype != np.dtype(</span><span class="s3">'O'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">val</span>

  <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s2">None, </span><span class="s1">val=</span><span class="s2">None, </span><span class="s1">weak_type=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">dtype = self.dtype </span><span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None else </span><span class="s1">dtype</span>
    <span class="s1">val = self.val </span><span class="s2">if </span><span class="s1">val </span><span class="s2">is None else </span><span class="s1">val</span>
    <span class="s1">weak_type = self.weak_type </span><span class="s2">if </span><span class="s1">weak_type </span><span class="s2">is None else </span><span class="s1">weak_type</span>
    <span class="s2">return </span><span class="s1">ConcreteArray(dtype</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">weak_type)</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">if </span><span class="s1">(type(self) </span><span class="s2">is </span><span class="s1">type(other) </span><span class="s2">and </span><span class="s1">self.dtype == other.dtype</span>
        <span class="s2">and </span><span class="s1">self.shape == other.shape </span><span class="s2">and </span><span class="s1">self.weak_type == other.weak_type):</span>
      <span class="s2">with </span><span class="s1">eval_context():  </span><span class="s0"># in case self.val is a DeviceArray</span>
        <span class="s2">return </span><span class="s1">(self.val == other.val).all()</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">return False</span>

  <span class="s2">def </span><span class="s1">__hash__(self):</span>
    <span class="s2">return </span><span class="s1">id(self.val)</span>

  <span class="s2">def </span><span class="s1">join(self</span><span class="s2">, </span><span class="s1">other) -&gt; AbstractValue:</span>
    <span class="s2">if </span><span class="s1">self == other:</span>
      <span class="s2">return </span><span class="s1">self</span>
    <span class="s2">elif </span><span class="s1">self.shape == other.shape </span><span class="s2">and </span><span class="s1">self.dtype == other.dtype:</span>
      <span class="s1">weak_type = self.weak_type </span><span class="s2">and </span><span class="s1">other.weak_type</span>
      <span class="s1">named_shape = join_named_shapes(self.named_shape</span><span class="s2">, </span><span class="s1">other.named_shape)</span>
      <span class="s2">return </span><span class="s1">ShapedArray(</span>
          <span class="s1">self.shape</span><span class="s2">, </span><span class="s1">self.dtype</span><span class="s2">, </span><span class="s1">weak_type=weak_type</span><span class="s2">, </span><span class="s1">named_shape=named_shape)</span>
    <span class="s2">elif </span><span class="s1">self.dtype == other.dtype:</span>
      <span class="s2">return </span><span class="s1">UnshapedArray(self.dtype</span><span class="s2">,</span>
                           <span class="s1">weak_type=self.weak_type </span><span class="s2">and </span><span class="s1">other.weak_type)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">TypeError(self</span><span class="s2">, </span><span class="s1">other)</span>

  <span class="s2">def </span><span class="s1">str_short(self</span><span class="s2">, </span><span class="s1">short_dtypes=</span><span class="s2">False</span><span class="s1">) -&gt; str:</span>
    <span class="s1">dt_str =  _short_dtype_name(self.dtype) </span><span class="s2">if </span><span class="s1">short_dtypes </span><span class="s2">else </span><span class="s1">self.dtype.name</span>
    <span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">self.val</span><span class="s2">}</span><span class="s3">, dtype=</span><span class="s2">{</span><span class="s1">dt_str</span><span class="s2">}</span><span class="s3">'</span>

  <span class="s1">_bool = _nonzero = partialmethod(_forward_to_value</span><span class="s2">, </span><span class="s1">bool)</span>
  <span class="s1">_int             = partialmethod(_forward_to_value</span><span class="s2">, </span><span class="s1">int)</span>
  <span class="s1">_hex             = partialmethod(_forward_to_value</span><span class="s2">, </span><span class="s1">hex)</span>
  <span class="s1">_oct             = partialmethod(_forward_to_value</span><span class="s2">, </span><span class="s1">oct)</span>

  <span class="s1">_float           = concretization_function_error(float</span><span class="s2">, True</span><span class="s1">)</span>
  <span class="s1">_complex         = concretization_function_error(complex</span><span class="s2">, True</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">primal_dtype_to_tangent_dtype(primal_dtype):</span>
  <span class="s0"># TODO(frostig,mattjj): determines that all opaque dtypes have</span>
  <span class="s0"># float0 tangent type, which works fine for all our current opaque</span>
  <span class="s0"># dtype applications. We may some day want to delegate this</span>
  <span class="s0"># decision to the dtype rules.</span>
  <span class="s2">if </span><span class="s1">(dtypes.is_opaque_dtype(primal_dtype) </span><span class="s2">or</span>
      <span class="s2">not </span><span class="s1">dtypes.issubdtype(primal_dtype</span><span class="s2">, </span><span class="s1">np.inexact)):</span>
    <span class="s2">return </span><span class="s1">dtypes.float0</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">primal_dtype</span>


<span class="s0"># Dynamic shape stuff below here! We keep the abstract values distinct just so</span>
<span class="s0"># as not to interfere with any static shape machinery.</span>

<span class="s0"># We have a convention of reusing AbsractValues as types, even though we could</span>
<span class="s0"># make a distinction and use abstract values during tracing only. This reuse</span>
<span class="s0"># becomes a bit more extreme with DShapedArrays. A DShapedArray's shape</span>
<span class="s0"># attribute is a tuple which can contain several different types: int, DArray</span>
<span class="s0"># (scalar and with dtype of bint type), Tracer (while tracing), Var (when used</span>
<span class="s0"># as jaxpr type annotations), or DBIdx/InDBIdx/OutDBIdx (when used in InputType</span>
<span class="s0"># or OutputType). We could reduce this polymorphism if it seems cleaner, though</span>
<span class="s0"># it's kind of convenient!</span>
<span class="s2">class </span><span class="s1">DShapedArray(UnshapedArray):</span>
  <span class="s1">__slots__ = [</span><span class="s3">'shape'</span><span class="s1">]</span>
  <span class="s1">shape: Tuple[AxisSize</span><span class="s2">, </span><span class="s1">...]  </span><span class="s0"># noqa: F821</span>
  <span class="s1">array_abstraction_level: int = </span><span class="s5">3</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">weak_type=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s1">self.shape = shape</span>
    <span class="s1">self.dtype = dtype</span>
    <span class="s1">self.weak_type = weak_type</span>

  <span class="s1">ndim = property(</span><span class="s2">lambda </span><span class="s1">self: len(self.shape))</span>
  <span class="s1">size = property(</span><span class="s2">lambda </span><span class="s1">self:</span>
                  <span class="s5">0 </span><span class="s2">if </span><span class="s1">any(type(d) </span><span class="s2">is </span><span class="s1">int </span><span class="s2">and </span><span class="s1">d == </span><span class="s5">0 </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">self.shape)</span>
                  <span class="s2">else </span><span class="s1">math.prod(self.shape))</span>

  <span class="s2">def </span><span class="s1">str_short(self</span><span class="s2">, </span><span class="s1">short_dtypes=</span><span class="s2">False</span><span class="s1">) -&gt; str:</span>
    <span class="s2">del </span><span class="s1">short_dtypes  </span><span class="s0"># ignored</span>
    <span class="s1">shape = </span><span class="s3">f'</span><span class="s2">{</span><span class="s3">&quot;,&quot;</span><span class="s1">.join(str(d) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">self.shape)</span><span class="s2">}</span><span class="s3">' </span><span class="s2">if </span><span class="s1">self.shape </span><span class="s2">else </span><span class="s3">''</span>
    <span class="s1">dtype = _short_dtype_name(self.dtype)</span>
    <span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">[</span><span class="s2">{</span><span class="s1">shape</span><span class="s2">}</span><span class="s3">]'</span>
  <span class="s1">__str__ = __repr__ = str_short</span>

  <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">shape=</span><span class="s2">None, </span><span class="s1">dtype=</span><span class="s2">None, </span><span class="s1">weak_type=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">shape </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s1">shape = self.shape</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s1">dtype = self.dtype</span>
    <span class="s2">if </span><span class="s1">weak_type </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s1">weak_type = self.weak_type</span>
    <span class="s2">return </span><span class="s1">DShapedArray(shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">weak_type)</span>

  <span class="s2">def </span><span class="s1">_len(self</span><span class="s2">, </span><span class="s1">tracer):</span>
    <span class="s2">return </span><span class="s1">self.shape[</span><span class="s5">0</span><span class="s1">]</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return </span><span class="s1">(type(self) </span><span class="s2">is </span><span class="s1">type(other)</span>
            <span class="s2">and </span><span class="s1">self.dtype == other.dtype </span><span class="s2">and </span><span class="s1">self.shape == other.shape</span>
            <span class="s2">and </span><span class="s1">self.weak_type == other.weak_type)</span>

  <span class="s2">def </span><span class="s1">__hash__(self):</span>
    <span class="s2">return </span><span class="s1">hash((self.shape</span><span class="s2">, </span><span class="s1">self.dtype</span><span class="s2">, </span><span class="s1">self.weak_type))</span>

  <span class="s2">def </span><span class="s1">join(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">if </span><span class="s1">(symbolic_equal_shape(self.shape</span><span class="s2">, </span><span class="s1">other.shape) </span><span class="s2">and</span>
        <span class="s1">self.dtype == other.dtype):</span>
      <span class="s1">weak_type = self.weak_type </span><span class="s2">and </span><span class="s1">other.weak_type</span>
      <span class="s2">return </span><span class="s1">self.update(weak_type=weak_type)</span>
    <span class="s2">elif </span><span class="s1">self.dtype == other.dtype:</span>
      <span class="s2">return </span><span class="s1">UnshapedArray(self.dtype)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">TypeError(self</span><span class="s2">, </span><span class="s1">other)</span>

  <span class="s2">def </span><span class="s1">at_least_vspace(self):</span>
    <span class="s2">return </span><span class="s1">DShapedArray(self.shape</span><span class="s2">, </span><span class="s1">primal_dtype_to_tangent_dtype(self.dtype)</span><span class="s2">,</span>
                        <span class="s1">self.weak_type)</span>

<span class="s2">class </span><span class="s1">DConcreteArray(DShapedArray):</span>
  <span class="s1">__slots__ = [</span><span class="s3">'val'</span><span class="s1">]</span>
  <span class="s1">array_abstraction_level = </span><span class="s5">1</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">weak_type</span><span class="s2">, </span><span class="s1">val):</span>
    <span class="s1">super().__init__(shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">weak_type)</span>
    <span class="s1">self.val = val</span>


<span class="s1">pytype_aval_mappings: Dict[type</span><span class="s2">, </span><span class="s1">Callable[[Any]</span><span class="s2">, </span><span class="s1">AbstractValue]] = {}</span>


<span class="s2">class </span><span class="s1">DArray:</span>
  <span class="s1">_aval: DShapedArray</span>
  <span class="s1">_data: Any  </span><span class="s0"># standard array type</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">data):</span>
    <span class="s1">pad_shape = tuple(d.dtype.bound </span><span class="s2">if </span><span class="s1">type(d) </span><span class="s2">is </span><span class="s1">DArray </span><span class="s2">and</span>
                      <span class="s1">type(d.dtype) </span><span class="s2">is </span><span class="s1">bint </span><span class="s2">else </span><span class="s1">d </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">aval.shape)</span>
    <span class="s2">assert </span><span class="s1">data.shape == pad_shape</span>
    <span class="s1">self._aval = aval</span>
    <span class="s1">self._data = data</span>
  <span class="s1">shape = property(</span><span class="s2">lambda </span><span class="s1">self: self._aval.shape)</span>
  <span class="s1">dtype = property(</span><span class="s2">lambda </span><span class="s1">self: self._aval.dtype)</span>
  <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
    <span class="s2">if not </span><span class="s1">self.shape </span><span class="s2">and </span><span class="s1">type(self.dtype) </span><span class="s2">is </span><span class="s1">bint:</span>
      <span class="s0"># special-case scalar bints</span>
      <span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">int(self._data)</span><span class="s2">}{{</span><span class="s3"></span><span class="s2">{</span><span class="s1">self.dtype.bound</span><span class="s2">}}}</span><span class="s3">'</span>

    <span class="s1">dtypestr = _short_dtype_name(self._aval.dtype)</span>
    <span class="s1">shapestr = </span><span class="s3">','</span><span class="s1">.join(map(str</span><span class="s2">, </span><span class="s1">self.shape))</span>
    <span class="s1">slices = tuple(slice(int(d._data)) </span><span class="s2">if </span><span class="s1">type(d) </span><span class="s2">is </span><span class="s1">DArray </span><span class="s2">and</span>
                   <span class="s1">type(d.dtype) </span><span class="s2">is </span><span class="s1">bint </span><span class="s2">else </span><span class="s1">slice(</span><span class="s2">None</span><span class="s1">) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">self.shape)</span>
    <span class="s1">data = self._data[slices]</span>
    <span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">dtypestr</span><span class="s2">}</span><span class="s3">[</span><span class="s2">{</span><span class="s1">shapestr</span><span class="s2">}</span><span class="s3">] with value: </span><span class="s2">{</span><span class="s1">data</span><span class="s2">}</span><span class="s3">'</span>
  <span class="s2">def </span><span class="s1">__hash__(self) -&gt; int:</span>
    <span class="s2">if not </span><span class="s1">self.shape:</span>
      <span class="s2">return </span><span class="s1">hash((self._aval</span><span class="s2">, </span><span class="s1">int(self._data)))</span>
    <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;unhashable type: DArray&quot;</span><span class="s1">)</span>
  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">DArray) </span><span class="s2">and </span><span class="s1">self._aval == other._aval:</span>
      <span class="s2">return </span><span class="s1">self._data == other._data</span>
    <span class="s2">return False</span>
  <span class="s2">def </span><span class="s1">__len__(self):</span>
    <span class="s2">return </span><span class="s1">self.shape[</span><span class="s5">0</span><span class="s1">]</span>

<span class="s1">pytype_aval_mappings[DArray] = \</span>
    <span class="s2">lambda </span><span class="s1">x: DConcreteArray(x._aval.shape</span><span class="s2">, </span><span class="s1">x._aval.dtype</span><span class="s2">, </span><span class="s1">x._aval.weak_type</span><span class="s2">,</span>
                             <span class="s1">x._data)</span>

<span class="s1">@dataclass(frozen=</span><span class="s2">True, </span><span class="s1">eq=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">bint:</span>
  <span class="s1">bound: int</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">name(self) -&gt; str:</span>
    <span class="s2">return </span><span class="s3">f'bint</span><span class="s2">{{</span><span class="s3"></span><span class="s2">{</span><span class="s1">self.bound</span><span class="s2">}}}</span><span class="s3">'</span>

  <span class="s2">def </span><span class="s1">__str__(self) -&gt; str:</span>
    <span class="s2">return </span><span class="s1">self.name</span>
<span class="s1">dtypes.opaque_dtypes.add(bint)</span>

<span class="s1">AxisSize = Union[int</span><span class="s2">, </span><span class="s1">DArray</span><span class="s2">, </span><span class="s1">Tracer</span><span class="s2">, </span><span class="s1">Var</span><span class="s2">, </span><span class="s1">DBIdx</span><span class="s2">, </span><span class="s1">InDBIdx</span><span class="s2">, </span><span class="s1">OutDBIdx]</span>


<span class="s2">class </span><span class="s1">AbstractToken(AbstractValue):</span>
  <span class="s2">def </span><span class="s1">join(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">AbstractToken):</span>
      <span class="s2">return </span><span class="s1">self</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">assert False, </span><span class="s3">f&quot;Cannot join </span><span class="s2">{</span><span class="s1">self</span><span class="s2">} </span><span class="s3">with </span><span class="s2">{</span><span class="s1">other</span><span class="s2">}</span><span class="s3">&quot;</span>
  <span class="s2">def </span><span class="s1">str_short(self</span><span class="s2">, </span><span class="s1">short_dtypes=</span><span class="s2">False</span><span class="s1">): </span><span class="s2">return </span><span class="s3">'Tok'</span>
  <span class="s2">def </span><span class="s1">at_least_vspace(self): </span><span class="s2">return </span><span class="s1">self</span>
<span class="s1">abstract_token: AbstractToken = AbstractToken()</span>

<span class="s0"># Concrete token object</span>
<span class="s2">class </span><span class="s1">Token: </span><span class="s2">pass</span>
<span class="s1">token: Token = Token()</span>
<span class="s1">pytype_aval_mappings[Token] = </span><span class="s2">lambda </span><span class="s1">_: abstract_token</span>


<span class="s2">def </span><span class="s1">raise_to_shaped(aval: AbstractValue</span><span class="s2">, </span><span class="s1">weak_type=</span><span class="s2">None</span><span class="s1">):</span>
  <span class="s1">aval_type = type(aval)</span>
  <span class="s2">if </span><span class="s1">aval_type </span><span class="s2">is </span><span class="s1">ShapedArray </span><span class="s2">and </span><span class="s1">weak_type </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">aval</span>
  <span class="s2">if </span><span class="s1">weak_type </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">weak_type = getattr(aval</span><span class="s2">, </span><span class="s3">'weak_type'</span><span class="s2">, False</span><span class="s1">)</span>
  <span class="s2">for </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">aval_type.__mro__:</span>
    <span class="s1">handler = raise_to_shaped_mappings.get(typ)</span>
    <span class="s2">if </span><span class="s1">handler: </span><span class="s2">return </span><span class="s1">handler(aval</span><span class="s2">, </span><span class="s1">weak_type)</span>
  <span class="s2">raise </span><span class="s1">TypeError(type(aval))</span>

<span class="s1">raise_to_shaped_mappings : Dict[type</span><span class="s2">, </span><span class="s1">Callable] = {</span>
  <span class="s1">AbstractToken: </span><span class="s2">lambda </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">_: aval</span><span class="s2">,</span>
  <span class="s1">Bot: </span><span class="s2">lambda </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">_: aval</span><span class="s2">,</span>
  <span class="s1">UnshapedArray: </span><span class="s2">lambda </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">_: aval</span><span class="s2">,</span>
  <span class="s1">ShapedArray: </span><span class="s2">lambda </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">weak_type: ShapedArray(</span>
      <span class="s1">aval.shape</span><span class="s2">, </span><span class="s1">aval.dtype</span><span class="s2">, </span><span class="s1">weak_type</span><span class="s2">, </span><span class="s1">aval.named_shape)</span><span class="s2">,</span>
  <span class="s1">DConcreteArray: </span><span class="s2">lambda </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">weak_type: DShapedArray(</span>
      <span class="s1">aval.shape</span><span class="s2">, </span><span class="s1">aval.dtype</span><span class="s2">, </span><span class="s1">weak_type)</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s0">### Operations on shapes and dimension sizes.</span>

<span class="s2">class </span><span class="s1">InconclusiveDimensionOperation(Exception):</span>
  <span class="s4">&quot;&quot;&quot;Raised when we cannot conclusively compute with symbolic dimensions.&quot;&quot;&quot;</span>
  <span class="s2">pass</span>

<span class="s2">class </span><span class="s1">DimensionHandler:</span>
  <span class="s4">&quot;&quot;&quot;Operations on dimension sizes. 
 
  Dimension sizes are normally integer constants, but can also be symbolic, 
  e.g., masking.Poly or jax2tf.shape_poly.DimVar. 
 
  The base class works for integers only. Subclasses are invoked when at least 
  one of the operands has a type registered in _SPECIAL_DIMENSION_HANDLERS. In 
  that case, all operands are guaranteed to be either the special dimension 
  type, or Python integer scalars. 
 
  Subclasses should raise InconclusiveDimensionOperation if the result cannot 
  be computed in some contexts. 
  &quot;&quot;&quot;</span>
  <span class="s2">def </span><span class="s1">is_constant(self</span><span class="s2">, </span><span class="s1">d: DimSize) -&gt; bool:</span>
    <span class="s4">&quot;&quot;&quot;The dimension is a constant.&quot;&quot;&quot;</span>
    <span class="s2">return True</span>

  <span class="s2">def </span><span class="s1">symbolic_equal(self</span><span class="s2">, </span><span class="s1">d1: DimSize</span><span class="s2">, </span><span class="s1">d2: DimSize) -&gt; bool:</span>
    <span class="s4">&quot;&quot;&quot;True iff the dimension sizes are equal in all contexts; False otherwise. 
    Unlike `d1 == d2` this never raises InconclusiveDimensionOperation. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">d1 == d2</span>

  <span class="s2">def </span><span class="s1">greater_equal(self</span><span class="s2">, </span><span class="s1">d1: DimSize</span><span class="s2">, </span><span class="s1">d2: DimSize) -&gt; bool:</span>
    <span class="s4">&quot;&quot;&quot;Computes `d1 &gt;= d2`. 
    Raise InconclusiveDimensionOperation if the result is different in 
    different contexts. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">d1 &gt;= d2</span>

  <span class="s2">def </span><span class="s1">sum(self</span><span class="s2">, </span><span class="s1">*ds: DimSize) -&gt; DimSize:</span>
    <span class="s4">&quot;&quot;&quot;Sum of dimensions. 
    Raises InconclusiveDimensionOperation if the result cannot be represented 
    by the same DimSize in all contexts. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">sum(ds)</span>

  <span class="s2">def </span><span class="s1">diff(self</span><span class="s2">, </span><span class="s1">d1: DimSize</span><span class="s2">, </span><span class="s1">d2: DimSize) -&gt; DimSize:</span>
    <span class="s4">&quot;&quot;&quot;Difference of dimensions. 
    Raises InconclusiveDimensionOperation if the result cannot be represented 
    by the same DimSize in all contexts. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">d1 - d2</span>

  <span class="s2">def </span><span class="s1">divide_shape_sizes(self</span><span class="s2">, </span><span class="s1">s1: Shape</span><span class="s2">, </span><span class="s1">s2: Shape) -&gt; DimSize:</span>
    <span class="s4">&quot;&quot;&quot;Computes integer &quot;i&quot; such that i  * size(s2) == size(s1). 
 
    Raise InconclusiveDimensionOperation if there is no such integer for all 
    contexts, 
    &quot;&quot;&quot;</span>
    <span class="s1">sz1 = math.prod(s1)</span>
    <span class="s1">sz2 = math.prod(s2)</span>
    <span class="s2">if </span><span class="s1">sz1 == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">sz2 == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s5">1</span>
    <span class="s2">if </span><span class="s1">sz1 % sz2:</span>
      <span class="s2">raise </span><span class="s1">InconclusiveDimensionOperation(</span><span class="s3">f&quot;Cannot divide evenly the sizes of shapes </span><span class="s2">{</span><span class="s1">tuple(s1)</span><span class="s2">} </span><span class="s3">and </span><span class="s2">{</span><span class="s1">tuple(s2)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">sz1 // sz2</span>

  <span class="s2">def </span><span class="s1">stride(self</span><span class="s2">, </span><span class="s1">d: DimSize</span><span class="s2">, </span><span class="s1">window_size: DimSize</span><span class="s2">, </span><span class="s1">window_stride: DimSize) -&gt; DimSize:</span>
    <span class="s4">&quot;&quot;&quot;(d - window_size) // window_stride + 1. 
 
    If d == 0 or window_size &gt; d, returns 0. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">d == </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">window_size &gt; d: </span><span class="s2">return </span><span class="s5">0</span>
    <span class="s2">return </span><span class="s1">(d - window_size) // window_stride + </span><span class="s5">1</span>

  <span class="s2">def </span><span class="s1">dilate(self</span><span class="s2">, </span><span class="s1">d: DimSize</span><span class="s2">, </span><span class="s1">dilation: int) -&gt; DimSize:</span>
    <span class="s4">&quot;&quot;&quot;Implements `d if dilation == 1 else (0 if d == 0 else 1 + dilation * (d - 1)))`&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">symbolic_equal_dim(dilation</span><span class="s2">, </span><span class="s5">1</span><span class="s1">):</span>
      <span class="s2">return </span><span class="s1">d</span>
    <span class="s2">return </span><span class="s5">0 </span><span class="s2">if </span><span class="s1">d == </span><span class="s5">0 </span><span class="s2">else </span><span class="s5">1 </span><span class="s1">+ dilation * (d - </span><span class="s5">1</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">as_value(self</span><span class="s2">, </span><span class="s1">d: DimSize):</span>
    <span class="s4">&quot;&quot;&quot;Turns a dimension size into a JAX value that we can compute with.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">d</span>

<span class="s1">_dimension_handler_int = DimensionHandler()</span>
<span class="s1">_SPECIAL_DIMENSION_HANDLERS: Dict[type</span><span class="s2">, </span><span class="s1">DimensionHandler] = {}</span>
<span class="s1">DArrayDimHandler = type(</span><span class="s3">'DArrayDimHandler'</span><span class="s2">, </span><span class="s1">(DimensionHandler</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">{})()</span>

<span class="s2">def </span><span class="s1">_get_special_dim_handler(dim: DimSize) -&gt; Optional[DimensionHandler]:</span>
  <span class="s2">if </span><span class="s1">isinstance(dim</span><span class="s2">, </span><span class="s1">Tracer) </span><span class="s2">and not </span><span class="s1">config.jax_dynamic_shapes:</span>
    <span class="s2">return None</span>
  <span class="s2">if </span><span class="s1">isinstance(dim</span><span class="s2">, </span><span class="s1">DArray) </span><span class="s2">and not </span><span class="s1">dim.shape </span><span class="s2">and </span><span class="s1">type(dim.dtype) </span><span class="s2">is </span><span class="s1">bint:</span>
    <span class="s2">return </span><span class="s1">DArrayDimHandler</span>
  <span class="s2">return </span><span class="s1">_SPECIAL_DIMENSION_HANDLERS.get(type(dim))</span>

<span class="s2">def </span><span class="s1">_dim_handler_and_canonical(*dlist: DimSize) -&gt; Tuple[DimensionHandler</span><span class="s2">, </span><span class="s1">Tuple[DimSize</span><span class="s2">, </span><span class="s1">...]]:</span>
  <span class="s4">&quot;&quot;&quot;Finds the handler for the given dimensions; also returns the canonical dimensions. 
 
  A dimension is canonical if it is a Python integer scalar, or has a type 
  registered in _SPECIAL_DIMENSION_HANDLERS. 
  &quot;&quot;&quot;</span>
  <span class="s1">special_handlers = set()</span>
  <span class="s1">canonical = []</span>
  <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">dlist:</span>
    <span class="s1">handler = _get_special_dim_handler(d)</span>
    <span class="s2">if </span><span class="s1">handler:</span>
      <span class="s1">special_handlers.add(handler)</span>
      <span class="s1">canonical.append(d)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">canonical.append(operator.index(d))</span>
      <span class="s2">except </span><span class="s1">TypeError:</span>
        <span class="s2">raise </span><span class="s1">_invalid_shape_error(dlist)</span>

  <span class="s2">if </span><span class="s1">len(special_handlers) &gt; </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">msg = (</span><span class="s3">f&quot;Dimension size operation involves multiple special dimension types </span><span class="s2">{</span><span class="s1">dlist</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
  <span class="s2">return </span><span class="s1">next(iter(special_handlers)</span><span class="s2">, </span><span class="s1">_dimension_handler_int)</span><span class="s2">, </span><span class="s1">tuple(canonical)</span>

<span class="s2">def </span><span class="s1">is_special_dim_size(v: Any) -&gt; bool:</span>
  <span class="s4">&quot;&quot;&quot;Checks if a value is a special DimSize.&quot;&quot;&quot;</span>
  <span class="s1">handler = _get_special_dim_handler(v)</span>
  <span class="s2">return </span><span class="s1">(handler </span><span class="s2">is not None</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">is_constant_dim(d: DimSize) -&gt; bool:</span>
  <span class="s0"># Whether the dimension is a static integer constant.</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s1">operator.index(d)</span>
    <span class="s2">return True</span>
  <span class="s2">except</span><span class="s1">:</span>
    <span class="s2">return False</span>

<span class="s2">def </span><span class="s1">is_dim(v: Any) -&gt; bool:</span>
  <span class="s2">return </span><span class="s1">is_special_dim_size(v) </span><span class="s2">or </span><span class="s1">is_constant_dim(v)</span>

<span class="s2">def </span><span class="s1">is_constant_shape(s: Shape) -&gt; bool:</span>
  <span class="s0"># Whether the shape is a static constant.</span>
  <span class="s2">return </span><span class="s1">all(is_constant_dim(d) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">s)</span>

<span class="s2">def </span><span class="s1">symbolic_equal_dim(d1: DimSize</span><span class="s2">, </span><span class="s1">d2: DimSize) -&gt; bool:</span>
  <span class="s2">if </span><span class="s1">d1 </span><span class="s2">is </span><span class="s1">d2 </span><span class="s2">or </span><span class="s1">same_referent(d1</span><span class="s2">, </span><span class="s1">d2): </span><span class="s2">return True</span>
  <span class="s1">handler</span><span class="s2">, </span><span class="s1">ds = _dim_handler_and_canonical(d1</span><span class="s2">, </span><span class="s1">d2)</span>
  <span class="s2">return </span><span class="s1">handler.symbolic_equal(*ds)</span>

<span class="s2">def </span><span class="s1">symbolic_equal_one_of_dim(d1: DimSize</span><span class="s2">, </span><span class="s1">dlist: Sequence[DimSize]) -&gt; bool:</span>
  <span class="s2">if </span><span class="s1">any(d1 </span><span class="s2">is </span><span class="s1">d </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">dlist): </span><span class="s2">return True  </span><span class="s0"># identical always implies equal</span>
  <span class="s1">handler</span><span class="s2">, </span><span class="s1">ds = _dim_handler_and_canonical(d1</span><span class="s2">, </span><span class="s1">*dlist)</span>
  <span class="s2">return </span><span class="s1">any([handler.symbolic_equal(ds[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">d) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">ds[</span><span class="s5">1</span><span class="s1">:]])</span>

<span class="s2">def </span><span class="s1">symbolic_equal_shape(s1: Shape</span><span class="s2">, </span><span class="s1">s2: Shape) -&gt; bool:</span>
  <span class="s2">return </span><span class="s1">(len(s1) == len(s2) </span><span class="s2">and</span>
          <span class="s1">all(unsafe_map(symbolic_equal_dim</span><span class="s2">, </span><span class="s1">s1</span><span class="s2">, </span><span class="s1">s2)))</span>

<span class="s2">def </span><span class="s1">greater_equal_dim(d1: DimSize</span><span class="s2">, </span><span class="s1">d2: DimSize) -&gt; bool:</span>
  <span class="s1">handler</span><span class="s2">, </span><span class="s1">ds = _dim_handler_and_canonical(d1</span><span class="s2">, </span><span class="s1">d2)</span>
  <span class="s2">return </span><span class="s1">handler.symbolic_equal(*ds) </span><span class="s2">or </span><span class="s1">handler.greater_equal(*ds)</span>

<span class="s2">def </span><span class="s1">greater_equal_shape(s1: Shape</span><span class="s2">, </span><span class="s1">s2: Shape) -&gt; bool:</span>
  <span class="s2">return </span><span class="s1">all(map(greater_equal_dim</span><span class="s2">, </span><span class="s1">s1</span><span class="s2">, </span><span class="s1">s2))</span>

<span class="s2">def </span><span class="s1">sum_dim(*ds: DimSize) -&gt; DimSize:</span>
  <span class="s1">handler</span><span class="s2">, </span><span class="s1">ds = _dim_handler_and_canonical(*ds)</span>
  <span class="s2">return </span><span class="s1">handler.sum(*ds)</span>

<span class="s2">def </span><span class="s1">sum_shapes(*ss: Shape) -&gt; Shape:</span>
  <span class="s2">return </span><span class="s1">tuple(map(sum_dim</span><span class="s2">, </span><span class="s1">*ss))</span>

<span class="s2">def </span><span class="s1">diff_dim(d1: DimSize</span><span class="s2">, </span><span class="s1">d2: DimSize) -&gt; DimSize:</span>
  <span class="s1">handler</span><span class="s2">, </span><span class="s1">ds = _dim_handler_and_canonical(d1</span><span class="s2">, </span><span class="s1">d2)</span>
  <span class="s2">return </span><span class="s1">handler.diff(*ds)</span>

<span class="s2">def </span><span class="s1">diff_shape(s1: Shape</span><span class="s2">, </span><span class="s1">s2: Shape) -&gt; Shape:</span>
  <span class="s2">return </span><span class="s1">tuple(map(diff_dim</span><span class="s2">, </span><span class="s1">s1</span><span class="s2">, </span><span class="s1">s2))</span>

<span class="s2">def </span><span class="s1">divide_shape_sizes(s1: Shape</span><span class="s2">, </span><span class="s1">s2: Shape) -&gt; DimSize:</span>
  <span class="s4">&quot;&quot;&quot;Returns an integer &quot;i&quot; s.t., i * size(s2) == size(s1). 
  Raises if there is no such integer.&quot;&quot;&quot;</span>
  <span class="s1">s1 = s1 </span><span class="s2">or </span><span class="s1">(</span><span class="s5">1</span><span class="s2">,</span><span class="s1">)</span>
  <span class="s1">s2 = s2 </span><span class="s2">or </span><span class="s1">(</span><span class="s5">1</span><span class="s2">,</span><span class="s1">)</span>
  <span class="s1">handler</span><span class="s2">, </span><span class="s1">ds = _dim_handler_and_canonical(*s1</span><span class="s2">, </span><span class="s1">*s2)</span>
  <span class="s2">return </span><span class="s1">handler.divide_shape_sizes(ds[:len(s1)]</span><span class="s2">, </span><span class="s1">ds[len(s1):])</span>

<span class="s2">def </span><span class="s1">same_shape_sizes(s1: Shape</span><span class="s2">, </span><span class="s1">s2: Shape) -&gt; bool:</span>
  <span class="s1">maybe_result = cancel_divide_tracers(s1</span><span class="s2">, </span><span class="s1">s2)</span>
  <span class="s2">if </span><span class="s1">maybe_result </span><span class="s2">is not None</span><span class="s1">: </span><span class="s2">return </span><span class="s1">maybe_result == </span><span class="s5">1</span>
  <span class="s2">return </span><span class="s5">1 </span><span class="s1">== divide_shape_sizes(s1</span><span class="s2">, </span><span class="s1">s2)</span>

<span class="s2">def </span><span class="s1">cancel_divide_tracers(num</span><span class="s2">, </span><span class="s1">denom):</span>
  <span class="s1">partition = </span><span class="s2">lambda </span><span class="s1">l: partition_list([isinstance(d</span><span class="s2">, </span><span class="s1">Tracer) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">l]</span><span class="s2">, </span><span class="s1">l)</span>
  <span class="s1">num</span><span class="s2">, </span><span class="s1">num_tracers = partition(num)</span>
  <span class="s1">denom</span><span class="s2">, </span><span class="s1">denom_tracers = partition(denom)</span>
  <span class="s2">if </span><span class="s1">num_tracers </span><span class="s2">or </span><span class="s1">denom_tracers:</span>
    <span class="s1">factor = _cancel_divide(num_tracers</span><span class="s2">, </span><span class="s1">denom_tracers)</span>
    <span class="s2">if </span><span class="s1">factor </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s1">size1 = math.prod(num)</span>
      <span class="s1">size2 = math.prod(denom)</span>
      <span class="s2">if </span><span class="s1">size1 == size2 </span><span class="s2">or </span><span class="s1">size2 != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">factor * (size1 // size2 </span><span class="s2">if </span><span class="s1">size1 != size2 </span><span class="s2">else </span><span class="s5">1</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">_cancel_divide(num</span><span class="s2">, </span><span class="s1">denom):</span>
  <span class="s1">num = list(num)</span>
  <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">denom:</span>
    <span class="s1">i = next((i </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">enumerate(num) </span><span class="s2">if </span><span class="s1">definitely_equal(a</span><span class="s2">, </span><span class="s1">b))</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">i </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s2">break  </span><span class="s0"># couldn't cancel</span>
    <span class="s2">del </span><span class="s1">num[i]</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">math.prod(num)</span>

<span class="s2">def </span><span class="s1">is_empty_shape(s: Shape) -&gt; bool:</span>
  <span class="s2">return </span><span class="s1">any(symbolic_equal_dim(d</span><span class="s2">, </span><span class="s5">0</span><span class="s1">) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">s)</span>

<span class="s2">def </span><span class="s1">dilate_dim(d: DimSize</span><span class="s2">, </span><span class="s1">dilation: DimSize) -&gt; DimSize:</span>
  <span class="s4">&quot;&quot;&quot;Implements `0 if d == 0 else 1 + dilation * (d - 1))`&quot;&quot;&quot;</span>
  <span class="s1">handler</span><span class="s2">, </span><span class="s1">ds = _dim_handler_and_canonical(d</span><span class="s2">, </span><span class="s1">dilation)</span>
  <span class="s2">return </span><span class="s1">handler.dilate(*ds)</span>

<span class="s2">def </span><span class="s1">dilate_shape(s: Shape</span><span class="s2">, </span><span class="s1">dilations: Sequence[int]) -&gt; Shape:</span>
  <span class="s2">return </span><span class="s1">tuple(map(dilate_dim</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">dilations))</span>

<span class="s2">def </span><span class="s1">stride_dim(d: DimSize</span><span class="s2">, </span><span class="s1">window_size: DimSize</span><span class="s2">, </span><span class="s1">window_stride: DimSize) -&gt; DimSize:</span>
  <span class="s1">handler</span><span class="s2">, </span><span class="s1">ds = _dim_handler_and_canonical(d</span><span class="s2">, </span><span class="s1">window_size</span><span class="s2">, </span><span class="s1">window_stride)</span>
  <span class="s2">return </span><span class="s1">handler.stride(*ds)</span>

<span class="s2">def </span><span class="s1">stride_shape(s: Shape</span><span class="s2">, </span><span class="s1">window_size: Shape</span><span class="s2">, </span><span class="s1">window_stride: Shape) -&gt; Shape:</span>
  <span class="s4">&quot;&quot;&quot;(s - window_size) // window_stride + 1&quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">tuple(map(stride_dim</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">window_size</span><span class="s2">, </span><span class="s1">window_stride))</span>

<span class="s2">def </span><span class="s1">dimension_as_value(d: DimSize):</span>
  <span class="s4">&quot;&quot;&quot;Turns a dimension size into a JAX value that we can compute with. 
     This is the identity function for constant dimensions. 
 
     Has the same abstract value as Python constants. 
     &quot;&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">isinstance(d</span><span class="s2">, </span><span class="s1">(int</span><span class="s2">, </span><span class="s1">Tracer</span><span class="s2">, </span><span class="s1">np.int32</span><span class="s2">, </span><span class="s1">np.int64)): </span><span class="s2">return </span><span class="s1">d</span>
  <span class="s0"># For shape_poly._DimPolynomial</span>
  <span class="s2">if </span><span class="s1">hasattr(d</span><span class="s2">, </span><span class="s3">&quot;dimension_as_value&quot;</span><span class="s1">): </span><span class="s2">return </span><span class="s1">d.dimension_as_value()</span>
  <span class="s2">return </span><span class="s1">operator.index(d)</span>

<span class="s2">def </span><span class="s1">_canonicalize_dimension(dim: DimSize) -&gt; DimSize:</span>
  <span class="s0"># Dimensions are most commonly integral (by far), so we check that first.</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">operator.index(dim)</span>
  <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e:</span>
    <span class="s1">type_error = e</span>
  <span class="s2">if </span><span class="s1">isinstance(dim</span><span class="s2">, </span><span class="s1">Tracer) </span><span class="s2">and </span><span class="s1">config.jax_dynamic_shapes:</span>
    <span class="s2">return </span><span class="s1">dim</span>
  <span class="s2">elif </span><span class="s1">(config.jax_dynamic_shapes </span><span class="s2">and </span><span class="s1">isinstance(dim</span><span class="s2">, </span><span class="s1">DArray) </span><span class="s2">and</span>
        <span class="s1">type(dim._aval.dtype) </span><span class="s2">is </span><span class="s1">bint </span><span class="s2">and not </span><span class="s1">dim._aval.shape):</span>
    <span class="s2">return </span><span class="s1">dim</span>
  <span class="s2">elif </span><span class="s1">is_special_dim_size(dim):</span>
    <span class="s2">return </span><span class="s1">dim</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">type_error</span>

<span class="s2">def </span><span class="s1">canonicalize_shape(shape: Shape</span><span class="s2">, </span><span class="s1">context: str=</span><span class="s3">&quot;&quot;</span><span class="s1">) -&gt; Tuple[Any</span><span class="s2">, </span><span class="s1">...]:</span>
  <span class="s4">&quot;&quot;&quot;Canonicalizes and checks for errors in a user-provided shape value. 
 
  Args: 
    shape: a Python value that represents a shape. 
 
  Returns: 
    A tuple of canonical dimension values. 
  &quot;&quot;&quot;</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">tuple(unsafe_map(_canonicalize_dimension</span><span class="s2">, </span><span class="s1">shape))</span>
  <span class="s2">except </span><span class="s1">TypeError:</span>
    <span class="s2">pass</span>
  <span class="s2">raise </span><span class="s1">_invalid_shape_error(shape</span><span class="s2">, </span><span class="s1">context)</span>

<span class="s2">def </span><span class="s1">canonicalize_dim(d: DimSize</span><span class="s2">, </span><span class="s1">context: str=</span><span class="s3">&quot;&quot;</span><span class="s1">) -&gt; DimSize:</span>
  <span class="s4">&quot;&quot;&quot;Canonicalizes and checks for errors in a user-provided shape dimension value. 
 
  Args: 
    f: a Python value that represents a dimension. 
 
  Returns: 
    A canonical dimension value. 
  &quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">canonicalize_shape((d</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">context)[</span><span class="s5">0</span><span class="s1">]</span>

<span class="s2">def </span><span class="s1">_invalid_shape_error(shape: Shape</span><span class="s2">, </span><span class="s1">context: str=</span><span class="s3">&quot;&quot;</span><span class="s1">):</span>
  <span class="s1">msg = (</span><span class="s3">&quot;Shapes must be 1D sequences of concrete values of integer type, &quot;</span>
         <span class="s3">f&quot;got </span><span class="s2">{</span><span class="s1">shape</span><span class="s2">}</span><span class="s3">.&quot;</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s1">context:</span>
    <span class="s1">msg += </span><span class="s3">f&quot; </span><span class="s2">{</span><span class="s1">context</span><span class="s2">}</span><span class="s3">.&quot;</span>
  <span class="s2">if </span><span class="s1">any(isinstance(x</span><span class="s2">, </span><span class="s1">Tracer) </span><span class="s2">and </span><span class="s1">isinstance(get_aval(x)</span><span class="s2">, </span><span class="s1">ShapedArray)</span>
         <span class="s2">and not </span><span class="s1">isinstance(get_aval(x)</span><span class="s2">, </span><span class="s1">ConcreteArray) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">shape):</span>
    <span class="s1">msg += (</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">If using `jit`, try using `static_argnums` or applying `jit` to &quot;</span>
            <span class="s3">&quot;smaller subfunctions.&quot;</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">shape:</span>
      <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">Tracer) </span><span class="s2">and </span><span class="s1">hasattr(x</span><span class="s2">, </span><span class="s3">&quot;_origin_msg&quot;</span><span class="s1">):</span>
        <span class="s1">msg += x._origin_msg()</span>

  <span class="s2">return </span><span class="s1">TypeError(msg)</span>

<span class="s2">def </span><span class="s1">evaluate_shape(shape: Shape</span><span class="s2">, </span><span class="s1">dim_vars: Sequence[str]</span><span class="s2">,</span>
                   <span class="s1">*dim_values: Array) -&gt; Sequence[Array]:</span>
  <span class="s4">&quot;&quot;&quot;Evaluates a shape possibly containing non-constants. 
 
  Args: 
    shape: the shape to evaluate. 
    dim_vars: the dimension variables names that may appear in `shape`. 
    dim_values: the dimension values corresponding to `dim_vars`. 
 
  Returns: 
     a tuple of JAX values corresponding to `shape`, of type 
     `dim_value_dtype`. 
  &quot;&quot;&quot;</span>
  <span class="s1">env = dict(zip(dim_vars</span><span class="s2">, </span><span class="s1">dim_values))</span>
  <span class="s2">def </span><span class="s1">eval_one_dim(d: DimSize):</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">operator.index(d)</span>
    <span class="s2">except</span><span class="s1">:</span>
      <span class="s0"># Is a _DimExpr</span>
      <span class="s2">return </span><span class="s1">d.evaluate(env)  </span><span class="s0"># type: ignore</span>
  <span class="s2">return </span><span class="s1">tuple(eval_one_dim(d) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">shape)</span>

<span class="s2">def </span><span class="s1">dim_value_dtype():</span>
  <span class="s4">&quot;&quot;&quot;The dtype to be used for dimension values.&quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">dtypes.canonicalize_dtype(np.int64)</span>

<span class="s2">def </span><span class="s1">dim_constant(ct: int):</span>
  <span class="s1">dtype = dim_value_dtype()</span>
  <span class="s2">assert </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">(np.int32</span><span class="s2">, </span><span class="s1">np.int64)</span>
  <span class="s2">if </span><span class="s1">dtype == np.int32:</span>
    <span class="s2">return </span><span class="s1">np.int32(ct)</span>
  <span class="s2">elif </span><span class="s1">dtype == np.int64:</span>
    <span class="s2">return </span><span class="s1">np.int64(ct)</span>

<span class="s2">def </span><span class="s1">dim_value_aval() -&gt; AbstractValue:</span>
  <span class="s2">return </span><span class="s1">ShapedArray(()</span><span class="s2">, </span><span class="s1">dim_value_dtype()</span><span class="s2">, </span><span class="s1">weak_type=</span><span class="s2">True</span><span class="s1">)</span>

<span class="s0"># ------------------- Named shapes -------------------</span>


<span class="s2">class </span><span class="s1">NamedShape:</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s1">self.__positional = canonicalize_shape(args)</span>
    <span class="s0"># TODO: Assert that kwargs match axis env?</span>
    <span class="s1">self.__named = dict(kwargs)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">rank(self):</span>
    <span class="s2">return </span><span class="s1">len(self.__positional) + len(self.__named)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">positional_rank(self):</span>
    <span class="s2">return </span><span class="s1">len(self.__positional)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">named_rank(self):</span>
    <span class="s2">return </span><span class="s1">len(self.__named)</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">positional(self):</span>
    <span class="s2">return </span><span class="s1">self.__positional</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">names(self):</span>
    <span class="s2">return </span><span class="s1">self.__named.keys()</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">named_sizes(self):</span>
    <span class="s2">return </span><span class="s1">self.__named.values()</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">named_items(self):</span>
    <span class="s2">return </span><span class="s1">self.__named.items()</span>

  <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">idx):</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s1">idx = operator.index(idx)</span>
      <span class="s2">return </span><span class="s1">self.__positional[idx]</span>
    <span class="s2">except </span><span class="s1">TypeError:</span>
      <span class="s2">pass</span>
    <span class="s2">return </span><span class="s1">self.__named[idx]</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">total(self):</span>
    <span class="s1">total = </span><span class="s5">1</span>
    <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self.__positional: total *= s</span>
    <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self.__named.values(): total *= s</span>
    <span class="s2">return </span><span class="s1">total</span>

  <span class="s2">def </span><span class="s1">__str__(self):</span>
    <span class="s0"># TODO(mattjj,frostig): revise not to miss commas</span>
    <span class="s2">if not </span><span class="s1">self.__named:</span>
      <span class="s2">return </span><span class="s1">str(self.__positional)</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">f&quot;(</span><span class="s2">{</span><span class="s3">', '</span><span class="s1">.join(map(str</span><span class="s2">, </span><span class="s1">self.__positional))</span><span class="s2">}{</span><span class="s3">', ' </span><span class="s2">if </span><span class="s1">self.__named </span><span class="s2">else </span><span class="s3">''</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s3">f&quot;</span><span class="s2">{</span><span class="s3">', '</span><span class="s1">.join(</span><span class="s3">f'</span><span class="s2">{</span><span class="s1">k</span><span class="s2">}</span><span class="s3">=</span><span class="s2">{</span><span class="s1">v</span><span class="s2">}</span><span class="s3">' </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.__named.items())</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">NamedShape):</span>
      <span class="s2">return </span><span class="s1">(self.__positional</span><span class="s2">, </span><span class="s1">self.__named) == (other.__positional</span><span class="s2">, </span><span class="s1">other.__named)</span>
    <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">tuple):</span>
      <span class="s2">return not </span><span class="s1">self.__named </span><span class="s2">and </span><span class="s1">self.__positional == other</span>
    <span class="s2">return False</span>

  <span class="s2">def </span><span class="s1">__hash__(self):</span>
    <span class="s1">named = frozenset(self.__named.items())</span>
    <span class="s2">return </span><span class="s1">hash((self.__positional</span><span class="s2">, </span><span class="s1">named))</span>

<span class="s2">def </span><span class="s1">join_named_shapes(*named_shapes):</span>
  <span class="s1">result = {}</span>
  <span class="s2">for </span><span class="s1">named_shape </span><span class="s2">in </span><span class="s1">named_shapes:</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">size </span><span class="s2">in </span><span class="s1">named_shape.items():</span>
      <span class="s2">if </span><span class="s1">result.setdefault(name</span><span class="s2">, </span><span class="s1">size) != size:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span>
            <span class="s3">f&quot;Axis name </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">used with inconsistent sizes: </span><span class="s2">{</span><span class="s1">result[name]</span><span class="s2">} </span><span class="s3">!= </span><span class="s2">{</span><span class="s1">size</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
  <span class="s2">return </span><span class="s1">result</span>

<span class="s0"># TODO: Make canonicalize_shape return named shapes?</span>
<span class="s2">def </span><span class="s1">as_named_shape(shape) -&gt; NamedShape:</span>
  <span class="s2">if </span><span class="s1">isinstance(shape</span><span class="s2">, </span><span class="s1">NamedShape):</span>
    <span class="s2">return </span><span class="s1">shape</span>
  <span class="s2">return </span><span class="s1">NamedShape(*shape)</span>


<span class="s0"># ------------------- Call -------------------</span>

<span class="s2">class </span><span class="s1">CallPrimitive(Primitive):</span>
  <span class="s1">multiple_results = </span><span class="s2">True</span>
  <span class="s1">call_primitive = </span><span class="s2">True</span>

  <span class="s2">def </span><span class="s1">bind(self</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**params):</span>
    <span class="s1">call_bind_continuation</span><span class="s2">, </span><span class="s1">top_trace</span><span class="s2">, </span><span class="s1">fun_</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params = (</span>
        <span class="s1">call_bind_with_continuation(self</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**params))</span>
    <span class="s1">outs = top_trace.process_call(self</span><span class="s2">, </span><span class="s1">fun_</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params)</span>
    <span class="s2">return </span><span class="s1">call_bind_continuation(outs)</span>

  <span class="s2">def </span><span class="s1">get_bind_params(self</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s1">new_params = dict(params)</span>
    <span class="s1">jaxpr = new_params.pop(</span><span class="s3">'call_jaxpr'</span><span class="s1">)</span>
    <span class="s1">subfun = lu.hashable_partial(lu.wrap_init(eval_jaxpr)</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">())</span>
    <span class="s2">if </span><span class="s1">config.jax_dynamic_shapes:</span>
      <span class="s1">subfun = lu.annotate(subfun</span><span class="s2">, </span><span class="s1">_jaxpr_type_to_callable_annotation(jaxpr))</span>
    <span class="s2">return </span><span class="s1">[subfun]</span><span class="s2">, </span><span class="s1">new_params</span>

<span class="s2">def </span><span class="s1">call_bind_with_continuation(primitive: CallPrimitive</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**params):</span>
  <span class="s1">top_trace = find_top_trace(args)</span>
  <span class="s1">fun_</span><span class="s2">, </span><span class="s1">env_trace_todo = process_env_traces_call(</span>
      <span class="s1">fun</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">top_trace.level</span><span class="s2">, </span><span class="s1">tuple(params.items()))</span>
  <span class="s1">tracers = map(top_trace.full_raise</span><span class="s2">, </span><span class="s1">args)</span>
  <span class="s1">fun_ = lu.annotate(fun_</span><span class="s2">, </span><span class="s1">fun.in_type)</span>

  <span class="s2">def </span><span class="s1">call_bind_continuation(outs):</span>
    <span class="s2">return </span><span class="s1">map(full_lower</span><span class="s2">, </span><span class="s1">apply_todos(env_trace_todo()</span><span class="s2">, </span><span class="s1">outs))</span>
  <span class="s2">return </span><span class="s1">call_bind_continuation</span><span class="s2">, </span><span class="s1">top_trace</span><span class="s2">, </span><span class="s1">fun_</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params</span>

<span class="s1">@lu.transformation_with_aux</span>
<span class="s2">def </span><span class="s1">process_env_traces_call(primitive: CallPrimitive</span><span class="s2">, </span><span class="s1">level: int</span><span class="s2">,</span>
                            <span class="s1">params_tuple: tuple</span><span class="s2">, </span><span class="s1">*args):</span>
  <span class="s1">outs = </span><span class="s2">yield </span><span class="s1">args</span><span class="s2">, </span><span class="s1">{}</span>
  <span class="s1">params = dict(params_tuple)</span>
  <span class="s1">todo = []</span>
  <span class="s2">while True</span><span class="s1">:</span>
    <span class="s1">tracers = [x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">outs </span><span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">Tracer) </span><span class="s2">and </span><span class="s1">x._trace.level &gt; level]</span>
    <span class="s2">if not </span><span class="s1">tracers:</span>
      <span class="s2">break</span>
    <span class="s1">ans = max(tracers</span><span class="s2">, </span><span class="s1">key=operator.attrgetter(</span><span class="s3">'_trace.level'</span><span class="s1">))</span>
    <span class="s1">trace = ans._trace.main.with_cur_sublevel()</span>
    <span class="s1">outs = map(trace.full_raise</span><span class="s2">, </span><span class="s1">outs)</span>
    <span class="s1">outs</span><span class="s2">, </span><span class="s1">cur_todo = trace.post_process_call(primitive</span><span class="s2">, </span><span class="s1">outs</span><span class="s2">, </span><span class="s1">params)</span>
    <span class="s1">todo.append(cur_todo)</span>
  <span class="s2">yield </span><span class="s1">outs</span><span class="s2">, </span><span class="s1">tuple(todo)  </span><span class="s0"># Ensure the aux output is immutable</span>

<span class="s2">def </span><span class="s1">apply_todos(todos</span><span class="s2">, </span><span class="s1">outs):</span>
  <span class="s1">todos_list = list(todos)</span>
  <span class="s2">while </span><span class="s1">todos_list:</span>
    <span class="s1">outs = map(full_lower</span><span class="s2">, </span><span class="s1">todos_list.pop()(outs))</span>
  <span class="s2">return </span><span class="s1">outs</span>


<span class="s2">def </span><span class="s1">call_impl(f: lu.WrappedFun</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**params):</span>
  <span class="s2">del </span><span class="s1">params  </span><span class="s0"># params parameterize the call primitive, not the function</span>
  <span class="s2">with </span><span class="s1">new_sublevel():</span>
    <span class="s2">return </span><span class="s1">f.call_wrapped(*args)</span>

<span class="s1">call_p: CallPrimitive = CallPrimitive(</span><span class="s3">'call'</span><span class="s1">)</span>
<span class="s1">call = call_p.bind</span>
<span class="s1">call_p.def_impl(call_impl)</span>


<span class="s2">class </span><span class="s1">ClosedCallPrimitive(CallPrimitive):</span>
  <span class="s2">def </span><span class="s1">get_bind_params(self</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s1">new_params = dict(params)</span>
    <span class="s1">jaxpr = new_params.pop(</span><span class="s3">'call_jaxpr'</span><span class="s1">)</span>
    <span class="s1">subfun = lu.wrap_init(partial(eval_jaxpr</span><span class="s2">, </span><span class="s1">jaxpr.jaxpr</span><span class="s2">, </span><span class="s1">jaxpr.consts))</span>
    <span class="s2">return </span><span class="s1">[subfun]</span><span class="s2">, </span><span class="s1">new_params</span>

<span class="s1">closed_call_p: ClosedCallPrimitive = ClosedCallPrimitive(</span><span class="s3">'closed_call'</span><span class="s1">)</span>
<span class="s1">closed_call_p.def_impl(call_impl)</span>


<span class="s1">outfeed_primitives: Set[Primitive] = set()</span>
<span class="s2">def </span><span class="s1">jaxpr_uses_outfeed(jaxpr: Jaxpr) -&gt; bool:</span>
  <span class="s4">&quot;&quot;&quot;Finds if there are outfeed primitives anywhere inside a Jaxpr.&quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">any(primitive_uses_outfeed(eqn.primitive</span><span class="s2">, </span><span class="s1">eqn.params)</span>
             <span class="s2">for </span><span class="s1">eqn </span><span class="s2">in </span><span class="s1">jaxpr.eqns)</span>

<span class="s2">def </span><span class="s1">_param_uses_outfeed(param):</span>
  <span class="s2">if </span><span class="s1">type(param) </span><span class="s2">is </span><span class="s1">Jaxpr:</span>
    <span class="s2">if </span><span class="s1">jaxpr_uses_outfeed(param):</span>
      <span class="s2">return True</span>
  <span class="s2">elif </span><span class="s1">type(param) </span><span class="s2">is </span><span class="s1">ClosedJaxpr:</span>
    <span class="s2">if </span><span class="s1">jaxpr_uses_outfeed(param.jaxpr):</span>
      <span class="s2">return True</span>
  <span class="s2">return False</span>

<span class="s2">def </span><span class="s1">primitive_uses_outfeed(prim: Primitive</span><span class="s2">, </span><span class="s1">params: Dict) -&gt; bool:</span>
  <span class="s2">if </span><span class="s1">prim </span><span class="s2">in </span><span class="s1">outfeed_primitives:</span>
    <span class="s2">return True</span>
  <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">params.values():</span>
    <span class="s2">if </span><span class="s1">isinstance(param</span><span class="s2">, </span><span class="s1">tuple):</span>
      <span class="s2">if </span><span class="s1">any(unsafe_map(_param_uses_outfeed</span><span class="s2">, </span><span class="s1">param)):</span>
        <span class="s2">return True</span>
    <span class="s2">elif </span><span class="s1">_param_uses_outfeed(param):</span>
      <span class="s2">return True</span>
  <span class="s2">return False</span>

<span class="s0"># ------------------- Map -------------------</span>

<span class="s2">class </span><span class="s1">MapPrimitive(Primitive):</span>
  <span class="s1">multiple_results = </span><span class="s2">True</span>
  <span class="s1">map_primitive = </span><span class="s2">True</span>

  <span class="s2">def </span><span class="s1">bind(self</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**params):</span>
    <span class="s2">assert </span><span class="s1">len(params[</span><span class="s3">'in_axes'</span><span class="s1">]) == len(args)</span>
    <span class="s2">return </span><span class="s1">map_bind(self</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**params)</span>

  <span class="s2">def </span><span class="s1">process(self</span><span class="s2">, </span><span class="s1">trace</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s2">return </span><span class="s1">trace.process_map(self</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params)</span>

  <span class="s2">def </span><span class="s1">post_process(self</span><span class="s2">, </span><span class="s1">trace</span><span class="s2">, </span><span class="s1">out_tracers</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s2">return </span><span class="s1">trace.post_process_map(self</span><span class="s2">, </span><span class="s1">out_tracers</span><span class="s2">, </span><span class="s1">params)</span>

  <span class="s2">def </span><span class="s1">get_bind_params(self</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s1">new_params = dict(params)</span>
    <span class="s1">jaxpr = new_params.pop(</span><span class="s3">'call_jaxpr'</span><span class="s1">)</span>
    <span class="s1">subfun = lu.hashable_partial(lu.wrap_init(eval_jaxpr)</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">())</span>
    <span class="s1">axes = new_params.pop(</span><span class="s3">'out_axes'</span><span class="s1">)</span>
    <span class="s1">new_params[</span><span class="s3">'out_axes_thunk'</span><span class="s1">] = HashableFunction(</span><span class="s2">lambda</span><span class="s1">: axes</span><span class="s2">, </span><span class="s1">closure=axes)</span>
    <span class="s2">return </span><span class="s1">[subfun]</span><span class="s2">, </span><span class="s1">new_params</span>


<span class="s2">def </span><span class="s1">map_bind_with_continuation(primitive: MapPrimitive</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">,</span>
                               <span class="s1">out_axes_thunk</span><span class="s2">, </span><span class="s1">**params):</span>
  <span class="s0"># The new thunk depends deterministically on the old thunk and the wrapped</span>
  <span class="s0"># function. Any caching already has to include the wrapped function as part</span>
  <span class="s0"># of the key, so we only use the previous thunk for equality checks.</span>
  <span class="s1">@as_hashable_function(closure=out_axes_thunk)</span>
  <span class="s2">def </span><span class="s1">new_out_axes_thunk():</span>
    <span class="s1">out_axes = out_axes_thunk()</span>
    <span class="s1">_</span><span class="s2">, </span><span class="s1">out_axes_transforms = todo_and_xforms()</span>
    <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">out_axes_transforms:</span>
      <span class="s1">out_axes = t(out_axes)</span>
    <span class="s2">return </span><span class="s1">out_axes</span>
  <span class="s1">params = dict(params</span><span class="s2">, </span><span class="s1">out_axes_thunk=new_out_axes_thunk)</span>
  <span class="s1">top_trace = find_top_trace(args)</span>
  <span class="s1">fun</span><span class="s2">, </span><span class="s1">todo_and_xforms = process_env_traces_map(</span>
      <span class="s1">fun</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">top_trace </span><span class="s2">and </span><span class="s1">top_trace.level</span><span class="s2">, </span><span class="s1">tuple(params.items()))</span>
  <span class="s1">tracers = map(top_trace.full_raise</span><span class="s2">, </span><span class="s1">args)</span>

  <span class="s2">def </span><span class="s1">map_bind_continuation(outs):</span>
    <span class="s1">env_trace_todo</span><span class="s2">, </span><span class="s1">_ = todo_and_xforms()</span>
    <span class="s2">return </span><span class="s1">map(full_lower</span><span class="s2">, </span><span class="s1">apply_todos(env_trace_todo</span><span class="s2">, </span><span class="s1">outs))</span>

  <span class="s2">return </span><span class="s1">map_bind_continuation</span><span class="s2">, </span><span class="s1">top_trace</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params</span>


<span class="s2">def </span><span class="s1">map_bind(primitive: MapPrimitive</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**params):</span>
  <span class="s1">map_bind_continuation</span><span class="s2">, </span><span class="s1">top_trace</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params = (</span>
      <span class="s1">map_bind_with_continuation(primitive</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**params))</span>
  <span class="s2">return </span><span class="s1">map_bind_continuation(</span>
      <span class="s1">primitive.process(top_trace</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params))</span>

<span class="s1">@lu.transformation_with_aux</span>
<span class="s2">def </span><span class="s1">process_env_traces_map(primitive: MapPrimitive</span><span class="s2">, </span><span class="s1">level: int</span><span class="s2">,</span>
                           <span class="s1">params_tuple: tuple</span><span class="s2">, </span><span class="s1">*args):</span>
  <span class="s1">outs = </span><span class="s2">yield </span><span class="s1">args</span><span class="s2">, </span><span class="s1">{}</span>
  <span class="s1">params = dict(params_tuple)</span>
  <span class="s1">todo = []</span>
  <span class="s1">out_axes_transforms = []</span>
  <span class="s2">while True</span><span class="s1">:</span>
    <span class="s1">tracers = [x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">outs </span><span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">Tracer)</span>
               <span class="s2">and </span><span class="s1">(level </span><span class="s2">is None or </span><span class="s1">x._trace.level &gt; level)]</span>
    <span class="s2">if not </span><span class="s1">tracers:</span>
      <span class="s2">break</span>
    <span class="s1">ans = max(tracers</span><span class="s2">, </span><span class="s1">key=operator.attrgetter(</span><span class="s3">'_trace.level'</span><span class="s1">))</span>
    <span class="s1">trace = ans._trace.main.with_cur_sublevel()</span>
    <span class="s1">outs = map(trace.full_raise</span><span class="s2">, </span><span class="s1">outs)</span>
    <span class="s1">outs</span><span class="s2">, </span><span class="s1">(cur_todo</span><span class="s2">, </span><span class="s1">cur_xform) = primitive.post_process(trace</span><span class="s2">, </span><span class="s1">outs</span><span class="s2">, </span><span class="s1">params)</span>
    <span class="s1">todo.append(cur_todo)</span>
    <span class="s1">out_axes_transforms.append(cur_xform)</span>
  <span class="s2">yield </span><span class="s1">outs</span><span class="s2">, </span><span class="s1">(tuple(todo)</span><span class="s2">, </span><span class="s1">tuple(out_axes_transforms))</span>


<span class="s2">def </span><span class="s1">mapped_aval(size: AxisSize</span><span class="s2">, </span><span class="s1">axis: Optional[int]</span><span class="s2">,</span>
                <span class="s1">aval: AbstractValue) -&gt; AbstractValue:</span>
  <span class="s1">handler</span><span class="s2">, </span><span class="s1">_ = aval_mapping_handlers.get(type(aval)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">None, None</span><span class="s1">))</span>
  <span class="s2">if </span><span class="s1">handler </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">handler(size</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">aval)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;no mapping handler for </span><span class="s2">{</span><span class="s1">aval</span><span class="s2">} </span><span class="s3">of type </span><span class="s2">{</span><span class="s1">type(aval)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">unmapped_aval(size: AxisSize</span><span class="s2">, </span><span class="s1">axis_name</span><span class="s2">, </span><span class="s1">axis: Optional[int]</span><span class="s2">,</span>
                  <span class="s1">aval: AbstractValue) -&gt; AbstractValue:</span>
  <span class="s1">_</span><span class="s2">, </span><span class="s1">handler = aval_mapping_handlers.get(type(aval)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">None, None</span><span class="s1">))</span>
  <span class="s2">if </span><span class="s1">handler </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">handler(size</span><span class="s2">, </span><span class="s1">axis_name</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">aval)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;no unmapping handler for </span><span class="s2">{</span><span class="s1">aval</span><span class="s2">} </span><span class="s3">of type </span><span class="s2">{</span><span class="s1">type(aval)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_map_shaped_array(</span>
    <span class="s1">size: int</span><span class="s2">, </span><span class="s1">axis: Optional[int]</span><span class="s2">, </span><span class="s1">aval: ShapedArray) -&gt; ShapedArray:</span>
  <span class="s2">assert </span><span class="s1">axis </span><span class="s2">is None or </span><span class="s1">aval.shape[axis] == size</span>
  <span class="s0"># TODO: Extend the named shape</span>
  <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s1">: </span><span class="s2">return </span><span class="s1">aval</span>
  <span class="s2">return </span><span class="s1">ShapedArray(tuple_delete(aval.shape</span><span class="s2">, </span><span class="s1">axis)</span><span class="s2">, </span><span class="s1">aval.dtype</span><span class="s2">,</span>
                     <span class="s1">named_shape=aval.named_shape</span><span class="s2">, </span><span class="s1">weak_type=aval.weak_type)</span>

<span class="s2">def </span><span class="s1">_unmap_shaped_array(</span>
    <span class="s1">size: int</span><span class="s2">, </span><span class="s1">axis_name: AxisName</span><span class="s2">, </span><span class="s1">axis: Optional[int]</span><span class="s2">, </span><span class="s1">aval: ShapedArray</span>
  <span class="s1">) -&gt; ShapedArray:</span>
  <span class="s1">named_shape = dict(aval.named_shape)</span>
  <span class="s1">named_shape.pop(axis_name</span><span class="s2">, None</span><span class="s1">)  </span><span class="s0"># TODO: make this mandatory</span>
  <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s1">: </span><span class="s2">return </span><span class="s1">aval.update(named_shape=named_shape)</span>
  <span class="s2">elif </span><span class="s1">type(axis) </span><span class="s2">is </span><span class="s1">int:</span>
    <span class="s2">return </span><span class="s1">ShapedArray(tuple_insert(aval.shape</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">size)</span><span class="s2">, </span><span class="s1">aval.dtype</span><span class="s2">,</span>
                       <span class="s1">named_shape=named_shape</span><span class="s2">, </span><span class="s1">weak_type=aval.weak_type)</span>
  <span class="s2">else</span><span class="s1">: </span><span class="s2">raise </span><span class="s1">TypeError(axis)</span>

<span class="s2">def </span><span class="s1">_map_dshaped_array(</span>
    <span class="s1">size: AxisSize</span><span class="s2">, </span><span class="s1">axis: Optional[int]</span><span class="s2">, </span><span class="s1">aval: DShapedArray) -&gt; DShapedArray:</span>
  <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s1">: </span><span class="s2">return </span><span class="s1">aval</span>
  <span class="s2">return </span><span class="s1">DShapedArray(tuple_delete(aval.shape</span><span class="s2">, </span><span class="s1">axis)</span><span class="s2">, </span><span class="s1">aval.dtype</span><span class="s2">,</span>
                      <span class="s1">aval.weak_type)</span>

<span class="s2">def </span><span class="s1">_unmap_dshaped_array(</span>
    <span class="s1">size: AxisSize</span><span class="s2">, </span><span class="s1">axis_name: AxisName</span><span class="s2">, </span><span class="s1">axis: Optional[int]</span><span class="s2">, </span><span class="s1">aval: DShapedArray</span>
  <span class="s1">) -&gt; DShapedArray:</span>
  <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s1">: </span><span class="s2">return </span><span class="s1">aval</span>
  <span class="s2">elif </span><span class="s1">type(axis) </span><span class="s2">is </span><span class="s1">int:</span>
    <span class="s2">return </span><span class="s1">DShapedArray(tuple_insert(aval.shape</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">size)</span><span class="s2">, </span><span class="s1">aval.dtype</span><span class="s2">,</span>
                        <span class="s1">weak_type=aval.weak_type)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">TypeError(axis)</span>

<span class="s1">AvalMapHandlerPair = Tuple[Callable</span><span class="s2">, </span><span class="s1">Callable]</span>
<span class="s1">aval_mapping_handlers: Dict[Type</span><span class="s2">, </span><span class="s1">AvalMapHandlerPair] = {</span>
    <span class="s1">DShapedArray:   (_map_dshaped_array</span><span class="s2">, </span><span class="s1">_unmap_dshaped_array)</span><span class="s2">,</span>
    <span class="s1">ShapedArray:   (_map_shaped_array</span><span class="s2">, </span><span class="s1">_unmap_shaped_array)</span><span class="s2">,</span>
    <span class="s1">ConcreteArray: (_map_shaped_array</span><span class="s2">, </span><span class="s1">_unmap_shaped_array)</span><span class="s2">,</span>
    <span class="s1">AbstractToken: (</span><span class="s2">lambda </span><span class="s1">_</span><span class="s2">, </span><span class="s1">__</span><span class="s2">, </span><span class="s1">a: a</span><span class="s2">, lambda </span><span class="s1">_</span><span class="s2">, </span><span class="s1">__</span><span class="s2">, </span><span class="s1">___</span><span class="s2">, </span><span class="s1">a: a)</span>
<span class="s1">}</span>

<span class="s1">@contextmanager</span>
<span class="s2">def </span><span class="s1">extend_axis_env(axis_name: AxisName</span><span class="s2">, </span><span class="s1">size: int</span><span class="s2">, </span><span class="s1">tag: Any):</span>
  <span class="s1">frame = AxisEnvFrame(axis_name</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">tag)</span>
  <span class="s1">ts = thread_local_state.trace_state</span>
  <span class="s1">ts.axis_env.append(frame)</span>
  <span class="s1">jax_config.update_thread_local_jit_state(</span>
      <span class="s1">axis_env_state=tuple(f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">ts.axis_env</span>
                           <span class="s2">if </span><span class="s1">f.name </span><span class="s2">is not </span><span class="s1">no_axis_name))</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">yield</span>
  <span class="s2">finally</span><span class="s1">:</span>
    <span class="s1">ts.axis_env.pop()</span>
    <span class="s1">jax_config.update_thread_local_jit_state(</span>
        <span class="s1">axis_env_state=tuple(f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">ts.axis_env</span>
                             <span class="s2">if </span><span class="s1">f.name </span><span class="s2">is not </span><span class="s1">no_axis_name))</span>

<span class="s1">@contextmanager</span>
<span class="s2">def </span><span class="s1">extend_axis_env_nd(axes: Iterable[Tuple[AxisName</span><span class="s2">, </span><span class="s1">int]]</span><span class="s2">, </span><span class="s1">tag: Any = </span><span class="s2">None</span><span class="s1">):</span>
  <span class="s1">frames = [AxisEnvFrame(axis_name</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">tag) </span><span class="s2">for </span><span class="s1">axis_name</span><span class="s2">, </span><span class="s1">size </span><span class="s2">in </span><span class="s1">axes]</span>
  <span class="s1">ts = thread_local_state.trace_state</span>
  <span class="s1">ts.axis_env.extend(frames)</span>
  <span class="s1">jax_config.update_thread_local_jit_state(</span>
      <span class="s1">axis_env_state=tuple(f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">ts.axis_env</span>
                           <span class="s2">if </span><span class="s1">f.name </span><span class="s2">is not </span><span class="s1">no_axis_name))</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">yield</span>
  <span class="s2">finally</span><span class="s1">:</span>
    <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">frames: ts.axis_env.pop()</span>
    <span class="s1">jax_config.update_thread_local_jit_state(</span>
        <span class="s1">axis_env_state=tuple(f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">ts.axis_env</span>
                             <span class="s2">if </span><span class="s1">f.name </span><span class="s2">is not </span><span class="s1">no_axis_name))</span>


<span class="s1">@contextmanager</span>
<span class="s2">def </span><span class="s1">stash_axis_env():</span>
  <span class="s4">&quot;Promise that a function or with-suite does not depend implicitly on axis env&quot;</span>
  <span class="s0"># If the promise is broken, then a NameError about an unbound axis name will</span>
  <span class="s0"># be raised.</span>
  <span class="s1">ts = thread_local_state.trace_state</span>
  <span class="s1">prev_axis_env</span><span class="s2">, </span><span class="s1">ts.axis_env = ts.axis_env</span><span class="s2">, </span><span class="s1">[]</span>
  <span class="s1">jax_config.update_thread_local_jit_state(axis_env_state=())</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">yield</span>
  <span class="s2">finally</span><span class="s1">:</span>
    <span class="s1">ts.axis_env = prev_axis_env</span>
    <span class="s1">jax_config.update_thread_local_jit_state(</span>
        <span class="s1">axis_env_state=tuple(f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">ts.axis_env</span>
                             <span class="s2">if </span><span class="s1">f.name </span><span class="s2">is not </span><span class="s1">no_axis_name))</span>


<span class="s0"># When a mapped function is given no axis name, we generate a name object based</span>
<span class="s0"># on the id of the function object. Collisions aren't important because this</span>
<span class="s0"># name can't be used in collectives, as user code never gets a ref to this</span>
<span class="s0"># object. We don't want to use the function object itself because that might</span>
<span class="s0"># persist references to the function object.</span>
<span class="s0"># TODO(mattjj): revisit this unique axis name strategy</span>
<span class="s1">@total_ordering</span>
<span class="s2">class </span><span class="s1">_TempAxisName:</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">obj):</span>
    <span class="s1">self.id = id(obj)</span>

  <span class="s2">def </span><span class="s1">__repr__(self):</span>
    <span class="s2">return </span><span class="s3">f'&lt;axis </span><span class="s2">{</span><span class="s1">hex(self.id)</span><span class="s2">}</span><span class="s3">&gt;'</span>

  <span class="s2">def </span><span class="s1">__hash__(self):</span>
    <span class="s2">return </span><span class="s1">hash(self.id)</span>

  <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return </span><span class="s1">type(other) </span><span class="s2">is </span><span class="s1">_TempAxisName </span><span class="s2">and </span><span class="s1">self.id == other.id</span>

  <span class="s2">def </span><span class="s1">__lt__(self</span><span class="s2">, </span><span class="s1">other):</span>
    <span class="s2">return </span><span class="s1">type(other) </span><span class="s2">is </span><span class="s1">_TempAxisName </span><span class="s2">and </span><span class="s1">self.id &lt; other.id</span>


<span class="s2">def </span><span class="s1">axis_frame(axis_name: AxisName</span><span class="s2">, </span><span class="s1">main_trace: Optional[MainTrace] = </span><span class="s2">None</span>
               <span class="s1">) -&gt; AxisEnvFrame:</span>
  <span class="s1">frames = thread_local_state.trace_state.axis_env</span>
  <span class="s2">for </span><span class="s1">frame </span><span class="s2">in </span><span class="s1">reversed(frames):</span>
    <span class="s2">if </span><span class="s1">(frame.name == axis_name </span><span class="s2">and</span>
        <span class="s1">(main_trace </span><span class="s2">is None or </span><span class="s1">frame.main_trace </span><span class="s2">is </span><span class="s1">main_trace)):</span>
      <span class="s2">return </span><span class="s1">frame</span>
  <span class="s1">named_axes = [frame.name </span><span class="s2">for </span><span class="s1">frame </span><span class="s2">in </span><span class="s1">reversed(frames)</span>
                <span class="s2">if not </span><span class="s1">isinstance(frame.name</span><span class="s2">, </span><span class="s1">_TempAxisName)]</span>
  <span class="s2">raise </span><span class="s1">NameError(</span>
      <span class="s3">f'unbound axis name: </span><span class="s2">{</span><span class="s1">axis_name</span><span class="s2">}</span><span class="s3">. The following axis names (e.g. defined '</span>
      <span class="s3">f'by pmap) are available to collective operations: </span><span class="s2">{</span><span class="s1">named_axes</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>


<span class="s1">ParamDict = Dict[str</span><span class="s2">, </span><span class="s1">Any]</span>
<span class="s1">AxisSubst = Callable[[AxisName]</span><span class="s2">, </span><span class="s1">Tuple[AxisName</span><span class="s2">, </span><span class="s1">...]]</span>

<span class="s2">class </span><span class="s1">NameGatheringSubst:</span>
  <span class="s2">def </span><span class="s1">__init__(self):</span>
    <span class="s1">self.axis_names = set()</span>
  <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">axis_name):</span>
    <span class="s1">self.axis_names.add(axis_name)</span>
    <span class="s2">return </span><span class="s1">(axis_name</span><span class="s2">,</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">used_axis_names(primitive: Primitive</span><span class="s2">, </span><span class="s1">params: ParamDict) -&gt; Set[AxisName]:</span>
  <span class="s1">subst = NameGatheringSubst()</span>
  <span class="s1">subst_axis_names(primitive</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">subst)</span>
  <span class="s2">return </span><span class="s1">subst.axis_names</span>

<span class="s2">def </span><span class="s1">subst_axis_names(primitive: Primitive</span><span class="s2">, </span><span class="s1">params: ParamDict</span><span class="s2">, </span><span class="s1">subst: AxisSubst</span><span class="s2">, </span><span class="s1">traverse: bool = </span><span class="s2">True</span><span class="s1">) -&gt; ParamDict:</span>
  <span class="s2">if </span><span class="s1">primitive </span><span class="s2">in </span><span class="s1">axis_substitution_rules:</span>
    <span class="s2">return </span><span class="s1">axis_substitution_rules[primitive](params</span><span class="s2">, </span><span class="s1">subst</span><span class="s2">, </span><span class="s1">traverse)</span>
  <span class="s2">if not </span><span class="s1">traverse:</span>
    <span class="s2">return </span><span class="s1">params</span>
  <span class="s0"># Default implementation: substitute names in all jaxpr parameters</span>
  <span class="s2">if </span><span class="s1">isinstance(primitive</span><span class="s2">, </span><span class="s1">MapPrimitive):</span>
    <span class="s2">def </span><span class="s1">shadowed_subst(name):</span>
      <span class="s2">return </span><span class="s1">(name</span><span class="s2">,</span><span class="s1">) </span><span class="s2">if </span><span class="s1">name == params[</span><span class="s3">'axis_name'</span><span class="s1">] </span><span class="s2">else </span><span class="s1">subst(name)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">shadowed_subst = subst</span>
  <span class="s1">jaxpr_params = [(n</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">for </span><span class="s1">n</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">params.items() </span><span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">(Jaxpr</span><span class="s2">, </span><span class="s1">ClosedJaxpr))]</span>
  <span class="s2">if not </span><span class="s1">jaxpr_params:</span>
    <span class="s2">return </span><span class="s1">params</span>
  <span class="s1">new_params = dict(params)</span>
  <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">jaxpr </span><span class="s2">in </span><span class="s1">jaxpr_params:</span>
    <span class="s1">new_params[name] = subst_axis_names_jaxpr(jaxpr</span><span class="s2">, </span><span class="s1">shadowed_subst)</span>
  <span class="s2">return </span><span class="s1">new_params</span>

<span class="s2">class </span><span class="s1">DuplicateAxisNameError(Exception):</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">var):</span>
    <span class="s1">self.var = var</span>
    <span class="s1">self.eqn = </span><span class="s2">None</span>

<span class="s2">def </span><span class="s1">subst_axis_names_var(v: Var</span><span class="s2">, </span><span class="s1">subst: AxisSubst</span><span class="s2">, </span><span class="s1">var_map: Dict[Var</span><span class="s2">, </span><span class="s1">Var]) -&gt; Var:</span>
  <span class="s0"># Var identity is load-bearing, so we can't have duplicates!</span>
  <span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">DropVar): </span><span class="s2">return </span><span class="s1">v</span>
  <span class="s2">assert </span><span class="s1">v </span><span class="s2">not in </span><span class="s1">var_map</span>
  <span class="s2">if not </span><span class="s1">hasattr(v.aval</span><span class="s2">, </span><span class="s3">'named_shape'</span><span class="s1">):</span>
    <span class="s1">var_map[v] = v</span>
    <span class="s2">return </span><span class="s1">v</span>
  <span class="s1">names = tuple(it.chain.from_iterable(subst(name) </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">v.aval.named_shape))</span>
  <span class="s1">named_shape = {name: axis_frame(name).size </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names}</span>
  <span class="s2">if </span><span class="s1">len(named_shape) != len(names):</span>
    <span class="s2">raise </span><span class="s1">DuplicateAxisNameError(v)</span>
  <span class="s1">new_v = Var(v.count</span><span class="s2">, </span><span class="s1">v.suffix</span><span class="s2">, </span><span class="s1">v.aval.update(named_shape=named_shape))</span>
  <span class="s1">var_map[v] = new_v</span>
  <span class="s2">return </span><span class="s1">new_v</span>

<span class="s2">def </span><span class="s1">subst_axis_names_eqn(eqn: JaxprEqn</span><span class="s2">, </span><span class="s1">subst: AxisSubst</span><span class="s2">, </span><span class="s1">var_map: Dict[Var</span><span class="s2">, </span><span class="s1">Var]) -&gt; JaxprEqn:</span>
  <span class="s1">invars: List[Atom] = [v </span><span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">Literal) </span><span class="s2">else </span><span class="s1">var_map[v] </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">eqn.invars]</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s1">outvars = [subst_axis_names_var(v</span><span class="s2">, </span><span class="s1">subst</span><span class="s2">, </span><span class="s1">var_map) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">eqn.outvars]</span>
  <span class="s2">except </span><span class="s1">DuplicateAxisNameError </span><span class="s2">as </span><span class="s1">e:</span>
    <span class="s1">e.eqn = eqn</span>
    <span class="s2">raise</span>
  <span class="s1">params = subst_axis_names(eqn.primitive</span><span class="s2">, </span><span class="s1">eqn.params</span><span class="s2">, </span><span class="s1">subst)</span>
  <span class="s2">return </span><span class="s1">eqn.replace(invars=invars</span><span class="s2">, </span><span class="s1">outvars=outvars</span><span class="s2">, </span><span class="s1">params=params)</span>

<span class="s2">def </span><span class="s1">do_subst_axis_names_jaxpr(jaxpr: Union[Jaxpr</span><span class="s2">, </span><span class="s1">ClosedJaxpr]</span><span class="s2">, </span><span class="s1">subst: AxisSubst):</span>
  <span class="s1">consts = </span><span class="s2">None</span>
  <span class="s2">if </span><span class="s1">isinstance(jaxpr</span><span class="s2">, </span><span class="s1">ClosedJaxpr):</span>
    <span class="s1">consts = jaxpr.consts</span>
    <span class="s1">jaxpr = jaxpr.jaxpr</span>
  <span class="s1">var_map: Dict[Var</span><span class="s2">, </span><span class="s1">Var] = {}</span>
  <span class="s1">invars = [subst_axis_names_var(v</span><span class="s2">, </span><span class="s1">subst</span><span class="s2">, </span><span class="s1">var_map) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">jaxpr.invars]  </span><span class="s0"># type: ignore[union-attr]</span>
  <span class="s1">constvars = [subst_axis_names_var(v</span><span class="s2">, </span><span class="s1">subst</span><span class="s2">, </span><span class="s1">var_map) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">jaxpr.constvars]  </span><span class="s0"># type: ignore[union-attr]</span>
  <span class="s1">eqns = [subst_axis_names_eqn(eqn</span><span class="s2">, </span><span class="s1">subst</span><span class="s2">, </span><span class="s1">var_map) </span><span class="s2">for </span><span class="s1">eqn </span><span class="s2">in </span><span class="s1">jaxpr.eqns]  </span><span class="s0"># type: ignore[union-attr]</span>
  <span class="s1">outvars: List[Atom] = [v </span><span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">Literal) </span><span class="s2">else </span><span class="s1">var_map[v] </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">jaxpr.outvars]  </span><span class="s0"># type: ignore[union-attr]</span>
  <span class="s1">new_jaxpr = Jaxpr(constvars</span><span class="s2">, </span><span class="s1">invars</span><span class="s2">, </span><span class="s1">outvars</span><span class="s2">, </span><span class="s1">eqns</span><span class="s2">, </span><span class="s1">jaxpr.effects)</span>
  <span class="s2">if </span><span class="s1">consts </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">ClosedJaxpr(new_jaxpr</span><span class="s2">, </span><span class="s1">consts)</span>
  <span class="s2">return </span><span class="s1">new_jaxpr</span>

<span class="s1">@weakref_lru_cache</span>
<span class="s2">def </span><span class="s1">used_axis_names_jaxpr(jaxpr: Union[Jaxpr</span><span class="s2">, </span><span class="s1">ClosedJaxpr]):</span>
  <span class="s1">subst = NameGatheringSubst()</span>
  <span class="s1">do_subst_axis_names_jaxpr(jaxpr</span><span class="s2">, </span><span class="s1">subst)</span>
  <span class="s2">return </span><span class="s1">frozenset(subst.axis_names)</span>

<span class="s2">def </span><span class="s1">subst_axis_names_jaxpr(jaxpr: Union[Jaxpr</span><span class="s2">, </span><span class="s1">ClosedJaxpr]</span><span class="s2">, </span><span class="s1">subst: AxisSubst):</span>
  <span class="s2">if </span><span class="s1">isinstance(subst</span><span class="s2">, </span><span class="s1">NameGatheringSubst):  </span><span class="s0"># This is a common case, so we optimize it!</span>
    <span class="s1">subst.axis_names |= used_axis_names_jaxpr(jaxpr)</span>
    <span class="s2">return </span><span class="s1">jaxpr</span>
  <span class="s2">return </span><span class="s1">do_subst_axis_names_jaxpr(jaxpr</span><span class="s2">, </span><span class="s1">subst)</span>

<span class="s2">def </span><span class="s1">replace_jaxpr_effects(jaxpr: ClosedJaxpr</span><span class="s2">, </span><span class="s1">effects: Effects):</span>
  <span class="s2">return </span><span class="s1">_replace_jaxpr_effects(jaxpr</span><span class="s2">, </span><span class="s1">frozenset(effects))</span>

<span class="s1">@weakref_lru_cache</span>
<span class="s2">def </span><span class="s1">_replace_jaxpr_effects(jaxpr: ClosedJaxpr</span><span class="s2">, </span><span class="s1">effects: FrozenSet[Effect]):</span>
  <span class="s2">return </span><span class="s1">jaxpr.replace(jaxpr=jaxpr.jaxpr.replace(effects=set(effects)))</span>


<span class="s1">axis_substitution_rules: Dict[Primitive</span><span class="s2">, </span><span class="s1">Callable[[ParamDict</span><span class="s2">, </span><span class="s1">AxisSubst</span><span class="s2">, </span><span class="s1">bool]</span><span class="s2">, </span><span class="s1">ParamDict]] = {}</span>

<span class="s0"># ------------------- AxisPrimitive -------------------</span>
<span class="s0"># Primitives that store axis names in params and want those axis names to</span>
<span class="s0"># participate in dispatch should subclass AxisPrimitive.</span>

<span class="s2">class </span><span class="s1">AxisPrimitive(Primitive):</span>
  <span class="s2">def </span><span class="s1">bind(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**params):</span>
    <span class="s1">top_trace = find_top_trace(args)</span>
    <span class="s1">axis_main = max((axis_frame(a).main_trace </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">used_axis_names(self</span><span class="s2">, </span><span class="s1">params))</span><span class="s2">,</span>
                    <span class="s1">default=</span><span class="s2">None, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">t: getattr(t</span><span class="s2">, </span><span class="s3">'level'</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">top_trace = (top_trace </span><span class="s2">if not </span><span class="s1">axis_main </span><span class="s2">or </span><span class="s1">axis_main.level &lt; top_trace.level</span>
                 <span class="s2">else </span><span class="s1">axis_main.with_cur_sublevel())</span>
    <span class="s2">return </span><span class="s1">self.bind_with_trace(top_trace</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">params)</span>


<span class="s0"># ------------------- Jaxpr checking -------------------</span>

<span class="s2">def </span><span class="s1">typecheck(aval: AbstractValue</span><span class="s2">, </span><span class="s1">x) -&gt; bool:</span>
  <span class="s2">return </span><span class="s1">typecompat(aval</span><span class="s2">, </span><span class="s1">get_aval(x))</span>

<span class="s2">def </span><span class="s1">typecompat(aval_ref: AbstractValue</span><span class="s2">, </span><span class="s1">aval: AbstractValue) -&gt; bool:</span>
  <span class="s4">&quot;&quot;&quot;Determine whether `aval` conforms to `aval_ref`. 
 
  Ignores weak_type and named_shape, other than to check that an axis name isn't 
  used with different sizes. 
  &quot;&quot;&quot;</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">typematch(aval_ref</span><span class="s2">, </span><span class="s1">lattice_join(aval_ref</span><span class="s2">, </span><span class="s1">aval))</span>
  <span class="s2">except </span><span class="s1">TypeError:</span>
    <span class="s2">return False</span>

<span class="s2">def </span><span class="s1">typematch(aval1: AbstractValue</span><span class="s2">, </span><span class="s1">aval2: AbstractValue) -&gt; bool:</span>
  <span class="s4">&quot;&quot;&quot;Determine whether `aval1` and `aval2` are equivalent. 
 
  Ignores weak_type and named_shape, other than to check that an axis name isn't 
  used with different sizes. 
  &quot;&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">aval1 == aval2: </span><span class="s2">return True</span>
  <span class="s0"># unequal avals may still represent the same type, because type is represented</span>
  <span class="s0"># by avals at the shaped level, and because weak type tags and (for now) named</span>
  <span class="s0"># shape components aren't considered part of the type</span>
  <span class="s2">if </span><span class="s1">isinstance(aval1</span><span class="s2">, </span><span class="s1">ShapedArray) </span><span class="s2">and </span><span class="s1">isinstance(aval2</span><span class="s2">, </span><span class="s1">ShapedArray):</span>
    <span class="s0"># a bonus check for whether any named axes have inconsistent sizes</span>
    <span class="s1">join_named_shapes(aval1.named_shape</span><span class="s2">, </span><span class="s1">aval2.named_shape)</span>
  <span class="s2">return </span><span class="s1">(raise_to_shaped(aval1</span><span class="s2">, </span><span class="s1">weak_type=</span><span class="s2">False</span><span class="s1">).strip_named_shape() ==</span>
          <span class="s1">raise_to_shaped(aval2</span><span class="s2">, </span><span class="s1">weak_type=</span><span class="s2">False</span><span class="s1">).strip_named_shape())</span>

<span class="s2">class </span><span class="s1">JaxprTypeError(TypeError): </span><span class="s2">pass</span>

<span class="s1">custom_typechecks: Dict[Primitive</span><span class="s2">, </span><span class="s1">Callable] = {}</span>

<span class="s2">def </span><span class="s1">_check_closed_call(_</span><span class="s2">, </span><span class="s1">*in_atoms</span><span class="s2">, </span><span class="s1">call_jaxpr):</span>
  <span class="s1">in_avals = [x.aval </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">in_atoms]</span>
  <span class="s2">if </span><span class="s1">list(in_avals) != list(call_jaxpr.in_avals):</span>
    <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">&quot;Closed call in_avals mismatch&quot;</span><span class="s1">)</span>
  <span class="s2">return </span><span class="s1">call_jaxpr.out_avals</span><span class="s2">, </span><span class="s1">call_jaxpr.effects</span>
<span class="s1">custom_typechecks[closed_call_p] = _check_closed_call</span>

<span class="s2">def </span><span class="s1">check_jaxpr(jaxpr: Jaxpr):</span>
  <span class="s4">&quot;&quot;&quot;Checks well-formedness of a jaxpr. 
 
  Specifically, check that: 
  - variables that are read are bound beforehand 
  - variables are typed equally throughout a jaxpr 
  - variable type annotations are compatible with their binding expression 
 
  Raises `JaxprTypeError` if `jaxpr` is determined invalid. Returns `None` 
  otherwise. 
  &quot;&quot;&quot;</span>
  <span class="s1">@functools.lru_cache(maxsize=</span><span class="s2">None</span><span class="s1">)</span>
  <span class="s2">def </span><span class="s1">ctx_factory():</span>
    <span class="s1">ctx = JaxprPpContext()</span>
    <span class="s1">pp_settings = JaxprPpSettings()</span>
    <span class="s2">try</span><span class="s1">: pp_jaxpr(jaxpr</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">pp_settings)  </span><span class="s0"># side-effect on ctx, build variable names</span>
    <span class="s2">except</span><span class="s1">: </span><span class="s2">pass</span>
    <span class="s2">return </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">pp_settings</span>

  <span class="s2">try</span><span class="s1">:</span>
    <span class="s1">_check_jaxpr(ctx_factory</span><span class="s2">, </span><span class="s1">jaxpr)</span>
  <span class="s2">except </span><span class="s1">JaxprTypeError </span><span class="s2">as </span><span class="s1">e:</span>
    <span class="s1">ctx</span><span class="s2">, </span><span class="s1">pp_settings = ctx_factory()</span>
    <span class="s2">if </span><span class="s1">len(e.args) == </span><span class="s5">2</span><span class="s1">:</span>
      <span class="s1">msg</span><span class="s2">, </span><span class="s1">eqnidx = e.args</span>
      <span class="s1">jaxpr_str = str(pp_jaxpr_eqn_range(jaxpr</span><span class="s2">, </span><span class="s1">eqnidx - </span><span class="s5">10</span><span class="s2">, </span><span class="s1">eqnidx + </span><span class="s5">10</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">,</span>
                                         <span class="s1">pp_settings))</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">msg</span><span class="s2">, </span><span class="s1">= e.args</span>
      <span class="s1">jaxpr_str = str(pp_jaxpr_eqn_range(jaxpr</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">pp_settings))</span>
    <span class="s1">msg = </span><span class="s3">&quot;</span><span class="s2">\n\n</span><span class="s3">&quot;</span><span class="s1">.join([msg</span><span class="s2">, </span><span class="s3">&quot;while checking jaxpr:&quot;</span><span class="s2">, </span><span class="s1">jaxpr_str])</span>
    <span class="s2">raise </span><span class="s1">JaxprTypeError(msg) </span><span class="s2">from None</span>

<span class="s2">def </span><span class="s1">_check_jaxpr(</span>
    <span class="s1">ctx_factory: Callable[[]</span><span class="s2">, </span><span class="s1">Tuple[JaxprPpContext</span><span class="s2">, </span><span class="s1">JaxprPpSettings]]</span><span class="s2">,</span>
    <span class="s1">jaxpr: Jaxpr</span>
  <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
  <span class="s0"># Use set of variables to types to check that variables are in scope.</span>
  <span class="s1">env: Set[Var] = set()</span>

  <span class="s2">def </span><span class="s1">read(x: Atom) -&gt; Atom:</span>
    <span class="s0"># Check the type annotation is itself well-typed.</span>
    <span class="s1">check_type(ctx_factory</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">x.aval)</span>
    <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">Var):</span>
      <span class="s0"># Check the variable is in-scope and consistently typed.</span>
      <span class="s2">if </span><span class="s1">x </span><span class="s2">not in </span><span class="s1">env:</span>
        <span class="s1">ctx</span><span class="s2">, </span><span class="s1">_ = ctx_factory()</span>
        <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;Variable '</span><span class="s2">{</span><span class="s1">pp_var(x</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">}</span><span class="s3">' not defined&quot;</span><span class="s1">)</span>
      <span class="s2">return </span><span class="s1">x</span>
    <span class="s2">elif </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">Literal):</span>
      <span class="s0"># Check that the literal matches its type annotation.</span>
      <span class="s2">if not </span><span class="s1">typecheck(x.aval</span><span class="s2">, </span><span class="s1">x.val):</span>
        <span class="s1">ctx</span><span class="s2">, </span><span class="s1">_ = ctx_factory()</span>
        <span class="s2">raise </span><span class="s1">JaxprTypeError(</span>
            <span class="s3">f&quot;Literal value </span><span class="s2">{</span><span class="s1">x.val</span><span class="s2">} </span><span class="s3">does not match its type annotation &quot;</span>
            <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">pp_aval(x.aval</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
      <span class="s2">return </span><span class="s1">x</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">assert False, </span><span class="s3">&quot;syntactically invalid jaxpr&quot;</span>

  <span class="s2">def </span><span class="s1">write(v: Var</span><span class="s2">, </span><span class="s1">a: AbstractValue) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">assert </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">Var)</span><span class="s2">, </span><span class="s3">&quot;syntactically invalid jaxpr&quot;</span>
    <span class="s0"># Check the type annotation of the binder is itself well-typed.</span>
    <span class="s1">check_type(ctx_factory</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">v.aval)</span>
    <span class="s0"># Check that the variable is not already bound.</span>
    <span class="s2">if </span><span class="s1">v </span><span class="s2">in </span><span class="s1">env:</span>
      <span class="s1">ctx</span><span class="s2">, </span><span class="s1">_ = ctx_factory()</span>
      <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;Variable '</span><span class="s2">{</span><span class="s1">pp_var(v</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">}</span><span class="s3">' already bound&quot;</span><span class="s1">)</span>
    <span class="s0"># Check that the computed type is consistent with the binder annotation.</span>
    <span class="s2">if not </span><span class="s1">typematch(v.aval</span><span class="s2">, </span><span class="s1">a):</span>
      <span class="s1">ctx</span><span class="s2">, </span><span class="s1">_ = ctx_factory()</span>
      <span class="s2">raise </span><span class="s1">JaxprTypeError(</span>
          <span class="s3">f&quot;Value for variable '</span><span class="s2">{</span><span class="s1">pp_var(v</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">}</span><span class="s3">' inconsistently typed &quot;</span>
          <span class="s3">f&quot;as </span><span class="s2">{</span><span class="s1">pp_aval(a</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">} </span><span class="s3">for let-binder of type </span><span class="s2">{</span><span class="s1">pp_aval(v.aval</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s0"># If the variable is not a DropVar, add it to the environment.</span>
    <span class="s2">if not </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">DropVar):</span>
      <span class="s1">env.add(v)</span>

  <span class="s0"># Check type annotations on lambda binders.</span>
  <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">it.chain(jaxpr.constvars</span><span class="s2">, </span><span class="s1">jaxpr.invars):</span>
    <span class="s1">check_type(ctx_factory</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">v.aval)</span>
    <span class="s1">write(v</span><span class="s2">, </span><span class="s1">v.aval)</span>

  <span class="s0"># Check each eqn.</span>
  <span class="s2">for </span><span class="s1">eqn_idx</span><span class="s2">, </span><span class="s1">eqn </span><span class="s2">in </span><span class="s1">enumerate(jaxpr.eqns):</span>
    <span class="s1">prim = eqn.primitive</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s1">in_atoms = map(read</span><span class="s2">, </span><span class="s1">eqn.invars)</span>
      <span class="s1">in_avals = [x.aval </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">in_atoms]  </span><span class="s0"># use in_atoms for dyn shapes</span>

      <span class="s0"># Compute the type of the primitive application.</span>
      <span class="s2">if </span><span class="s1">prim </span><span class="s2">in </span><span class="s1">custom_typechecks:</span>
        <span class="s1">out_type</span><span class="s2">, </span><span class="s1">eqn_effects = custom_typechecks[prim](</span>
          <span class="s1">ctx_factory</span><span class="s2">, </span><span class="s1">*in_atoms</span><span class="s2">, </span><span class="s1">**eqn.params)</span>
      <span class="s2">elif </span><span class="s1">prim.call_primitive:</span>
        <span class="s1">out_type</span><span class="s2">, </span><span class="s1">eqn_effects = _check_call(ctx_factory</span><span class="s2">, </span><span class="s1">prim</span><span class="s2">, </span><span class="s1">in_atoms</span><span class="s2">,</span>
                                            <span class="s1">eqn.params)</span>
      <span class="s2">elif </span><span class="s1">prim.map_primitive:</span>
        <span class="s1">out_type</span><span class="s2">, </span><span class="s1">eqn_effects = _check_map(ctx_factory</span><span class="s2">, </span><span class="s1">prim</span><span class="s2">, </span><span class="s1">in_avals</span><span class="s2">,</span>
                                           <span class="s1">eqn.params)</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">out_type</span><span class="s2">, </span><span class="s1">eqn_effects = check_eqn(prim</span><span class="s2">, </span><span class="s1">in_avals</span><span class="s2">, </span><span class="s1">eqn.params)</span>

      <span class="s0"># Check the computed effect type matches the eqn's annotation, and is</span>
      <span class="s0"># included in the jaxpr's annotation.</span>
      <span class="s2">if </span><span class="s1">eqn.effects != eqn_effects:</span>
        <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">&quot;Inferred effects do not match equation effects. &quot;</span>
                             <span class="s3">f&quot;Equation effects: </span><span class="s2">{</span><span class="s1">eqn.effects</span><span class="s2">}</span><span class="s3">. &quot;</span>
                             <span class="s3">f&quot;Inferred effects: </span><span class="s2">{</span><span class="s1">eqn_effects</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
      <span class="s2">for </span><span class="s1">eff </span><span class="s2">in </span><span class="s1">eqn.effects:</span>
        <span class="s2">if </span><span class="s1">isinstance(eff</span><span class="s2">, </span><span class="s1">effects.JaxprInputEffect):</span>
          <span class="s1">eqn_invar = eqn.invars[eff.input_index]</span>
          <span class="s1">all_vars = [*jaxpr.constvars</span><span class="s2">, </span><span class="s1">*jaxpr.invars]</span>
          <span class="s2">if </span><span class="s1">eqn_invar </span><span class="s2">not in </span><span class="s1">all_vars:</span>
            <span class="s2">raise </span><span class="s1">JaxprTypeError(</span>
                <span class="s3">&quot;Invalid `JaxprInputEffect`: must correspond to a jaxpr invar&quot;</span><span class="s1">)</span>
          <span class="s1">jaxpr_index = all_vars.index(eqn_invar)</span>
          <span class="s1">jaxpr_effect = eff.replace(input_index=jaxpr_index)</span>
          <span class="s2">if </span><span class="s1">jaxpr_effect </span><span class="s2">not in </span><span class="s1">jaxpr.effects:</span>
            <span class="s2">raise </span><span class="s1">JaxprTypeError(</span>
                <span class="s3">&quot;Invalid `JaxprInputEffect`: must be present in jaxpr. &quot;</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">jaxpr_effect</span><span class="s2">} </span><span class="s3">is not in </span><span class="s2">{</span><span class="s1">jaxpr.effects</span><span class="s2">}</span><span class="s3">.&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">eff </span><span class="s2">not in </span><span class="s1">jaxpr.effects:</span>
          <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">&quot;Equation effect not present in jaxpr effects. &quot;</span>
                               <span class="s3">f&quot;Equation effect: </span><span class="s2">{</span><span class="s1">eff</span><span class="s2">}</span><span class="s3">. &quot;</span>
                               <span class="s3">f&quot;Jaxpr effects: </span><span class="s2">{</span><span class="s1">jaxpr.effects</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

      <span class="s0"># Check out_type matches the let-binders' annotation (after substitution).</span>
      <span class="s1">out_type = substitute_vars_in_output_ty(out_type</span><span class="s2">, </span><span class="s1">eqn.invars</span><span class="s2">, </span><span class="s1">eqn.outvars)</span>
      <span class="s1">map(write</span><span class="s2">, </span><span class="s1">eqn.outvars</span><span class="s2">, </span><span class="s1">out_type)</span>

    <span class="s2">except </span><span class="s1">JaxprTypeError </span><span class="s2">as </span><span class="s1">e:</span>
      <span class="s1">ctx</span><span class="s2">, </span><span class="s1">settings = ctx_factory()</span>
      <span class="s1">msg</span><span class="s2">, </span><span class="s1">= e.args</span>
      <span class="s1">src = source_info_util.summarize(eqn.source_info)</span>
      <span class="s1">msg = </span><span class="s3">&quot;</span><span class="s2">\n\n</span><span class="s3">&quot;</span><span class="s1">.join([msg</span><span class="s2">, </span><span class="s3">&quot;in equation:&quot;</span><span class="s2">, </span><span class="s1">str(pp.nest(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">pp_eqn(eqn</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">settings)))</span><span class="s2">,</span>
                         <span class="s3">f&quot;from source: </span><span class="s2">{</span><span class="s1">src</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">])</span>
      <span class="s2">raise </span><span class="s1">JaxprTypeError(msg</span><span class="s2">, </span><span class="s1">eqn_idx) </span><span class="s2">from None</span>

  <span class="s0"># TODO(mattjj): include output type annotation on jaxpr and check it here</span>
  <span class="s1">map(read</span><span class="s2">, </span><span class="s1">jaxpr.outvars)</span>

<span class="s2">def </span><span class="s1">check_type(</span>
    <span class="s1">ctx_factory: Callable[[]</span><span class="s2">, </span><span class="s1">Tuple[JaxprPpContext</span><span class="s2">, </span><span class="s1">JaxprPpSettings]]</span><span class="s2">,</span>
    <span class="s1">env: Set[Var]</span><span class="s2">,</span>
    <span class="s1">ty: AbstractValue</span><span class="s2">,</span>
  <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
  <span class="s2">if </span><span class="s1">isinstance(ty</span><span class="s2">, </span><span class="s1">DShapedArray):</span>
    <span class="s0"># Check all elements in the shape tuple are well-typed.</span>
    <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">ty.shape:</span>
      <span class="s2">if </span><span class="s1">(isinstance(d</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">or</span>
          <span class="s1">isinstance(d</span><span class="s2">, </span><span class="s1">DArray) </span><span class="s2">and not </span><span class="s1">d.shape </span><span class="s2">and </span><span class="s1">type(d.dtype) == bint):</span>
        <span class="s2">continue</span>
      <span class="s2">elif </span><span class="s1">isinstance(d</span><span class="s2">, </span><span class="s1">Var):</span>
        <span class="s2">if </span><span class="s1">d </span><span class="s2">not in </span><span class="s1">env:</span>
          <span class="s1">ctx</span><span class="s2">, </span><span class="s1">_ = ctx_factory()</span>
          <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;unbound axis size: '</span><span class="s2">{</span><span class="s1">pp_var(d</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">}</span><span class="s3">'&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(d.aval</span><span class="s2">, </span><span class="s1">(ShapedArray</span><span class="s2">, </span><span class="s1">DShapedArray)):</span>
          <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;axis size with unexpected type annotation: &quot;</span>
                               <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">d.aval</span><span class="s2">} </span><span class="s3">of type </span><span class="s2">{</span><span class="s1">type(d.aval)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(d.aval</span><span class="s2">, </span><span class="s1">ShapedArray):</span>
          <span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype = d.aval.shape</span><span class="s2">, </span><span class="s1">d.aval.dtype</span>
          <span class="s2">if </span><span class="s1">shape: </span><span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;axis size nonscalar: </span><span class="s2">{</span><span class="s1">d.aval</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
          <span class="s2">if not </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s2">, </span><span class="s1">np.integer):</span>
            <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;axis size with non-integer dtype: </span><span class="s2">{</span><span class="s1">d.aval</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
          <span class="s2">assert </span><span class="s1">isinstance(d.aval</span><span class="s2">, </span><span class="s1">DShapedArray)</span>
          <span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype = d.aval.shape</span><span class="s2">, </span><span class="s1">d.aval.dtype</span>
          <span class="s2">if </span><span class="s1">shape: </span><span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;axis size nonscalar: </span><span class="s2">{</span><span class="s1">d.aval</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
          <span class="s2">if </span><span class="s1">type(dtype) </span><span class="s2">is not </span><span class="s1">bint:</span>
            <span class="s2">raise </span><span class="s1">JaxprTypeError(</span>
                <span class="s3">f&quot;DArray axis size with non-bint dtype: </span><span class="s2">{</span><span class="s1">d.aval</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;unexpected type in shape: </span><span class="s2">{</span><span class="s1">type(d)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return  </span><span class="s0"># Except in above case(s), all syntactic forms are valid</span>

<span class="s2">def </span><span class="s1">substitute_vars_in_output_ty(</span>
    <span class="s1">out_type: Sequence[AbstractValue]</span><span class="s2">,  </span><span class="s0"># shapes may contain InDBIdx / OutDBIdx</span>
    <span class="s1">in_atoms: Sequence[Atom]</span><span class="s2">,</span>
    <span class="s1">out_binders: Sequence[Var]</span><span class="s2">,</span>
  <span class="s1">) -&gt; List[AbstractValue]:  </span><span class="s0"># shapes may contain Vars</span>
  <span class="s1">in_atoms = [x.val </span><span class="s2">if </span><span class="s1">type(x) </span><span class="s2">is </span><span class="s1">Literal </span><span class="s2">else </span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">in_atoms]</span>
  <span class="s1">result = []</span>
  <span class="s2">for </span><span class="s1">aval </span><span class="s2">in </span><span class="s1">out_type:</span>
    <span class="s2">if </span><span class="s1">type(aval) </span><span class="s2">is </span><span class="s1">DShapedArray:</span>
      <span class="s1">shape = [in_atoms[d.val] </span><span class="s2">if </span><span class="s1">type(d) </span><span class="s2">is </span><span class="s1">InDBIdx </span><span class="s2">else  </span><span class="s0"># type: ignore</span>
               <span class="s1">out_binders[d.val] </span><span class="s2">if </span><span class="s1">type(d) </span><span class="s2">is </span><span class="s1">OutDBIdx </span><span class="s2">else  </span><span class="s0"># type: ignore</span>
               <span class="s1">d </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">aval.shape]</span>
      <span class="s1">aval = aval.update(shape=tuple(shape))</span>
    <span class="s1">result.append(aval)</span>
  <span class="s2">return </span><span class="s1">result</span>

<span class="s2">def </span><span class="s1">check_eqn(prim</span><span class="s2">, </span><span class="s1">in_avals</span><span class="s2">, </span><span class="s1">params):</span>
  <span class="s2">for </span><span class="s1">jaxpr </span><span class="s2">in </span><span class="s1">jaxprs_in_params(params):</span>
    <span class="s1">check_jaxpr(jaxpr)</span>

  <span class="s1">out_avals</span><span class="s2">, </span><span class="s1">effects = prim.abstract_eval(*in_avals</span><span class="s2">, </span><span class="s1">**params)</span>
  <span class="s2">if not </span><span class="s1">prim.multiple_results:</span>
    <span class="s1">out_avals = [out_avals]</span>
  <span class="s2">return </span><span class="s1">out_avals</span><span class="s2">, </span><span class="s1">effects</span>

<span class="s2">def </span><span class="s1">_check_call(ctx_factory</span><span class="s2">, </span><span class="s1">prim</span><span class="s2">, </span><span class="s1">in_atoms</span><span class="s2">, </span><span class="s1">params):</span>
  <span class="s2">if </span><span class="s3">&quot;call_jaxpr&quot; </span><span class="s2">not in </span><span class="s1">params:</span>
    <span class="s2">raise </span><span class="s1">JaxprTypeError(</span>
        <span class="s3">f&quot;Call primitive </span><span class="s2">{</span><span class="s1">prim</span><span class="s2">} </span><span class="s3">missing 'call_jaxpr' parameter&quot;</span><span class="s1">)</span>
  <span class="s1">call_jaxpr = params[</span><span class="s3">&quot;call_jaxpr&quot;</span><span class="s1">]</span>

  <span class="s2">if </span><span class="s1">len(in_atoms) != len(call_jaxpr.invars):</span>
    <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;Call primitive </span><span class="s2">{</span><span class="s1">prim</span><span class="s2">} </span><span class="s3">with </span><span class="s2">{</span><span class="s1">len(in_atoms)</span><span class="s2">} </span><span class="s3">&quot;</span>
                         <span class="s3">f&quot;operands cannot call jaxpr with &quot;</span>
                         <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">len(call_jaxpr.invars)</span><span class="s2">} </span><span class="s3">inputs&quot;</span><span class="s1">)</span>

  <span class="s0"># Check `call_jaxpr` can be applied to in_atoms.</span>
  <span class="s1">env: Dict[Var</span><span class="s2">, </span><span class="s1">Atom] = {}</span>
  <span class="s2">def </span><span class="s1">substitute(aval: AbstractValue):</span>
    <span class="s2">if </span><span class="s1">isinstance(aval</span><span class="s2">, </span><span class="s1">DShapedArray):</span>
      <span class="s1">aval = aval.update(shape=tuple([env.get(d</span><span class="s2">, </span><span class="s1">d) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">aval.shape]))  </span><span class="s0"># type: ignore</span>
    <span class="s2">return </span><span class="s1">aval</span>
  <span class="s2">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">zip(call_jaxpr.invars</span><span class="s2">, </span><span class="s1">in_atoms):</span>
    <span class="s2">if not </span><span class="s1">typecompat(substitute(v.aval)</span><span class="s2">, </span><span class="s1">x.aval):</span>
      <span class="s0"># TODO(mattjj): vars in error message are confusing b/c of Var.__repr__</span>
      <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;Call primitive </span><span class="s2">{</span><span class="s1">prim</span><span class="s2">} </span><span class="s3">passes operand </span><span class="s2">{</span><span class="s1">x</span><span class="s2">} </span><span class="s3">of type &quot;</span>
                           <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">x.aval</span><span class="s2">} </span><span class="s3">to jaxpr expecting type &quot;</span>
                           <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">substitute(v.aval)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">env[v] = x </span><span class="s2">if </span><span class="s1">type(x) </span><span class="s2">is </span><span class="s1">Var </span><span class="s2">else </span><span class="s1">x.val</span>

  <span class="s1">_check_jaxpr(ctx_factory</span><span class="s2">, </span><span class="s1">call_jaxpr)</span>

  <span class="s1">invars</span><span class="s2">, </span><span class="s1">outvars = call_jaxpr.invars</span><span class="s2">, </span><span class="s1">call_jaxpr.outvars</span>
  <span class="s1">in_map : Dict[Var</span><span class="s2">,  </span><span class="s1">InDBIdx] = {v:  InDBIdx(i) </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate( invars)}</span>
  <span class="s1">out_map: Dict[Var</span><span class="s2">, </span><span class="s1">OutDBIdx] = {x: OutDBIdx(i) </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(outvars)</span>
                                  <span class="s2">if </span><span class="s1">type(x) </span><span class="s2">is </span><span class="s1">Var}</span>
  <span class="s1">out_avals = [x.aval </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">call_jaxpr.outvars]</span>
  <span class="s1">out_type = [a.update(shape=tuple(in_map.get(d</span><span class="s2">, </span><span class="s1">out_map.get(d))</span>
                                   <span class="s2">if </span><span class="s1">type(d) </span><span class="s2">is </span><span class="s1">Var </span><span class="s2">else </span><span class="s1">d </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">a.shape))</span>
              <span class="s2">if </span><span class="s1">type(a) </span><span class="s2">is </span><span class="s1">DShapedArray </span><span class="s2">else </span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">out_avals]</span>
  <span class="s2">return </span><span class="s1">out_type</span><span class="s2">, </span><span class="s1">call_jaxpr.effects</span>

<span class="s2">def </span><span class="s1">_check_map(ctx_factory</span><span class="s2">, </span><span class="s1">prim</span><span class="s2">, </span><span class="s1">in_avals</span><span class="s2">, </span><span class="s1">params):</span>
  <span class="s2">if </span><span class="s3">&quot;call_jaxpr&quot; </span><span class="s2">not in </span><span class="s1">params:</span>
    <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;Map primitive </span><span class="s2">{</span><span class="s1">prim</span><span class="s2">} </span><span class="s3">missing 'call_jaxpr' parameter&quot;</span><span class="s1">)</span>
  <span class="s1">call_jaxpr = params[</span><span class="s3">&quot;call_jaxpr&quot;</span><span class="s1">]</span>
  <span class="s1">ordered_effects_ = effects.ordered_effects.filter_in(call_jaxpr.effects)</span>
  <span class="s2">if </span><span class="s1">ordered_effects_:</span>
    <span class="s2">raise </span><span class="s1">JaxprTypeError(</span>
        <span class="s3">f&quot;Map primitive </span><span class="s2">{</span><span class="s1">prim</span><span class="s2">} </span><span class="s3">mapping ordered effects: </span><span class="s2">{</span><span class="s1">ordered_effects_</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s3">&quot;axis_size&quot; </span><span class="s2">not in </span><span class="s1">params:</span>
    <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;Map primitive </span><span class="s2">{</span><span class="s1">prim</span><span class="s2">} </span><span class="s3">missing 'axis_size' parameter&quot;</span><span class="s1">)</span>
  <span class="s1">axis_size = params[</span><span class="s3">&quot;axis_size&quot;</span><span class="s1">]</span>
  <span class="s2">if </span><span class="s3">&quot;axis_name&quot; </span><span class="s2">not in </span><span class="s1">params:</span>
    <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;Map primitive </span><span class="s2">{</span><span class="s1">prim</span><span class="s2">} </span><span class="s3">missing 'axis_name' parameter&quot;</span><span class="s1">)</span>
  <span class="s1">axis_name = params[</span><span class="s3">&quot;axis_name&quot;</span><span class="s1">]</span>
  <span class="s2">if </span><span class="s3">&quot;in_axes&quot; </span><span class="s2">not in </span><span class="s1">params:</span>
    <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;Map primitive </span><span class="s2">{</span><span class="s1">prim</span><span class="s2">} </span><span class="s3">missing 'in_axes' parameter&quot;</span><span class="s1">)</span>
  <span class="s1">in_axes = params[</span><span class="s3">&quot;in_axes&quot;</span><span class="s1">]</span>
  <span class="s2">if </span><span class="s3">&quot;out_axes&quot; </span><span class="s2">not in </span><span class="s1">params:</span>
    <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;Map primitive </span><span class="s2">{</span><span class="s1">prim</span><span class="s2">} </span><span class="s3">missing 'out_axes' parameter&quot;</span><span class="s1">)</span>
  <span class="s1">out_axes = params[</span><span class="s3">&quot;out_axes&quot;</span><span class="s1">]</span>

  <span class="s1">binder_avals = [unmapped_aval(axis_size</span><span class="s2">, </span><span class="s1">axis_name</span><span class="s2">, </span><span class="s1">in_axis</span><span class="s2">, </span><span class="s1">v.aval)</span>
                  <span class="s2">if </span><span class="s1">in_axis </span><span class="s2">is not None else </span><span class="s1">v.aval</span>
                  <span class="s2">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">in_axis </span><span class="s2">in </span><span class="s1">zip(call_jaxpr.invars</span><span class="s2">, </span><span class="s1">in_axes)]</span>
  <span class="s2">for </span><span class="s1">binder_aval</span><span class="s2">, </span><span class="s1">in_aval </span><span class="s2">in </span><span class="s1">zip(binder_avals</span><span class="s2">, </span><span class="s1">in_avals):</span>
    <span class="s2">if not </span><span class="s1">typecompat(binder_aval</span><span class="s2">, </span><span class="s1">in_aval):</span>
      <span class="s2">raise </span><span class="s1">JaxprTypeError(</span><span class="s3">f&quot;Call primitive </span><span class="s2">{</span><span class="s1">prim</span><span class="s2">} </span><span class="s3">passes operand </span><span class="s2">{</span><span class="s1">in_aval</span><span class="s2">} </span><span class="s3">&quot;</span>
                           <span class="s3">f&quot;to jaxpr expecting </span><span class="s2">{</span><span class="s1">binder_aval</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

  <span class="s2">with </span><span class="s1">extend_axis_env(params[</span><span class="s3">'axis_name'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">axis_size</span><span class="s2">, None</span><span class="s1">):</span>
    <span class="s1">_check_jaxpr(ctx_factory</span><span class="s2">, </span><span class="s1">call_jaxpr)</span>

  <span class="s1">mapped_out_avals = [v.aval </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">call_jaxpr.outvars]</span>
  <span class="s1">out_avals = [unmapped_aval(axis_size</span><span class="s2">, </span><span class="s1">axis_name</span><span class="s2">, </span><span class="s1">out_axis</span><span class="s2">, </span><span class="s1">aval)</span>
               <span class="s2">if </span><span class="s1">out_axis </span><span class="s2">is not None else </span><span class="s1">aval</span>
               <span class="s2">for </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">out_axis </span><span class="s2">in </span><span class="s1">zip(mapped_out_avals</span><span class="s2">, </span><span class="s1">out_axes)]</span>
  <span class="s2">return </span><span class="s1">out_avals</span><span class="s2">, </span><span class="s1">call_jaxpr.effects</span>


<span class="s0"># ------------------- Jaxpr printed representation -------------------</span>


<span class="s2">class </span><span class="s1">JaxprPpSettings(NamedTuple):</span>
  <span class="s1">print_shapes: bool = </span><span class="s2">True</span>
  <span class="s1">source_info: bool = </span><span class="s2">False</span>
  <span class="s1">name_stack: bool = </span><span class="s2">False</span>
  <span class="s1">custom_pp_eqn_rules: bool = </span><span class="s2">True</span>
  <span class="s1">print_effects: bool = </span><span class="s2">False</span>

<span class="s0"># A JaxprPpContext allows us to globally uniquify variable names within nested</span>
<span class="s0"># Jaxprs.</span>
<span class="s2">class </span><span class="s1">JaxprPpContext:</span>
  <span class="s1">var_ids: DefaultDict[Var</span><span class="s2">, </span><span class="s1">int]</span>

  <span class="s2">def </span><span class="s1">__init__(self):</span>
    <span class="s1">self.var_ids = collections.defaultdict(it.count().__next__</span><span class="s2">, </span><span class="s1">{})</span>


<span class="s2">def </span><span class="s1">pp_var(v: Var</span><span class="s2">, </span><span class="s1">context: JaxprPpContext) -&gt; str:</span>
  <span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">(Literal</span><span class="s2">, </span><span class="s1">DropVar)): </span><span class="s2">return </span><span class="s1">str(v)</span>
  <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">_encode_digits_alphabetic(context.var_ids[v])</span><span class="s2">}{</span><span class="s1">v.suffix</span><span class="s2">}</span><span class="s3">&quot;</span>

<span class="s2">def </span><span class="s1">pp_aval(a: AbstractValue</span><span class="s2">, </span><span class="s1">context: JaxprPpContext) -&gt; str:</span>
  <span class="s2">if </span><span class="s1">isinstance(a</span><span class="s2">, </span><span class="s1">DShapedArray):</span>
    <span class="s1">shape = [pp_var(d</span><span class="s2">, </span><span class="s1">context) </span><span class="s2">if </span><span class="s1">type(d) </span><span class="s2">is </span><span class="s1">Var </span><span class="s2">else </span><span class="s1">str(d) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">a.shape]</span>
    <span class="s1">dtype = _short_dtype_name(a.dtype)</span>
    <span class="s2">return </span><span class="s3">f'</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">[</span><span class="s2">{</span><span class="s3">&quot;,&quot;</span><span class="s1">.join(shape)</span><span class="s2">}</span><span class="s3">]'</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">a.str_short(short_dtypes=</span><span class="s2">True</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">pp_vars(vs: Sequence[Any]</span><span class="s2">, </span><span class="s1">context: JaxprPpContext</span><span class="s2">,</span>
            <span class="s1">*</span><span class="s2">, </span><span class="s1">separator=</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">print_shapes: bool = </span><span class="s2">False</span><span class="s1">) -&gt; pp.Doc:</span>
  <span class="s2">if </span><span class="s1">print_shapes:</span>
    <span class="s2">return </span><span class="s1">pp.nest(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">pp.group(</span>
      <span class="s1">pp.join(pp.text(separator) + pp.group(pp.brk())</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s1">pp.text(pp_var(v</span><span class="s2">, </span><span class="s1">context)) +</span>
        <span class="s1">pp.type_annotation(pp.text(</span><span class="s3">&quot;:&quot; </span><span class="s1">+ pp_aval(v.aval</span><span class="s2">, </span><span class="s1">context)))</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vs</span>
      <span class="s1">])</span>
    <span class="s1">))</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">pp.nest(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">pp.group(</span>
      <span class="s1">pp.join(pp.text(separator) + pp.group(pp.brk())</span><span class="s2">,</span>
              <span class="s1">[pp.text(pp_var(v</span><span class="s2">, </span><span class="s1">context)) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vs])</span>
    <span class="s1">))</span>

<span class="s2">def </span><span class="s1">pp_kv_pair(k:str</span><span class="s2">, </span><span class="s1">v: Any</span><span class="s2">, </span><span class="s1">context: JaxprPpContext</span><span class="s2">, </span><span class="s1">settings: JaxprPpSettings) -&gt; pp.Doc:</span>
  <span class="s2">if </span><span class="s1">type(v) </span><span class="s2">is </span><span class="s1">tuple </span><span class="s2">and </span><span class="s1">all(isinstance(j</span><span class="s2">, </span><span class="s1">(Jaxpr</span><span class="s2">, </span><span class="s1">ClosedJaxpr)) </span><span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">v):</span>
    <span class="s1">pp_v = pp_jaxprs(v</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">settings)</span>
  <span class="s2">elif </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">Jaxpr):</span>
    <span class="s1">pp_v = pp_jaxpr(v</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">settings)</span>
  <span class="s2">elif </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">ClosedJaxpr):</span>
    <span class="s1">pp_v = pp_jaxpr(v.jaxpr</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">settings)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">pp_v = pp.text(str(v))</span>
  <span class="s2">return </span><span class="s1">pp.text(</span><span class="s3">f'</span><span class="s2">{</span><span class="s1">k</span><span class="s2">}</span><span class="s3">='</span><span class="s1">) + pp_v</span>

<span class="s2">def </span><span class="s1">pp_kv_pairs(kv_pairs</span><span class="s2">, </span><span class="s1">context: JaxprPpContext</span><span class="s2">, </span><span class="s1">settings: JaxprPpSettings) -&gt; pp.Doc:</span>
  <span class="s2">if not </span><span class="s1">kv_pairs:</span>
    <span class="s2">return </span><span class="s1">pp.nil()</span>
  <span class="s2">return </span><span class="s1">pp.group(</span>
    <span class="s1">pp.nest(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">pp.concat([</span>
      <span class="s1">pp.text(</span><span class="s3">&quot;[&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s1">pp.brk(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
      <span class="s1">pp.join(pp.brk()</span><span class="s2">, </span><span class="s1">[pp_kv_pair(k</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">settings) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kv_pairs])</span>
    <span class="s1">]))</span>
    <span class="s1">+ pp.brk(</span><span class="s3">&quot;&quot;</span><span class="s1">) + pp.text(</span><span class="s3">&quot;]&quot;</span><span class="s1">)</span>
  <span class="s1">)</span>

<span class="s2">def </span><span class="s1">pp_eqn(eqn: JaxprEqn</span><span class="s2">, </span><span class="s1">context: JaxprPpContext</span><span class="s2">, </span><span class="s1">settings: JaxprPpSettings</span>
           <span class="s1">) -&gt; pp.Doc:</span>
  <span class="s1">rule = (_pp_eqn </span><span class="s2">if not </span><span class="s1">settings.custom_pp_eqn_rules </span><span class="s2">else</span>
          <span class="s1">pp_eqn_rules.get(eqn.primitive</span><span class="s2">, </span><span class="s1">_pp_eqn))</span>
  <span class="s2">return </span><span class="s1">rule(eqn</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">settings)</span>

<span class="s2">def </span><span class="s1">_pp_eqn(eqn</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">settings) -&gt; pp.Doc:</span>
  <span class="s1">annotation = (source_info_util.summarize(eqn.source_info)</span>
                <span class="s2">if </span><span class="s1">settings.source_info </span><span class="s2">else None</span><span class="s1">)</span>
  <span class="s1">name_stack_annotation = </span><span class="s3">f'[</span><span class="s2">{</span><span class="s1">eqn.source_info.name_stack</span><span class="s2">}</span><span class="s3">]' </span><span class="s2">if </span><span class="s1">settings.name_stack </span><span class="s2">else None</span>
  <span class="s1">lhs = pp_vars(eqn.outvars</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">print_shapes=settings.print_shapes)</span>
  <span class="s1">rhs = [pp.text(eqn.primitive.name</span><span class="s2">, </span><span class="s1">annotation=name_stack_annotation)</span><span class="s2">,</span>
         <span class="s1">pp_kv_pairs(sorted(eqn.params.items())</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">settings)</span><span class="s2">,</span>
         <span class="s1">pp.text(</span><span class="s3">&quot; &quot;</span><span class="s1">) + pp_vars(eqn.invars</span><span class="s2">, </span><span class="s1">context)]</span>
  <span class="s2">return </span><span class="s1">pp.concat([lhs</span><span class="s2">, </span><span class="s1">pp.text(</span><span class="s3">&quot; = &quot;</span><span class="s2">, </span><span class="s1">annotation=annotation)</span><span class="s2">, </span><span class="s1">*rhs])</span>
<span class="s1">CustomPpEqnRule = Callable[[JaxprEqn</span><span class="s2">, </span><span class="s1">JaxprPpContext</span><span class="s2">, </span><span class="s1">JaxprPpSettings]</span><span class="s2">, </span><span class="s1">pp.Doc]</span>
<span class="s1">pp_eqn_rules: Dict[Primitive</span><span class="s2">, </span><span class="s1">CustomPpEqnRule]  = {}</span>

<span class="s2">def </span><span class="s1">pp_eqns(eqns</span><span class="s2">, </span><span class="s1">context: JaxprPpContext</span><span class="s2">, </span><span class="s1">settings: JaxprPpSettings) -&gt; pp.Doc:</span>
  <span class="s2">return </span><span class="s1">pp.join(</span>
    <span class="s1">pp.brk(</span><span class="s3">&quot;; &quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">[pp_eqn(e</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">settings) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">eqns])</span>

<span class="s2">def </span><span class="s1">_compact_eqn_should_include(k: str</span><span class="s2">, </span><span class="s1">v: Any) -&gt; bool:</span>
  <span class="s2">if </span><span class="s1">k == </span><span class="s3">'branches'</span><span class="s1">: </span><span class="s2">return False</span>
  <span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">(Jaxpr</span><span class="s2">, </span><span class="s1">ClosedJaxpr)): </span><span class="s2">return False</span>
  <span class="s2">if </span><span class="s1">(isinstance(v</span><span class="s2">, </span><span class="s1">tuple) </span><span class="s2">and</span>
      <span class="s1">any(isinstance(e</span><span class="s2">, </span><span class="s1">(Jaxpr</span><span class="s2">, </span><span class="s1">ClosedJaxpr)) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">v)):</span>
    <span class="s2">return False</span>
  <span class="s2">return True</span>

<span class="s2">def </span><span class="s1">str_eqn_compact(primitive_name: str</span><span class="s2">, </span><span class="s1">params: Dict) -&gt; str:</span>
  <span class="s4">&quot;Compact equation to string conversion used in HLO metadata.&quot;</span>
  <span class="s1">kvs = </span><span class="s3">&quot; &quot;</span><span class="s1">.join(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">k</span><span class="s2">}</span><span class="s3">=</span><span class="s2">{</span><span class="s1">v</span><span class="s2">}</span><span class="s3">&quot; </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">params.items()</span>
                 <span class="s2">if </span><span class="s1">_compact_eqn_should_include(k</span><span class="s2">, </span><span class="s1">v))</span>
  <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">primitive_name</span><span class="s2">}</span><span class="s3">[</span><span class="s2">{</span><span class="s1">kvs</span><span class="s2">}</span><span class="s3">]&quot; </span><span class="s2">if </span><span class="s1">len(kvs) &gt; </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">primitive_name</span>

<span class="s2">def </span><span class="s1">pp_jaxpr_skeleton(jaxpr</span><span class="s2">, </span><span class="s1">eqns_fn</span><span class="s2">, </span><span class="s1">context: JaxprPpContext</span><span class="s2">,</span>
                      <span class="s1">settings: JaxprPpSettings) -&gt; pp.Doc:</span>
  <span class="s1">constvars = pp_vars(jaxpr.constvars</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">print_shapes=settings.print_shapes)</span>
  <span class="s1">invars = pp_vars(jaxpr.invars</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">print_shapes=settings.print_shapes)</span>
  <span class="s1">eqns = eqns_fn()</span>
  <span class="s1">outvars = pp.concat([</span>
    <span class="s1">pp.text(</span><span class="s3">&quot;(&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">pp_vars(jaxpr.outvars</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">separator=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">pp.text(</span><span class="s3">&quot;)&quot; </span><span class="s2">if </span><span class="s1">len(jaxpr.outvars) != </span><span class="s5">1 </span><span class="s2">else </span><span class="s3">&quot;,)&quot;</span><span class="s1">)])</span>
  <span class="s2">if </span><span class="s1">settings.print_effects:</span>
    <span class="s0"># TODO(sharadmv): render an entire signature here</span>
    <span class="s1">eff_text = [pp.text(</span><span class="s3">&quot; : { &quot;</span><span class="s1">)]</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">eff </span><span class="s2">in </span><span class="s1">enumerate(jaxpr.effects):</span>
      <span class="s2">if </span><span class="s1">i &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">eff_text.append(pp.text(</span><span class="s3">&quot;, &quot;</span><span class="s1">))</span>
      <span class="s2">if </span><span class="s1">isinstance(eff</span><span class="s2">, </span><span class="s1">effects.JaxprInputEffect):</span>
        <span class="s1">index = eff.input_index</span>
        <span class="s1">all_vars = [*jaxpr.constvars</span><span class="s2">, </span><span class="s1">*jaxpr.invars]</span>
        <span class="s1">eff_text.append(pp_effect(eff.replace(input_index=all_vars[index])</span><span class="s2">,</span>
                                  <span class="s1">context))</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">eff_text.append(pp_effect(eff</span><span class="s2">, </span><span class="s1">context))</span>
    <span class="s1">eff_text.append(pp.text(</span><span class="s3">&quot; }&quot;</span><span class="s1">))</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">eff_text = []</span>
  <span class="s2">return </span><span class="s1">pp.group(pp.nest(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">pp.concat([</span>
    <span class="s1">pp.text(</span><span class="s3">&quot;{ &quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">pp.keyword(pp.text(</span><span class="s3">&quot;lambda &quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">constvars</span><span class="s2">, </span><span class="s1">pp.text(</span><span class="s3">&quot;; &quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">invars</span><span class="s2">,</span>
    <span class="s1">pp.text(</span><span class="s3">&quot;. &quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">pp.keyword(pp.text(</span><span class="s3">&quot;let&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">pp.nest(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">pp.brk() + eqns)</span><span class="s2">, </span><span class="s1">pp.brk()</span><span class="s2">,</span>
    <span class="s1">pp.keyword(pp.text(</span><span class="s3">&quot;in &quot;</span><span class="s1">))</span><span class="s2">, </span><span class="s1">outvars</span><span class="s2">,</span>
    <span class="s1">pp.concat(eff_text)</span>
  <span class="s1">])) + pp.text(</span><span class="s3">&quot; }&quot;</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">pp_jaxpr(jaxpr</span><span class="s2">, </span><span class="s1">context: JaxprPpContext</span><span class="s2">, </span><span class="s1">settings: JaxprPpSettings) -&gt; pp.Doc:</span>
  <span class="s1">eqns_fn = </span><span class="s2">lambda</span><span class="s1">: pp_eqns(jaxpr.eqns</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">settings)</span>
  <span class="s2">return </span><span class="s1">pp_jaxpr_skeleton(jaxpr</span><span class="s2">, </span><span class="s1">eqns_fn</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">settings)</span>

<span class="s2">def </span><span class="s1">pp_jaxprs(jaxprs</span><span class="s2">, </span><span class="s1">context: JaxprPpContext</span><span class="s2">, </span><span class="s1">settings: JaxprPpSettings) -&gt; pp.Doc:</span>
  <span class="s1">jaxprs = [j.jaxpr </span><span class="s2">if </span><span class="s1">isinstance(j</span><span class="s2">, </span><span class="s1">ClosedJaxpr) </span><span class="s2">else </span><span class="s1">j </span><span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">jaxprs]</span>
  <span class="s2">return </span><span class="s1">pp.group(pp.nest(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">pp.concat([</span>
      <span class="s1">pp.text(</span><span class="s3">'('</span><span class="s1">)</span><span class="s2">, </span><span class="s1">pp.brk(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
      <span class="s1">pp.join(pp.brk()</span><span class="s2">, </span><span class="s1">map(</span><span class="s2">lambda </span><span class="s1">x: pp_jaxpr(x</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">settings)</span><span class="s2">, </span><span class="s1">jaxprs))]</span>
    <span class="s1">)) + pp.brk(</span><span class="s3">&quot;&quot;</span><span class="s1">) + pp.text(</span><span class="s3">')'</span><span class="s1">)</span>
  <span class="s1">)</span>


<span class="s2">def </span><span class="s1">pp_jaxpr_eqn_range(jaxpr: Jaxpr</span><span class="s2">, </span><span class="s1">lo: int</span><span class="s2">, </span><span class="s1">hi: int</span><span class="s2">, </span><span class="s1">context: JaxprPpContext</span><span class="s2">,</span>
                       <span class="s1">settings: JaxprPpSettings) -&gt; pp.Doc:</span>
  <span class="s1">lo = max(lo</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
  <span class="s1">hi = max(lo</span><span class="s2">, </span><span class="s1">min(hi</span><span class="s2">, </span><span class="s1">len(jaxpr.eqns)))</span>
  <span class="s1">eqns = jaxpr.eqns[lo:hi]</span>
  <span class="s2">def </span><span class="s1">eqns_fn():</span>
    <span class="s1">pps = []</span>
    <span class="s2">if </span><span class="s1">len(eqns) == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">len(jaxpr.eqns) != </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">pps.append(pp.text(</span><span class="s3">'...'</span><span class="s1">))</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">if </span><span class="s1">lo != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">pps.append(pp.text(</span><span class="s3">'...'</span><span class="s1">))</span>
      <span class="s1">pps.extend(map((</span><span class="s2">lambda </span><span class="s1">e: pp_eqn(e</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">settings))</span><span class="s2">, </span><span class="s1">eqns))</span>
      <span class="s2">if </span><span class="s1">hi != len(jaxpr.eqns):</span>
        <span class="s1">pps.append(pp.text(</span><span class="s3">'...'</span><span class="s1">))</span>
    <span class="s2">return </span><span class="s1">pp.join(pp.brk(</span><span class="s3">&quot;; &quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">pps)</span>
  <span class="s2">return </span><span class="s1">pp_jaxpr_skeleton(jaxpr</span><span class="s2">, </span><span class="s1">eqns_fn</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">settings)</span>

<span class="s2">def </span><span class="s1">pp_effect(effect: Effect</span><span class="s2">, </span><span class="s1">context: JaxprPpContext) -&gt; pp.Doc:</span>
  <span class="s2">if </span><span class="s1">hasattr(effect</span><span class="s2">, </span><span class="s3">&quot;_pretty_print&quot;</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">effect._pretty_print(context)</span>
  <span class="s2">return </span><span class="s1">pp.text(str(effect))</span>
</pre>
</body>
</html>