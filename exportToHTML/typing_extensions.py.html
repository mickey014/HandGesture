<html>
<head>
<title>typing_extensions.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typing_extensions.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">abc</span>
<span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">collections.abc</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">types </span><span class="s0">as </span><span class="s1">_types</span>
<span class="s0">import </span><span class="s1">typing</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s1">__all__ = [</span>
    <span class="s2"># Super-special typing primitives.</span>
    <span class="s3">'Any'</span><span class="s0">,</span>
    <span class="s3">'ClassVar'</span><span class="s0">,</span>
    <span class="s3">'Concatenate'</span><span class="s0">,</span>
    <span class="s3">'Final'</span><span class="s0">,</span>
    <span class="s3">'LiteralString'</span><span class="s0">,</span>
    <span class="s3">'ParamSpec'</span><span class="s0">,</span>
    <span class="s3">'ParamSpecArgs'</span><span class="s0">,</span>
    <span class="s3">'ParamSpecKwargs'</span><span class="s0">,</span>
    <span class="s3">'Self'</span><span class="s0">,</span>
    <span class="s3">'Type'</span><span class="s0">,</span>
    <span class="s3">'TypeVar'</span><span class="s0">,</span>
    <span class="s3">'TypeVarTuple'</span><span class="s0">,</span>
    <span class="s3">'Unpack'</span><span class="s0">,</span>

    <span class="s2"># ABCs (from collections.abc).</span>
    <span class="s3">'Awaitable'</span><span class="s0">,</span>
    <span class="s3">'AsyncIterator'</span><span class="s0">,</span>
    <span class="s3">'AsyncIterable'</span><span class="s0">,</span>
    <span class="s3">'Coroutine'</span><span class="s0">,</span>
    <span class="s3">'AsyncGenerator'</span><span class="s0">,</span>
    <span class="s3">'AsyncContextManager'</span><span class="s0">,</span>
    <span class="s3">'Buffer'</span><span class="s0">,</span>
    <span class="s3">'ChainMap'</span><span class="s0">,</span>

    <span class="s2"># Concrete collection types.</span>
    <span class="s3">'ContextManager'</span><span class="s0">,</span>
    <span class="s3">'Counter'</span><span class="s0">,</span>
    <span class="s3">'Deque'</span><span class="s0">,</span>
    <span class="s3">'DefaultDict'</span><span class="s0">,</span>
    <span class="s3">'NamedTuple'</span><span class="s0">,</span>
    <span class="s3">'OrderedDict'</span><span class="s0">,</span>
    <span class="s3">'TypedDict'</span><span class="s0">,</span>

    <span class="s2"># Structural checks, a.k.a. protocols.</span>
    <span class="s3">'SupportsAbs'</span><span class="s0">,</span>
    <span class="s3">'SupportsBytes'</span><span class="s0">,</span>
    <span class="s3">'SupportsComplex'</span><span class="s0">,</span>
    <span class="s3">'SupportsFloat'</span><span class="s0">,</span>
    <span class="s3">'SupportsIndex'</span><span class="s0">,</span>
    <span class="s3">'SupportsInt'</span><span class="s0">,</span>
    <span class="s3">'SupportsRound'</span><span class="s0">,</span>

    <span class="s2"># One-off things.</span>
    <span class="s3">'Annotated'</span><span class="s0">,</span>
    <span class="s3">'assert_never'</span><span class="s0">,</span>
    <span class="s3">'assert_type'</span><span class="s0">,</span>
    <span class="s3">'clear_overloads'</span><span class="s0">,</span>
    <span class="s3">'dataclass_transform'</span><span class="s0">,</span>
    <span class="s3">'deprecated'</span><span class="s0">,</span>
    <span class="s3">'get_overloads'</span><span class="s0">,</span>
    <span class="s3">'final'</span><span class="s0">,</span>
    <span class="s3">'get_args'</span><span class="s0">,</span>
    <span class="s3">'get_origin'</span><span class="s0">,</span>
    <span class="s3">'get_original_bases'</span><span class="s0">,</span>
    <span class="s3">'get_type_hints'</span><span class="s0">,</span>
    <span class="s3">'IntVar'</span><span class="s0">,</span>
    <span class="s3">'is_typeddict'</span><span class="s0">,</span>
    <span class="s3">'Literal'</span><span class="s0">,</span>
    <span class="s3">'NewType'</span><span class="s0">,</span>
    <span class="s3">'overload'</span><span class="s0">,</span>
    <span class="s3">'override'</span><span class="s0">,</span>
    <span class="s3">'Protocol'</span><span class="s0">,</span>
    <span class="s3">'reveal_type'</span><span class="s0">,</span>
    <span class="s3">'runtime'</span><span class="s0">,</span>
    <span class="s3">'runtime_checkable'</span><span class="s0">,</span>
    <span class="s3">'Text'</span><span class="s0">,</span>
    <span class="s3">'TypeAlias'</span><span class="s0">,</span>
    <span class="s3">'TypeAliasType'</span><span class="s0">,</span>
    <span class="s3">'TypeGuard'</span><span class="s0">,</span>
    <span class="s3">'TYPE_CHECKING'</span><span class="s0">,</span>
    <span class="s3">'Never'</span><span class="s0">,</span>
    <span class="s3">'NoReturn'</span><span class="s0">,</span>
    <span class="s3">'Required'</span><span class="s0">,</span>
    <span class="s3">'NotRequired'</span><span class="s0">,</span>
<span class="s1">]</span>

<span class="s2"># for backward compatibility</span>
<span class="s1">PEP_560 = </span><span class="s0">True</span>
<span class="s1">GenericMeta = type</span>

<span class="s2"># The functions below are modified copies of typing internal helpers.</span>
<span class="s2"># They are needed by _ProtocolMeta and they provide support for PEP 646.</span>


<span class="s0">class </span><span class="s1">_Sentinel:</span>
    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s3">&quot;&lt;sentinel&gt;&quot;</span>


<span class="s1">_marker = _Sentinel()</span>


<span class="s0">def </span><span class="s1">_check_generic(cls</span><span class="s0">, </span><span class="s1">parameters</span><span class="s0">, </span><span class="s1">elen=_marker):</span>
    <span class="s4">&quot;&quot;&quot;Check correct count for parameters of a generic cls (internal helper). 
    This gives a nice error message in case of count mismatch. 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">elen:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">cls</span><span class="s0">} </span><span class="s3">is not a generic class&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">elen </span><span class="s0">is </span><span class="s1">_marker:</span>
        <span class="s0">if not </span><span class="s1">hasattr(cls</span><span class="s0">, </span><span class="s3">&quot;__parameters__&quot;</span><span class="s1">) </span><span class="s0">or not </span><span class="s1">cls.__parameters__:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">cls</span><span class="s0">} </span><span class="s3">is not a generic class&quot;</span><span class="s1">)</span>
        <span class="s1">elen = len(cls.__parameters__)</span>
    <span class="s1">alen = len(parameters)</span>
    <span class="s0">if </span><span class="s1">alen != elen:</span>
        <span class="s0">if </span><span class="s1">hasattr(cls</span><span class="s0">, </span><span class="s3">&quot;__parameters__&quot;</span><span class="s1">):</span>
            <span class="s1">parameters = [p </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">cls.__parameters__ </span><span class="s0">if not </span><span class="s1">_is_unpack(p)]</span>
            <span class="s1">num_tv_tuples = sum(isinstance(p</span><span class="s0">, </span><span class="s1">TypeVarTuple) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">parameters)</span>
            <span class="s0">if </span><span class="s1">(num_tv_tuples &gt; </span><span class="s5">0</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(alen &gt;= elen - num_tv_tuples):</span>
                <span class="s0">return</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Too </span><span class="s0">{</span><span class="s3">'many' </span><span class="s0">if </span><span class="s1">alen &gt; elen </span><span class="s0">else </span><span class="s3">'few'</span><span class="s0">} </span><span class="s3">parameters for </span><span class="s0">{</span><span class="s1">cls</span><span class="s0">}</span><span class="s3">;&quot;</span>
                        <span class="s3">f&quot; actual </span><span class="s0">{</span><span class="s1">alen</span><span class="s0">}</span><span class="s3">, expected </span><span class="s0">{</span><span class="s1">elen</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">10</span><span class="s1">):</span>
    <span class="s0">def </span><span class="s1">_should_collect_from_parameters(t):</span>
        <span class="s0">return </span><span class="s1">isinstance(</span>
            <span class="s1">t</span><span class="s0">, </span><span class="s1">(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_types.GenericAlias</span><span class="s0">, </span><span class="s1">_types.UnionType)</span>
        <span class="s1">)</span>
<span class="s0">elif </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
    <span class="s0">def </span><span class="s1">_should_collect_from_parameters(t):</span>
        <span class="s0">return </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_types.GenericAlias))</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">_should_collect_from_parameters(t):</span>
        <span class="s0">return </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">typing._GenericAlias) </span><span class="s0">and not </span><span class="s1">t._special</span>


<span class="s0">def </span><span class="s1">_collect_type_vars(types</span><span class="s0">, </span><span class="s1">typevar_types=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Collect all type variable contained in types in order of 
    first appearance (lexicographic order). For example:: 
 
        _collect_type_vars((T, List[S, T])) == (T, S) 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">typevar_types </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">typevar_types = typing.TypeVar</span>
    <span class="s1">tvars = []</span>
    <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">types:</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">typevar_types) </span><span class="s0">and</span>
            <span class="s1">t </span><span class="s0">not in </span><span class="s1">tvars </span><span class="s0">and</span>
            <span class="s0">not </span><span class="s1">_is_unpack(t)</span>
        <span class="s1">):</span>
            <span class="s1">tvars.append(t)</span>
        <span class="s0">if </span><span class="s1">_should_collect_from_parameters(t):</span>
            <span class="s1">tvars.extend([t </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">t.__parameters__ </span><span class="s0">if </span><span class="s1">t </span><span class="s0">not in </span><span class="s1">tvars])</span>
    <span class="s0">return </span><span class="s1">tuple(tvars)</span>


<span class="s1">NoReturn = typing.NoReturn</span>

<span class="s2"># Some unconstrained type variables.  These are used by the container types.</span>
<span class="s2"># (These are not for export.)</span>
<span class="s1">T = typing.TypeVar(</span><span class="s3">'T'</span><span class="s1">)  </span><span class="s2"># Any type.</span>
<span class="s1">KT = typing.TypeVar(</span><span class="s3">'KT'</span><span class="s1">)  </span><span class="s2"># Key type.</span>
<span class="s1">VT = typing.TypeVar(</span><span class="s3">'VT'</span><span class="s1">)  </span><span class="s2"># Value type.</span>
<span class="s1">T_co = typing.TypeVar(</span><span class="s3">'T_co'</span><span class="s0">, </span><span class="s1">covariant=</span><span class="s0">True</span><span class="s1">)  </span><span class="s2"># Any type covariant containers.</span>
<span class="s1">T_contra = typing.TypeVar(</span><span class="s3">'T_contra'</span><span class="s0">, </span><span class="s1">contravariant=</span><span class="s0">True</span><span class="s1">)  </span><span class="s2"># Ditto contravariant.</span>


<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">11</span><span class="s1">):</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span>
<span class="s0">else</span><span class="s1">:</span>

    <span class="s0">class </span><span class="s1">_AnyMeta(type):</span>
        <span class="s0">def </span><span class="s1">__instancecheck__(self</span><span class="s0">, </span><span class="s1">obj):</span>
            <span class="s0">if </span><span class="s1">self </span><span class="s0">is </span><span class="s1">Any:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;typing_extensions.Any cannot be used with isinstance()&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">super().__instancecheck__(obj)</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">if </span><span class="s1">self </span><span class="s0">is </span><span class="s1">Any:</span>
                <span class="s0">return </span><span class="s3">&quot;typing_extensions.Any&quot;</span>
            <span class="s0">return </span><span class="s1">super().__repr__()</span>

    <span class="s0">class </span><span class="s1">Any(metaclass=_AnyMeta):</span>
        <span class="s4">&quot;&quot;&quot;Special type indicating an unconstrained type. 
        - Any is compatible with every type. 
        - Any assumed to have all methods. 
        - All values assumed to be instances of Any. 
        Note that all the above statements are true from the point of view of 
        static type checkers. At runtime, Any should not be used with instance 
        checks. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">if </span><span class="s1">cls </span><span class="s0">is </span><span class="s1">Any:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Any cannot be instantiated&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">super().__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s1">ClassVar = typing.ClassVar</span>

<span class="s2"># On older versions of typing there is an internal class named &quot;Final&quot;.</span>
<span class="s2"># 3.8+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'Final'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">7</span><span class="s1">):</span>
    <span class="s1">Final = typing.Final</span>
<span class="s2"># 3.7</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_FinalForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s1">item = typing._type_check(parameters</span><span class="s0">,</span>
                                      <span class="s3">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s3">accepts only a single type.'</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">Final = _FinalForm(</span><span class="s3">'Final'</span><span class="s0">,</span>
                       <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;A special typing construct to indicate that a name 
                       cannot be re-assigned or overridden in a subclass. 
                       For example: 
 
                           MAX_SIZE: Final = 9000 
                           MAX_SIZE += 1  # Error reported by type checker 
 
                           class Connection: 
                               TIMEOUT: Final[int] = 10 
                           class FastConnector(Connection): 
                               TIMEOUT = 1  # Error reported by type checker 
 
                       There is no runtime checking of these properties.&quot;&quot;&quot;</span><span class="s1">)</span>

<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">11</span><span class="s1">):</span>
    <span class="s1">final = typing.final</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s2"># @final exists in 3.8+, but we backport it for all versions</span>
    <span class="s2"># before 3.11 to keep support for the __final__ attribute.</span>
    <span class="s2"># See https://bugs.python.org/issue46342</span>
    <span class="s0">def </span><span class="s1">final(f):</span>
        <span class="s4">&quot;&quot;&quot;This decorator can be used to indicate to type checkers that 
        the decorated method cannot be overridden, and decorated class 
        cannot be subclassed. For example: 
 
            class Base: 
                @final 
                def done(self) -&gt; None: 
                    ... 
            class Sub(Base): 
                def done(self) -&gt; None:  # Error reported by type checker 
                    ... 
            @final 
            class Leaf: 
                ... 
            class Other(Leaf):  # Error reported by type checker 
                ... 
 
        There is no runtime checking of these properties. The decorator 
        sets the ``__final__`` attribute to ``True`` on the decorated object 
        to allow runtime introspection. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">f.__final__ = </span><span class="s0">True</span>
        <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">TypeError):</span>
            <span class="s2"># Skip the attribute silently if it is not writable.</span>
            <span class="s2"># AttributeError happens if the object has __slots__ or a</span>
            <span class="s2"># read-only property, TypeError if it's a builtin class.</span>
            <span class="s0">pass</span>
        <span class="s0">return </span><span class="s1">f</span>


<span class="s0">def </span><span class="s1">IntVar(name):</span>
    <span class="s0">return </span><span class="s1">typing.TypeVar(name)</span>


<span class="s2"># A Literal bug was fixed in 3.11.0, 3.10.1 and 3.9.8</span>
<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">1</span><span class="s1">):</span>
    <span class="s1">Literal = typing.Literal</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">_flatten_literal_params(parameters):</span>
        <span class="s4">&quot;&quot;&quot;An internal helper for Literal creation: flatten Literals among parameters&quot;&quot;&quot;</span>
        <span class="s1">params = []</span>
        <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">parameters:</span>
            <span class="s0">if </span><span class="s1">isinstance(p</span><span class="s0">, </span><span class="s1">_LiteralGenericAlias):</span>
                <span class="s1">params.extend(p.__args__)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">params.append(p)</span>
        <span class="s0">return </span><span class="s1">tuple(params)</span>

    <span class="s0">def </span><span class="s1">_value_and_type_iter(params):</span>
        <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">params:</span>
            <span class="s0">yield </span><span class="s1">p</span><span class="s0">, </span><span class="s1">type(p)</span>

    <span class="s0">class </span><span class="s1">_LiteralGenericAlias(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">_LiteralGenericAlias):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s1">these_args_deduped = set(_value_and_type_iter(self.__args__))</span>
            <span class="s1">other_args_deduped = set(_value_and_type_iter(other.__args__))</span>
            <span class="s0">return </span><span class="s1">these_args_deduped == other_args_deduped</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">hash(frozenset(_value_and_type_iter(self.__args__)))</span>

    <span class="s0">class </span><span class="s1">_LiteralForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">doc: str):</span>
            <span class="s1">self._name = </span><span class="s3">'Literal'</span>
            <span class="s1">self._doc = self.__doc__ = doc</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s0">if not </span><span class="s1">isinstance(parameters</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">parameters = (parameters</span><span class="s0">,</span><span class="s1">)</span>

            <span class="s1">parameters = _flatten_literal_params(parameters)</span>

            <span class="s1">val_type_pairs = list(_value_and_type_iter(parameters))</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">deduped_pairs = set(val_type_pairs)</span>
            <span class="s0">except </span><span class="s1">TypeError:</span>
                <span class="s2"># unhashable parameters</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># similar logic to typing._deduplicate on Python 3.9+</span>
                <span class="s0">if </span><span class="s1">len(deduped_pairs) &lt; len(val_type_pairs):</span>
                    <span class="s1">new_parameters = []</span>
                    <span class="s0">for </span><span class="s1">pair </span><span class="s0">in </span><span class="s1">val_type_pairs:</span>
                        <span class="s0">if </span><span class="s1">pair </span><span class="s0">in </span><span class="s1">deduped_pairs:</span>
                            <span class="s1">new_parameters.append(pair[</span><span class="s5">0</span><span class="s1">])</span>
                            <span class="s1">deduped_pairs.remove(pair)</span>
                    <span class="s0">assert not </span><span class="s1">deduped_pairs</span><span class="s0">, </span><span class="s1">deduped_pairs</span>
                    <span class="s1">parameters = tuple(new_parameters)</span>

            <span class="s0">return </span><span class="s1">_LiteralGenericAlias(self</span><span class="s0">, </span><span class="s1">parameters)</span>

    <span class="s1">Literal = _LiteralForm(doc=</span><span class="s3">&quot;&quot;&quot;</span><span class="s0">\ 
                           </span><span class="s3">A type that can be used to indicate to type checkers 
                           that the corresponding value has a value literally equivalent 
                           to the provided parameter. For example: 
 
                               var: Literal[4] = 4 
 
                           The type checker understands that 'var' is literally equal to 
                           the value 4 and no other value. 
 
                           Literal[...] cannot be subclassed. There is no runtime 
                           checking verifying that the parameter is actually a value 
                           instead of a type.&quot;&quot;&quot;</span><span class="s1">)</span>


<span class="s1">_overload_dummy = typing._overload_dummy</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;get_overloads&quot;</span><span class="s1">):  </span><span class="s2"># 3.11+</span>
    <span class="s1">overload = typing.overload</span>
    <span class="s1">get_overloads = typing.get_overloads</span>
    <span class="s1">clear_overloads = typing.clear_overloads</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s2"># {module: {qualname: {firstlineno: func}}}</span>
    <span class="s1">_overload_registry = collections.defaultdict(</span>
        <span class="s1">functools.partial(collections.defaultdict</span><span class="s0">, </span><span class="s1">dict)</span>
    <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">overload(func):</span>
        <span class="s4">&quot;&quot;&quot;Decorator for overloaded functions/methods. 
 
        In a stub file, place two or more stub definitions for the same 
        function in a row, each decorated with @overload.  For example: 
 
        @overload 
        def utf8(value: None) -&gt; None: ... 
        @overload 
        def utf8(value: bytes) -&gt; bytes: ... 
        @overload 
        def utf8(value: str) -&gt; bytes: ... 
 
        In a non-stub file (i.e. a regular .py file), do the same but 
        follow it with an implementation.  The implementation should *not* 
        be decorated with @overload.  For example: 
 
        @overload 
        def utf8(value: None) -&gt; None: ... 
        @overload 
        def utf8(value: bytes) -&gt; bytes: ... 
        @overload 
        def utf8(value: str) -&gt; bytes: ... 
        def utf8(value): 
            # implementation goes here 
 
        The overloads for a function can be retrieved at runtime using the 
        get_overloads() function. 
        &quot;&quot;&quot;</span>
        <span class="s2"># classmethod and staticmethod</span>
        <span class="s1">f = getattr(func</span><span class="s0">, </span><span class="s3">&quot;__func__&quot;</span><span class="s0">, </span><span class="s1">func)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">_overload_registry[f.__module__][f.__qualname__][</span>
                <span class="s1">f.__code__.co_firstlineno</span>
            <span class="s1">] = func</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s2"># Not a normal function; ignore.</span>
            <span class="s0">pass</span>
        <span class="s0">return </span><span class="s1">_overload_dummy</span>

    <span class="s0">def </span><span class="s1">get_overloads(func):</span>
        <span class="s4">&quot;&quot;&quot;Return all defined overloads for *func* as a sequence.&quot;&quot;&quot;</span>
        <span class="s2"># classmethod and staticmethod</span>
        <span class="s1">f = getattr(func</span><span class="s0">, </span><span class="s3">&quot;__func__&quot;</span><span class="s0">, </span><span class="s1">func)</span>
        <span class="s0">if </span><span class="s1">f.__module__ </span><span class="s0">not in </span><span class="s1">_overload_registry:</span>
            <span class="s0">return </span><span class="s1">[]</span>
        <span class="s1">mod_dict = _overload_registry[f.__module__]</span>
        <span class="s0">if </span><span class="s1">f.__qualname__ </span><span class="s0">not in </span><span class="s1">mod_dict:</span>
            <span class="s0">return </span><span class="s1">[]</span>
        <span class="s0">return </span><span class="s1">list(mod_dict[f.__qualname__].values())</span>

    <span class="s0">def </span><span class="s1">clear_overloads():</span>
        <span class="s4">&quot;&quot;&quot;Clear all overloads in the registry.&quot;&quot;&quot;</span>
        <span class="s1">_overload_registry.clear()</span>


<span class="s2"># This is not a real generic class.  Don't use outside annotations.</span>
<span class="s1">Type = typing.Type</span>

<span class="s2"># Various ABCs mimicking those in collections.abc.</span>
<span class="s2"># A few are simply re-exported for completeness.</span>


<span class="s1">Awaitable = typing.Awaitable</span>
<span class="s1">Coroutine = typing.Coroutine</span>
<span class="s1">AsyncIterable = typing.AsyncIterable</span>
<span class="s1">AsyncIterator = typing.AsyncIterator</span>
<span class="s1">Deque = typing.Deque</span>
<span class="s1">ContextManager = typing.ContextManager</span>
<span class="s1">AsyncContextManager = typing.AsyncContextManager</span>
<span class="s1">DefaultDict = typing.DefaultDict</span>

<span class="s2"># 3.7.2+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'OrderedDict'</span><span class="s1">):</span>
    <span class="s1">OrderedDict = typing.OrderedDict</span>
<span class="s2"># 3.7.0-3.7.2</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">OrderedDict = typing._alias(collections.OrderedDict</span><span class="s0">, </span><span class="s1">(KT</span><span class="s0">, </span><span class="s1">VT))</span>

<span class="s1">Counter = typing.Counter</span>
<span class="s1">ChainMap = typing.ChainMap</span>
<span class="s1">AsyncGenerator = typing.AsyncGenerator</span>
<span class="s1">Text = typing.Text</span>
<span class="s1">TYPE_CHECKING = typing.TYPE_CHECKING</span>


<span class="s1">_PROTO_ALLOWLIST = {</span>
    <span class="s3">'collections.abc'</span><span class="s1">: [</span>
        <span class="s3">'Callable'</span><span class="s0">, </span><span class="s3">'Awaitable'</span><span class="s0">, </span><span class="s3">'Iterable'</span><span class="s0">, </span><span class="s3">'Iterator'</span><span class="s0">, </span><span class="s3">'AsyncIterable'</span><span class="s0">,</span>
        <span class="s3">'Hashable'</span><span class="s0">, </span><span class="s3">'Sized'</span><span class="s0">, </span><span class="s3">'Container'</span><span class="s0">, </span><span class="s3">'Collection'</span><span class="s0">, </span><span class="s3">'Reversible'</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s3">'contextlib'</span><span class="s1">: [</span><span class="s3">'AbstractContextManager'</span><span class="s0">, </span><span class="s3">'AbstractAsyncContextManager'</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">}</span>


<span class="s1">_EXCLUDED_ATTRS = {</span>
    <span class="s3">&quot;__abstractmethods__&quot;</span><span class="s0">, </span><span class="s3">&quot;__annotations__&quot;</span><span class="s0">, </span><span class="s3">&quot;__weakref__&quot;</span><span class="s0">, </span><span class="s3">&quot;_is_protocol&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;_is_runtime_protocol&quot;</span><span class="s0">, </span><span class="s3">&quot;__dict__&quot;</span><span class="s0">, </span><span class="s3">&quot;__slots__&quot;</span><span class="s0">, </span><span class="s3">&quot;__parameters__&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;__orig_bases__&quot;</span><span class="s0">, </span><span class="s3">&quot;__module__&quot;</span><span class="s0">, </span><span class="s3">&quot;_MutableMapping__marker&quot;</span><span class="s0">, </span><span class="s3">&quot;__doc__&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;__subclasshook__&quot;</span><span class="s0">, </span><span class="s3">&quot;__orig_class__&quot;</span><span class="s0">, </span><span class="s3">&quot;__init__&quot;</span><span class="s0">, </span><span class="s3">&quot;__new__&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;__protocol_attrs__&quot;</span><span class="s0">, </span><span class="s3">&quot;__callable_proto_members_only__&quot;</span><span class="s0">,</span>
<span class="s1">}</span>

<span class="s0">if </span><span class="s1">sys.version_info &lt; (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">8</span><span class="s1">):</span>
    <span class="s1">_EXCLUDED_ATTRS |= {</span>
        <span class="s3">&quot;_gorg&quot;</span><span class="s0">, </span><span class="s3">&quot;__next_in_mro__&quot;</span><span class="s0">, </span><span class="s3">&quot;__extra__&quot;</span><span class="s0">, </span><span class="s3">&quot;__tree_hash__&quot;</span><span class="s0">, </span><span class="s3">&quot;__args__&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;__origin__&quot;</span>
    <span class="s1">}</span>

<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
    <span class="s1">_EXCLUDED_ATTRS.add(</span><span class="s3">&quot;__class_getitem__&quot;</span><span class="s1">)</span>

<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">12</span><span class="s1">):</span>
    <span class="s1">_EXCLUDED_ATTRS.add(</span><span class="s3">&quot;__type_params__&quot;</span><span class="s1">)</span>

<span class="s1">_EXCLUDED_ATTRS = frozenset(_EXCLUDED_ATTRS)</span>


<span class="s0">def </span><span class="s1">_get_protocol_attrs(cls):</span>
    <span class="s1">attrs = set()</span>
    <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">cls.__mro__[:-</span><span class="s5">1</span><span class="s1">]:  </span><span class="s2"># without object</span>
        <span class="s0">if </span><span class="s1">base.__name__ </span><span class="s0">in </span><span class="s1">{</span><span class="s3">'Protocol'</span><span class="s0">, </span><span class="s3">'Generic'</span><span class="s1">}:</span>
            <span class="s0">continue</span>
        <span class="s1">annotations = getattr(base</span><span class="s0">, </span><span class="s3">'__annotations__'</span><span class="s0">, </span><span class="s1">{})</span>
        <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">(*base.__dict__</span><span class="s0">, </span><span class="s1">*annotations):</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">not </span><span class="s1">attr.startswith(</span><span class="s3">'_abc_'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">attr </span><span class="s0">not in </span><span class="s1">_EXCLUDED_ATTRS):</span>
                <span class="s1">attrs.add(attr)</span>
    <span class="s0">return </span><span class="s1">attrs</span>


<span class="s0">def </span><span class="s1">_maybe_adjust_parameters(cls):</span>
    <span class="s4">&quot;&quot;&quot;Helper function used in Protocol.__init_subclass__ and _TypedDictMeta.__new__. 
 
    The contents of this function are very similar 
    to logic found in typing.Generic.__init_subclass__ 
    on the CPython main branch. 
    &quot;&quot;&quot;</span>
    <span class="s1">tvars = []</span>
    <span class="s0">if </span><span class="s3">'__orig_bases__' </span><span class="s0">in </span><span class="s1">cls.__dict__:</span>
        <span class="s1">tvars = _collect_type_vars(cls.__orig_bases__)</span>
        <span class="s2"># Look for Generic[T1, ..., Tn] or Protocol[T1, ..., Tn].</span>
        <span class="s2"># If found, tvars must be a subset of it.</span>
        <span class="s2"># If not found, tvars is it.</span>
        <span class="s2"># Also check for and reject plain Generic,</span>
        <span class="s2"># and reject multiple Generic[...] and/or Protocol[...].</span>
        <span class="s1">gvars = </span><span class="s0">None</span>
        <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">cls.__orig_bases__:</span>
            <span class="s0">if </span><span class="s1">(isinstance(base</span><span class="s0">, </span><span class="s1">typing._GenericAlias) </span><span class="s0">and</span>
                    <span class="s1">base.__origin__ </span><span class="s0">in </span><span class="s1">(typing.Generic</span><span class="s0">, </span><span class="s1">Protocol)):</span>
                <span class="s2"># for error messages</span>
                <span class="s1">the_base = base.__origin__.__name__</span>
                <span class="s0">if </span><span class="s1">gvars </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s3">&quot;Cannot inherit from Generic[...]&quot;</span>
                        <span class="s3">&quot; and/or Protocol[...] multiple types.&quot;</span><span class="s1">)</span>
                <span class="s1">gvars = base.__parameters__</span>
        <span class="s0">if </span><span class="s1">gvars </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">gvars = tvars</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">tvarset = set(tvars)</span>
            <span class="s1">gvarset = set(gvars)</span>
            <span class="s0">if not </span><span class="s1">tvarset &lt;= gvarset:</span>
                <span class="s1">s_vars = </span><span class="s3">', '</span><span class="s1">.join(str(t) </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">tvars </span><span class="s0">if </span><span class="s1">t </span><span class="s0">not in </span><span class="s1">gvarset)</span>
                <span class="s1">s_args = </span><span class="s3">', '</span><span class="s1">.join(str(g) </span><span class="s0">for </span><span class="s1">g </span><span class="s0">in </span><span class="s1">gvars)</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Some type variables (</span><span class="s0">{</span><span class="s1">s_vars</span><span class="s0">}</span><span class="s3">) are&quot;</span>
                                <span class="s3">f&quot; not listed in </span><span class="s0">{</span><span class="s1">the_base</span><span class="s0">}</span><span class="s3">[</span><span class="s0">{</span><span class="s1">s_args</span><span class="s0">}</span><span class="s3">]&quot;</span><span class="s1">)</span>
            <span class="s1">tvars = gvars</span>
    <span class="s1">cls.__parameters__ = tuple(tvars)</span>


<span class="s0">def </span><span class="s1">_caller(depth=</span><span class="s5">2</span><span class="s1">):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">sys._getframe(depth).f_globals.get(</span><span class="s3">'__name__'</span><span class="s0">, </span><span class="s3">'__main__'</span><span class="s1">)</span>
    <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError):  </span><span class="s2"># For platforms without _getframe()</span>
        <span class="s0">return None</span>


<span class="s2"># The performance of runtime-checkable protocols is significantly improved on Python 3.12,</span>
<span class="s2"># so we backport the 3.12 version of Protocol to Python &lt;=3.11</span>
<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">12</span><span class="s1">):</span>
    <span class="s1">Protocol = typing.Protocol</span>
    <span class="s1">runtime_checkable = typing.runtime_checkable</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">_allow_reckless_class_checks(depth=</span><span class="s5">3</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Allow instance and class checks for special stdlib modules. 
        The abc and functools modules indiscriminately call isinstance() and 
        issubclass() on the whole MRO of a user class, which may contain protocols. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_caller(depth) </span><span class="s0">in </span><span class="s1">{</span><span class="s3">'abc'</span><span class="s0">, </span><span class="s3">'functools'</span><span class="s0">, None</span><span class="s1">}</span>

    <span class="s0">def </span><span class="s1">_no_init(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">type(self)._is_protocol:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'Protocols cannot be instantiated'</span><span class="s1">)</span>

    <span class="s0">class </span><span class="s1">_ProtocolMeta(abc.ABCMeta):</span>
        <span class="s2"># This metaclass is somewhat unfortunate,</span>
        <span class="s2"># but is necessary for several reasons...</span>
        <span class="s0">def </span><span class="s1">__init__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">if </span><span class="s1">getattr(cls</span><span class="s0">, </span><span class="s3">&quot;_is_protocol&quot;</span><span class="s0">, False</span><span class="s1">):</span>
                <span class="s1">cls.__protocol_attrs__ = _get_protocol_attrs(cls)</span>
                <span class="s2"># PEP 544 prohibits using issubclass()</span>
                <span class="s2"># with protocols that have non-method members.</span>
                <span class="s1">cls.__callable_proto_members_only__ = all(</span>
                    <span class="s1">callable(getattr(cls</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, None</span><span class="s1">)) </span><span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">cls.__protocol_attrs__</span>
                <span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__subclasscheck__(cls</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">type):</span>
                <span class="s2"># Same error message as for issubclass(1, int).</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'issubclass() arg 1 must be a class'</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">(</span>
                <span class="s1">getattr(cls</span><span class="s0">, </span><span class="s3">'_is_protocol'</span><span class="s0">, False</span><span class="s1">)</span>
                <span class="s0">and not </span><span class="s1">_allow_reckless_class_checks()</span>
            <span class="s1">):</span>
                <span class="s0">if not </span><span class="s1">cls.__callable_proto_members_only__:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s3">&quot;Protocols with non-method members don't support issubclass()&quot;</span>
                    <span class="s1">)</span>
                <span class="s0">if not </span><span class="s1">getattr(cls</span><span class="s0">, </span><span class="s3">'_is_runtime_protocol'</span><span class="s0">, False</span><span class="s1">):</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s3">&quot;Instance and class checks can only be used with &quot;</span>
                        <span class="s3">&quot;@runtime_checkable protocols&quot;</span>
                    <span class="s1">)</span>
            <span class="s0">return </span><span class="s1">super().__subclasscheck__(other)</span>

        <span class="s0">def </span><span class="s1">__instancecheck__(cls</span><span class="s0">, </span><span class="s1">instance):</span>
            <span class="s2"># We need this method for situations where attributes are</span>
            <span class="s2"># assigned in __init__.</span>
            <span class="s0">if not </span><span class="s1">getattr(cls</span><span class="s0">, </span><span class="s3">&quot;_is_protocol&quot;</span><span class="s0">, False</span><span class="s1">):</span>
                <span class="s2"># i.e., it's a concrete subclass of a protocol</span>
                <span class="s0">return </span><span class="s1">super().__instancecheck__(instance)</span>

            <span class="s0">if </span><span class="s1">(</span>
                <span class="s0">not </span><span class="s1">getattr(cls</span><span class="s0">, </span><span class="s3">'_is_runtime_protocol'</span><span class="s0">, False</span><span class="s1">) </span><span class="s0">and</span>
                <span class="s0">not </span><span class="s1">_allow_reckless_class_checks()</span>
            <span class="s1">):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Instance and class checks can only be used with&quot;</span>
                                <span class="s3">&quot; @runtime_checkable protocols&quot;</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">super().__instancecheck__(instance):</span>
                <span class="s0">return True</span>

            <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">cls.__protocol_attrs__:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">val = inspect.getattr_static(instance</span><span class="s0">, </span><span class="s1">attr)</span>
                <span class="s0">except </span><span class="s1">AttributeError:</span>
                    <span class="s0">break</span>
                <span class="s0">if </span><span class="s1">val </span><span class="s0">is None and </span><span class="s1">callable(getattr(cls</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, None</span><span class="s1">)):</span>
                    <span class="s0">break</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return True</span>

            <span class="s0">return False</span>

        <span class="s0">def </span><span class="s1">__eq__(cls</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s2"># Hack so that typing.Generic.__class_getitem__</span>
            <span class="s2"># treats typing_extensions.Protocol</span>
            <span class="s2"># as equivalent to typing.Protocol on Python 3.8+</span>
            <span class="s0">if </span><span class="s1">super().__eq__(other) </span><span class="s0">is True</span><span class="s1">:</span>
                <span class="s0">return True</span>
            <span class="s0">return </span><span class="s1">(</span>
                <span class="s1">cls </span><span class="s0">is </span><span class="s1">Protocol </span><span class="s0">and </span><span class="s1">other </span><span class="s0">is </span><span class="s1">getattr(typing</span><span class="s0">, </span><span class="s3">&quot;Protocol&quot;</span><span class="s0">, </span><span class="s1">object())</span>
            <span class="s1">)</span>

        <span class="s2"># This has to be defined, or the abc-module cache</span>
        <span class="s2"># complains about classes with this metaclass being unhashable,</span>
        <span class="s2"># if we define only __eq__!</span>
        <span class="s0">def </span><span class="s1">__hash__(cls) -&gt; int:</span>
            <span class="s0">return </span><span class="s1">type.__hash__(cls)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_proto_hook(cls</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">if not </span><span class="s1">cls.__dict__.get(</span><span class="s3">'_is_protocol'</span><span class="s0">, False</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">cls.__protocol_attrs__:</span>
            <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">other.__mro__:</span>
                <span class="s2"># Check if the members appears in the class dictionary...</span>
                <span class="s0">if </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">base.__dict__:</span>
                    <span class="s0">if </span><span class="s1">base.__dict__[attr] </span><span class="s0">is None</span><span class="s1">:</span>
                        <span class="s0">return </span><span class="s1">NotImplemented</span>
                    <span class="s0">break</span>

                <span class="s2"># ...or in annotations, if it is a sub-protocol.</span>
                <span class="s1">annotations = getattr(base</span><span class="s0">, </span><span class="s3">'__annotations__'</span><span class="s0">, </span><span class="s1">{})</span>
                <span class="s0">if </span><span class="s1">(</span>
                    <span class="s1">isinstance(annotations</span><span class="s0">, </span><span class="s1">collections.abc.Mapping)</span>
                    <span class="s0">and </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">annotations</span>
                    <span class="s0">and </span><span class="s1">issubclass(other</span><span class="s0">, </span><span class="s1">(typing.Generic</span><span class="s0">, </span><span class="s1">_ProtocolMeta))</span>
                    <span class="s0">and </span><span class="s1">getattr(other</span><span class="s0">, </span><span class="s3">&quot;_is_protocol&quot;</span><span class="s0">, False</span><span class="s1">)</span>
                <span class="s1">):</span>
                    <span class="s0">break</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">_check_proto_bases(cls):</span>
        <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">cls.__bases__:</span>
            <span class="s0">if not </span><span class="s1">(base </span><span class="s0">in </span><span class="s1">(object</span><span class="s0">, </span><span class="s1">typing.Generic) </span><span class="s0">or</span>
                    <span class="s1">base.__module__ </span><span class="s0">in </span><span class="s1">_PROTO_ALLOWLIST </span><span class="s0">and</span>
                    <span class="s1">base.__name__ </span><span class="s0">in </span><span class="s1">_PROTO_ALLOWLIST[base.__module__] </span><span class="s0">or</span>
                    <span class="s1">isinstance(base</span><span class="s0">, </span><span class="s1">_ProtocolMeta) </span><span class="s0">and </span><span class="s1">base._is_protocol):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'Protocols can only inherit from other'</span>
                                <span class="s3">f' protocols, got </span><span class="s0">{</span><span class="s1">repr(base)</span><span class="s0">}</span><span class="s3">'</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">8</span><span class="s1">):</span>
        <span class="s0">class </span><span class="s1">Protocol(typing.Generic</span><span class="s0">, </span><span class="s1">metaclass=_ProtocolMeta):</span>
            <span class="s1">__doc__ = typing.Protocol.__doc__</span>
            <span class="s1">__slots__ = ()</span>
            <span class="s1">_is_protocol = </span><span class="s0">True</span>
            <span class="s1">_is_runtime_protocol = </span><span class="s0">False</span>

            <span class="s0">def </span><span class="s1">__init_subclass__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s1">super().__init_subclass__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

                <span class="s2"># Determine if this is a protocol or a concrete subclass.</span>
                <span class="s0">if not </span><span class="s1">cls.__dict__.get(</span><span class="s3">'_is_protocol'</span><span class="s0">, False</span><span class="s1">):</span>
                    <span class="s1">cls._is_protocol = any(b </span><span class="s0">is </span><span class="s1">Protocol </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">cls.__bases__)</span>

                <span class="s2"># Set (or override) the protocol subclass hook.</span>
                <span class="s0">if </span><span class="s3">'__subclasshook__' </span><span class="s0">not in </span><span class="s1">cls.__dict__:</span>
                    <span class="s1">cls.__subclasshook__ = _proto_hook</span>

                <span class="s2"># We have nothing more to do for non-protocols...</span>
                <span class="s0">if not </span><span class="s1">cls._is_protocol:</span>
                    <span class="s0">return</span>

                <span class="s2"># ... otherwise check consistency of bases, and prohibit instantiation.</span>
                <span class="s1">_check_proto_bases(cls)</span>
                <span class="s0">if </span><span class="s1">cls.__init__ </span><span class="s0">is </span><span class="s1">Protocol.__init__:</span>
                    <span class="s1">cls.__init__ = _no_init</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">class </span><span class="s1">Protocol(metaclass=_ProtocolMeta):</span>
            <span class="s2"># There is quite a lot of overlapping code with typing.Generic.</span>
            <span class="s2"># Unfortunately it is hard to avoid this on Python &lt;3.8,</span>
            <span class="s2"># as the typing module on Python 3.7 doesn't let us subclass typing.Generic!</span>
            <span class="s4">&quot;&quot;&quot;Base class for protocol classes. Protocol classes are defined as:: 
 
                class Proto(Protocol): 
                    def meth(self) -&gt; int: 
                        ... 
 
            Such classes are primarily used with static type checkers that recognize 
            structural subtyping (static duck-typing), for example:: 
 
                class C: 
                    def meth(self) -&gt; int: 
                        return 0 
 
                def func(x: Proto) -&gt; int: 
                    return x.meth() 
 
                func(C())  # Passes static type check 
 
            See PEP 544 for details. Protocol classes decorated with 
            @typing_extensions.runtime_checkable act 
            as simple-minded runtime-checkable protocols that check 
            only the presence of given attributes, ignoring their type signatures. 
 
            Protocol classes can be generic, they are defined as:: 
 
                class GenProto(Protocol[T]): 
                    def meth(self) -&gt; T: 
                        ... 
            &quot;&quot;&quot;</span>
            <span class="s1">__slots__ = ()</span>
            <span class="s1">_is_protocol = </span><span class="s0">True</span>
            <span class="s1">_is_runtime_protocol = </span><span class="s0">False</span>

            <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
                <span class="s0">if </span><span class="s1">cls </span><span class="s0">is </span><span class="s1">Protocol:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Type Protocol cannot be instantiated; &quot;</span>
                                    <span class="s3">&quot;it can only be used as a base class&quot;</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">super().__new__(cls)</span>

            <span class="s1">@typing._tp_cache</span>
            <span class="s0">def </span><span class="s1">__class_getitem__(cls</span><span class="s0">, </span><span class="s1">params):</span>
                <span class="s0">if not </span><span class="s1">isinstance(params</span><span class="s0">, </span><span class="s1">tuple):</span>
                    <span class="s1">params = (params</span><span class="s0">,</span><span class="s1">)</span>
                <span class="s0">if not </span><span class="s1">params </span><span class="s0">and </span><span class="s1">cls </span><span class="s0">is not </span><span class="s1">typing.Tuple:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s3">f&quot;Parameter list to </span><span class="s0">{</span><span class="s1">cls.__qualname__</span><span class="s0">}</span><span class="s3">[...] cannot be empty&quot;</span><span class="s1">)</span>
                <span class="s1">msg = </span><span class="s3">&quot;Parameters to generic types must be types.&quot;</span>
                <span class="s1">params = tuple(typing._type_check(p</span><span class="s0">, </span><span class="s1">msg) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">params)</span>
                <span class="s0">if </span><span class="s1">cls </span><span class="s0">is </span><span class="s1">Protocol:</span>
                    <span class="s2"># Generic can only be subscripted with unique type variables.</span>
                    <span class="s0">if not </span><span class="s1">all(isinstance(p</span><span class="s0">, </span><span class="s1">typing.TypeVar) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">params):</span>
                        <span class="s1">i = </span><span class="s5">0</span>
                        <span class="s0">while </span><span class="s1">isinstance(params[i]</span><span class="s0">, </span><span class="s1">typing.TypeVar):</span>
                            <span class="s1">i += </span><span class="s5">1</span>
                        <span class="s0">raise </span><span class="s1">TypeError(</span>
                            <span class="s3">&quot;Parameters to Protocol[...] must all be type variables.&quot;</span>
                            <span class="s3">f&quot; Parameter </span><span class="s0">{</span><span class="s1">i + </span><span class="s5">1</span><span class="s0">} </span><span class="s3">is </span><span class="s0">{</span><span class="s1">params[i]</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
                    <span class="s0">if </span><span class="s1">len(set(params)) != len(params):</span>
                        <span class="s0">raise </span><span class="s1">TypeError(</span>
                            <span class="s3">&quot;Parameters to Protocol[...] must all be unique&quot;</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s2"># Subscripting a regular Generic subclass.</span>
                    <span class="s1">_check_generic(cls</span><span class="s0">, </span><span class="s1">params</span><span class="s0">, </span><span class="s1">len(cls.__parameters__))</span>
                <span class="s0">return </span><span class="s1">typing._GenericAlias(cls</span><span class="s0">, </span><span class="s1">params)</span>

            <span class="s0">def </span><span class="s1">__init_subclass__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">if </span><span class="s3">'__orig_bases__' </span><span class="s0">in </span><span class="s1">cls.__dict__:</span>
                    <span class="s1">error = typing.Generic </span><span class="s0">in </span><span class="s1">cls.__orig_bases__</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">error = typing.Generic </span><span class="s0">in </span><span class="s1">cls.__bases__</span>
                <span class="s0">if </span><span class="s1">error:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Cannot inherit from plain Generic&quot;</span><span class="s1">)</span>
                <span class="s1">_maybe_adjust_parameters(cls)</span>

                <span class="s2"># Determine if this is a protocol or a concrete subclass.</span>
                <span class="s0">if not </span><span class="s1">cls.__dict__.get(</span><span class="s3">'_is_protocol'</span><span class="s0">, None</span><span class="s1">):</span>
                    <span class="s1">cls._is_protocol = any(b </span><span class="s0">is </span><span class="s1">Protocol </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">cls.__bases__)</span>

                <span class="s2"># Set (or override) the protocol subclass hook.</span>
                <span class="s0">if </span><span class="s3">'__subclasshook__' </span><span class="s0">not in </span><span class="s1">cls.__dict__:</span>
                    <span class="s1">cls.__subclasshook__ = _proto_hook</span>

                <span class="s2"># We have nothing more to do for non-protocols.</span>
                <span class="s0">if not </span><span class="s1">cls._is_protocol:</span>
                    <span class="s0">return</span>

                <span class="s2"># Check consistency of bases.</span>
                <span class="s1">_check_proto_bases(cls)</span>
                <span class="s0">if </span><span class="s1">cls.__init__ </span><span class="s0">is </span><span class="s1">Protocol.__init__:</span>
                    <span class="s1">cls.__init__ = _no_init</span>

    <span class="s0">def </span><span class="s1">runtime_checkable(cls):</span>
        <span class="s4">&quot;&quot;&quot;Mark a protocol class as a runtime protocol, so that it 
        can be used with isinstance() and issubclass(). Raise TypeError 
        if applied to a non-protocol class. 
 
        This allows a simple-minded structural check very similar to the 
        one-offs in collections.abc such as Hashable. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">(</span>
            <span class="s1">(isinstance(cls</span><span class="s0">, </span><span class="s1">_ProtocolMeta) </span><span class="s0">or </span><span class="s1">issubclass(cls</span><span class="s0">, </span><span class="s1">typing.Generic))</span>
            <span class="s0">and </span><span class="s1">getattr(cls</span><span class="s0">, </span><span class="s3">&quot;_is_protocol&quot;</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'@runtime_checkable can be only applied to protocol classes,'</span>
                            <span class="s3">f' got </span><span class="s0">{</span><span class="s1">cls</span><span class="s0">!r}</span><span class="s3">'</span><span class="s1">)</span>
        <span class="s1">cls._is_runtime_protocol = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">cls</span>


<span class="s2"># Exists for backwards compatibility.</span>
<span class="s1">runtime = runtime_checkable</span>


<span class="s2"># Our version of runtime-checkable protocols is faster on Python 3.7-3.11</span>
<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">12</span><span class="s1">):</span>
    <span class="s1">SupportsInt = typing.SupportsInt</span>
    <span class="s1">SupportsFloat = typing.SupportsFloat</span>
    <span class="s1">SupportsComplex = typing.SupportsComplex</span>
    <span class="s1">SupportsBytes = typing.SupportsBytes</span>
    <span class="s1">SupportsIndex = typing.SupportsIndex</span>
    <span class="s1">SupportsAbs = typing.SupportsAbs</span>
    <span class="s1">SupportsRound = typing.SupportsRound</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">@runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsInt(Protocol):</span>
        <span class="s4">&quot;&quot;&quot;An ABC with one abstract method __int__.&quot;&quot;&quot;</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s1">@abc.abstractmethod</span>
        <span class="s0">def </span><span class="s1">__int__(self) -&gt; int:</span>
            <span class="s0">pass</span>

    <span class="s1">@runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsFloat(Protocol):</span>
        <span class="s4">&quot;&quot;&quot;An ABC with one abstract method __float__.&quot;&quot;&quot;</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s1">@abc.abstractmethod</span>
        <span class="s0">def </span><span class="s1">__float__(self) -&gt; float:</span>
            <span class="s0">pass</span>

    <span class="s1">@runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsComplex(Protocol):</span>
        <span class="s4">&quot;&quot;&quot;An ABC with one abstract method __complex__.&quot;&quot;&quot;</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s1">@abc.abstractmethod</span>
        <span class="s0">def </span><span class="s1">__complex__(self) -&gt; complex:</span>
            <span class="s0">pass</span>

    <span class="s1">@runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsBytes(Protocol):</span>
        <span class="s4">&quot;&quot;&quot;An ABC with one abstract method __bytes__.&quot;&quot;&quot;</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s1">@abc.abstractmethod</span>
        <span class="s0">def </span><span class="s1">__bytes__(self) -&gt; bytes:</span>
            <span class="s0">pass</span>

    <span class="s1">@runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsIndex(Protocol):</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s1">@abc.abstractmethod</span>
        <span class="s0">def </span><span class="s1">__index__(self) -&gt; int:</span>
            <span class="s0">pass</span>

    <span class="s1">@runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsAbs(Protocol[T_co]):</span>
        <span class="s4">&quot;&quot;&quot; 
        An ABC with one abstract method __abs__ that is covariant in its return type. 
        &quot;&quot;&quot;</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s1">@abc.abstractmethod</span>
        <span class="s0">def </span><span class="s1">__abs__(self) -&gt; T_co:</span>
            <span class="s0">pass</span>

    <span class="s1">@runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsRound(Protocol[T_co]):</span>
        <span class="s4">&quot;&quot;&quot; 
        An ABC with one abstract method __round__ that is covariant in its return type. 
        &quot;&quot;&quot;</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s1">@abc.abstractmethod</span>
        <span class="s0">def </span><span class="s1">__round__(self</span><span class="s0">, </span><span class="s1">ndigits: int = </span><span class="s5">0</span><span class="s1">) -&gt; T_co:</span>
            <span class="s0">pass</span>


<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">12</span><span class="s1">):</span>
    <span class="s2"># The standard library TypedDict in Python 3.8 does not store runtime information</span>
    <span class="s2"># about which (if any) keys are optional.  See https://bugs.python.org/issue38834</span>
    <span class="s2"># The standard library TypedDict in Python 3.9.0/1 does not honour the &quot;total&quot;</span>
    <span class="s2"># keyword with old-style TypedDict().  See https://bugs.python.org/issue42059</span>
    <span class="s2"># The standard library TypedDict below Python 3.11 does not store runtime</span>
    <span class="s2"># information about optional and required keys when using Required or NotRequired.</span>
    <span class="s2"># Generic TypedDicts are also impossible using typing.TypedDict on Python &lt;3.11.</span>
    <span class="s2"># Aaaand on 3.12 we add __orig_bases__ to TypedDict</span>
    <span class="s2"># to enable better runtime introspection.</span>
    <span class="s1">TypedDict = typing.TypedDict</span>
    <span class="s1">_TypedDictMeta = typing._TypedDictMeta</span>
    <span class="s1">is_typeddict = typing.is_typeddict</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">_check_fails(cls</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">_caller() </span><span class="s0">not in </span><span class="s1">{</span><span class="s3">'abc'</span><span class="s0">, </span><span class="s3">'functools'</span><span class="s0">, </span><span class="s3">'typing'</span><span class="s1">}:</span>
                <span class="s2"># Typed dicts are only for static structural subtyping.</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'TypedDict does not support instance and class checks'</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
            <span class="s0">pass</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">_dict_new(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if not </span><span class="s1">args:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'TypedDict.__new__(): not enough arguments'</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">args = args[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s5">1</span><span class="s1">:]  </span><span class="s2"># allow the &quot;cls&quot; keyword be passed</span>
        <span class="s0">return </span><span class="s1">dict(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">_dict_new.__text_signature__ = </span><span class="s3">'($cls, _typename, _fields=None, /, **kwargs)'</span>

    <span class="s0">def </span><span class="s1">_typeddict_new(*args</span><span class="s0">, </span><span class="s1">total=</span><span class="s0">True, </span><span class="s1">**kwargs):</span>
        <span class="s0">if not </span><span class="s1">args:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'TypedDict.__new__(): not enough arguments'</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">args = args[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s5">1</span><span class="s1">:]  </span><span class="s2"># allow the &quot;cls&quot; keyword be passed</span>
        <span class="s0">if </span><span class="s1">args:</span>
            <span class="s1">typename</span><span class="s0">, </span><span class="s1">args = args[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s5">1</span><span class="s1">:]  </span><span class="s2"># allow the &quot;_typename&quot; keyword be passed</span>
        <span class="s0">elif </span><span class="s3">'_typename' </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s1">typename = kwargs.pop(</span><span class="s3">'_typename'</span><span class="s1">)</span>
            <span class="s1">warnings.warn(</span><span class="s3">&quot;Passing '_typename' as keyword argument is deprecated&quot;</span><span class="s0">,</span>
                          <span class="s1">DeprecationWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;TypedDict.__new__() missing 1 required positional &quot;</span>
                            <span class="s3">&quot;argument: '_typename'&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">args:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">fields</span><span class="s0">, </span><span class="s1">= args  </span><span class="s2"># allow the &quot;_fields&quot; keyword be passed</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'TypedDict.__new__() takes from 2 to 3 '</span>
                                <span class="s3">f'positional arguments but </span><span class="s0">{</span><span class="s1">len(args) + </span><span class="s5">2</span><span class="s0">} </span><span class="s3">'</span>
                                <span class="s3">'were given'</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s3">'_fields' </span><span class="s0">in </span><span class="s1">kwargs </span><span class="s0">and </span><span class="s1">len(kwargs) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">fields = kwargs.pop(</span><span class="s3">'_fields'</span><span class="s1">)</span>
            <span class="s1">warnings.warn(</span><span class="s3">&quot;Passing '_fields' as keyword argument is deprecated&quot;</span><span class="s0">,</span>
                          <span class="s1">DeprecationWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fields = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">fields </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">fields = kwargs</span>
        <span class="s0">elif </span><span class="s1">kwargs:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;TypedDict takes either a dict or keyword arguments,&quot;</span>
                            <span class="s3">&quot; but not both&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">kwargs:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s3">&quot;The kwargs-based syntax for TypedDict definitions is deprecated, &quot;</span>
                <span class="s3">&quot;may be removed in a future version, and may not be &quot;</span>
                <span class="s3">&quot;understood by third-party type checkers.&quot;</span><span class="s0">,</span>
                <span class="s1">DeprecationWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s1">ns = {</span><span class="s3">'__annotations__'</span><span class="s1">: dict(fields)}</span>
        <span class="s1">module = _caller()</span>
        <span class="s0">if </span><span class="s1">module </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s2"># Setting correct module is necessary to make typed dict classes pickleable.</span>
            <span class="s1">ns[</span><span class="s3">'__module__'</span><span class="s1">] = module</span>

        <span class="s0">return </span><span class="s1">_TypedDictMeta(typename</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">ns</span><span class="s0">, </span><span class="s1">total=total)</span>

    <span class="s1">_typeddict_new.__text_signature__ = (</span><span class="s3">'($cls, _typename, _fields=None,'</span>
                                         <span class="s3">' /, *, total=True, **kwargs)'</span><span class="s1">)</span>

    <span class="s1">_TAKES_MODULE = </span><span class="s3">&quot;module&quot; </span><span class="s0">in </span><span class="s1">inspect.signature(typing._type_check).parameters</span>

    <span class="s0">class </span><span class="s1">_TypedDictMeta(type):</span>
        <span class="s0">def </span><span class="s1">__init__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">ns</span><span class="s0">, </span><span class="s1">total=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">super().__init__(name</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">ns)</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">ns</span><span class="s0">, </span><span class="s1">total=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s2"># Create new typed dict class object.</span>
            <span class="s2"># This method is called directly when TypedDict is subclassed,</span>
            <span class="s2"># or via _typeddict_new when TypedDict is instantiated. This way</span>
            <span class="s2"># TypedDict supports all three syntaxes described in its docstring.</span>
            <span class="s2"># Subclasses and instances of TypedDict return actual dictionaries</span>
            <span class="s2"># via _dict_new.</span>
            <span class="s1">ns[</span><span class="s3">'__new__'</span><span class="s1">] = _typeddict_new </span><span class="s0">if </span><span class="s1">name == </span><span class="s3">'TypedDict' </span><span class="s0">else </span><span class="s1">_dict_new</span>
            <span class="s2"># Don't insert typing.Generic into __bases__ here,</span>
            <span class="s2"># or Generic.__init_subclass__ will raise TypeError</span>
            <span class="s2"># in the super().__new__() call.</span>
            <span class="s2"># Instead, monkey-patch __bases__ onto the class after it's been created.</span>
            <span class="s1">tp_dict = super().__new__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">(dict</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ns)</span>

            <span class="s1">is_generic = any(issubclass(base</span><span class="s0">, </span><span class="s1">typing.Generic) </span><span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">bases)</span>

            <span class="s0">if </span><span class="s1">is_generic:</span>
                <span class="s1">tp_dict.__bases__ = (typing.Generic</span><span class="s0">, </span><span class="s1">dict)</span>
                <span class="s1">_maybe_adjust_parameters(tp_dict)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># generic TypedDicts get __orig_bases__ from Generic</span>
                <span class="s1">tp_dict.__orig_bases__ = bases </span><span class="s0">or </span><span class="s1">(TypedDict</span><span class="s0">,</span><span class="s1">)</span>

            <span class="s1">annotations = {}</span>
            <span class="s1">own_annotations = ns.get(</span><span class="s3">'__annotations__'</span><span class="s0">, </span><span class="s1">{})</span>
            <span class="s1">msg = </span><span class="s3">&quot;TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type&quot;</span>
            <span class="s1">kwds = {</span><span class="s3">&quot;module&quot;</span><span class="s1">: tp_dict.__module__} </span><span class="s0">if </span><span class="s1">_TAKES_MODULE </span><span class="s0">else </span><span class="s1">{}</span>
            <span class="s1">own_annotations = {</span>
                <span class="s1">n: typing._type_check(tp</span><span class="s0">, </span><span class="s1">msg</span><span class="s0">, </span><span class="s1">**kwds)</span>
                <span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">tp </span><span class="s0">in </span><span class="s1">own_annotations.items()</span>
            <span class="s1">}</span>
            <span class="s1">required_keys = set()</span>
            <span class="s1">optional_keys = set()</span>

            <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">bases:</span>
                <span class="s1">annotations.update(base.__dict__.get(</span><span class="s3">'__annotations__'</span><span class="s0">, </span><span class="s1">{}))</span>
                <span class="s1">required_keys.update(base.__dict__.get(</span><span class="s3">'__required_keys__'</span><span class="s0">, </span><span class="s1">()))</span>
                <span class="s1">optional_keys.update(base.__dict__.get(</span><span class="s3">'__optional_keys__'</span><span class="s0">, </span><span class="s1">()))</span>

            <span class="s1">annotations.update(own_annotations)</span>
            <span class="s0">for </span><span class="s1">annotation_key</span><span class="s0">, </span><span class="s1">annotation_type </span><span class="s0">in </span><span class="s1">own_annotations.items():</span>
                <span class="s1">annotation_origin = get_origin(annotation_type)</span>
                <span class="s0">if </span><span class="s1">annotation_origin </span><span class="s0">is </span><span class="s1">Annotated:</span>
                    <span class="s1">annotation_args = get_args(annotation_type)</span>
                    <span class="s0">if </span><span class="s1">annotation_args:</span>
                        <span class="s1">annotation_type = annotation_args[</span><span class="s5">0</span><span class="s1">]</span>
                        <span class="s1">annotation_origin = get_origin(annotation_type)</span>

                <span class="s0">if </span><span class="s1">annotation_origin </span><span class="s0">is </span><span class="s1">Required:</span>
                    <span class="s1">required_keys.add(annotation_key)</span>
                <span class="s0">elif </span><span class="s1">annotation_origin </span><span class="s0">is </span><span class="s1">NotRequired:</span>
                    <span class="s1">optional_keys.add(annotation_key)</span>
                <span class="s0">elif </span><span class="s1">total:</span>
                    <span class="s1">required_keys.add(annotation_key)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">optional_keys.add(annotation_key)</span>

            <span class="s1">tp_dict.__annotations__ = annotations</span>
            <span class="s1">tp_dict.__required_keys__ = frozenset(required_keys)</span>
            <span class="s1">tp_dict.__optional_keys__ = frozenset(optional_keys)</span>
            <span class="s0">if not </span><span class="s1">hasattr(tp_dict</span><span class="s0">, </span><span class="s3">'__total__'</span><span class="s1">):</span>
                <span class="s1">tp_dict.__total__ = total</span>
            <span class="s0">return </span><span class="s1">tp_dict</span>

        <span class="s1">__instancecheck__ = __subclasscheck__ = _check_fails</span>

    <span class="s1">TypedDict = _TypedDictMeta(</span><span class="s3">'TypedDict'</span><span class="s0">, </span><span class="s1">(dict</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{})</span>
    <span class="s1">TypedDict.__module__ = __name__</span>
    <span class="s1">TypedDict.__doc__ = \</span>
        <span class="s3">&quot;&quot;&quot;A simple typed name space. At runtime it is equivalent to a plain dict. 
 
        TypedDict creates a dictionary type that expects all of its 
        instances to have a certain set of keys, with each key 
        associated with a value of a consistent type. This expectation 
        is not checked at runtime but is only enforced by type checkers. 
        Usage:: 
 
            class Point2D(TypedDict): 
                x: int 
                y: int 
                label: str 
 
            a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK 
            b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check 
 
            assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first') 
 
        The type info can be accessed via the Point2D.__annotations__ dict, and 
        the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets. 
        TypedDict supports two additional equivalent forms:: 
 
            Point2D = TypedDict('Point2D', x=int, y=int, label=str) 
            Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str}) 
 
        The class syntax is only supported in Python 3.6+, while two other 
        syntax forms work for Python 2.7 and 3.2+ 
        &quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;_TypedDictMeta&quot;</span><span class="s1">):</span>
        <span class="s1">_TYPEDDICT_TYPES = (typing._TypedDictMeta</span><span class="s0">, </span><span class="s1">_TypedDictMeta)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">_TYPEDDICT_TYPES = (_TypedDictMeta</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">is_typeddict(tp):</span>
        <span class="s4">&quot;&quot;&quot;Check if an annotation is a TypedDict class 
 
        For example:: 
            class Film(TypedDict): 
                title: str 
                year: int 
 
            is_typeddict(Film)  # =&gt; True 
            is_typeddict(Union[list, str])  # =&gt; False 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">tuple(_TYPEDDICT_TYPES))</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;assert_type&quot;</span><span class="s1">):</span>
    <span class="s1">assert_type = typing.assert_type</span>

<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">assert_type(__val</span><span class="s0">, </span><span class="s1">__typ):</span>
        <span class="s4">&quot;&quot;&quot;Assert (to the type checker) that the value is of the given type. 
 
        When the type checker encounters a call to assert_type(), it 
        emits an error if the value is not of the specified type:: 
 
            def greet(name: str) -&gt; None: 
                assert_type(name, str)  # ok 
                assert_type(name, int)  # type checker error 
 
        At runtime this returns the first argument unchanged and otherwise 
        does nothing. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">__val</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;Required&quot;</span><span class="s1">):</span>
    <span class="s1">get_type_hints = typing.get_type_hints</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s2"># replaces _strip_annotations()</span>
    <span class="s0">def </span><span class="s1">_strip_extras(t):</span>
        <span class="s4">&quot;&quot;&quot;Strips Annotated, Required and NotRequired from a given type.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">_AnnotatedAlias):</span>
            <span class="s0">return </span><span class="s1">_strip_extras(t.__origin__)</span>
        <span class="s0">if </span><span class="s1">hasattr(t</span><span class="s0">, </span><span class="s3">&quot;__origin__&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">t.__origin__ </span><span class="s0">in </span><span class="s1">(Required</span><span class="s0">, </span><span class="s1">NotRequired):</span>
            <span class="s0">return </span><span class="s1">_strip_extras(t.__args__[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s0">if </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">typing._GenericAlias):</span>
            <span class="s1">stripped_args = tuple(_strip_extras(a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">t.__args__)</span>
            <span class="s0">if </span><span class="s1">stripped_args == t.__args__:</span>
                <span class="s0">return </span><span class="s1">t</span>
            <span class="s0">return </span><span class="s1">t.copy_with(stripped_args)</span>
        <span class="s0">if </span><span class="s1">hasattr(_types</span><span class="s0">, </span><span class="s3">&quot;GenericAlias&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">_types.GenericAlias):</span>
            <span class="s1">stripped_args = tuple(_strip_extras(a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">t.__args__)</span>
            <span class="s0">if </span><span class="s1">stripped_args == t.__args__:</span>
                <span class="s0">return </span><span class="s1">t</span>
            <span class="s0">return </span><span class="s1">_types.GenericAlias(t.__origin__</span><span class="s0">, </span><span class="s1">stripped_args)</span>
        <span class="s0">if </span><span class="s1">hasattr(_types</span><span class="s0">, </span><span class="s3">&quot;UnionType&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">_types.UnionType):</span>
            <span class="s1">stripped_args = tuple(_strip_extras(a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">t.__args__)</span>
            <span class="s0">if </span><span class="s1">stripped_args == t.__args__:</span>
                <span class="s0">return </span><span class="s1">t</span>
            <span class="s0">return </span><span class="s1">functools.reduce(operator.or_</span><span class="s0">, </span><span class="s1">stripped_args)</span>

        <span class="s0">return </span><span class="s1">t</span>

    <span class="s0">def </span><span class="s1">get_type_hints(obj</span><span class="s0">, </span><span class="s1">globalns=</span><span class="s0">None, </span><span class="s1">localns=</span><span class="s0">None, </span><span class="s1">include_extras=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Return type hints for an object. 
 
        This is often the same as obj.__annotations__, but it handles 
        forward references encoded as string literals, adds Optional[t] if a 
        default value equal to None is set and recursively replaces all 
        'Annotated[T, ...]', 'Required[T]' or 'NotRequired[T]' with 'T' 
        (unless 'include_extras=True'). 
 
        The argument may be a module, class, method, or function. The annotations 
        are returned as a dictionary. For classes, annotations include also 
        inherited members. 
 
        TypeError is raised if the argument is not of a type that can contain 
        annotations, and an empty dictionary is returned if no annotations are 
        present. 
 
        BEWARE -- the behavior of globalns and localns is counterintuitive 
        (unless you are familiar with how eval() and exec() work).  The 
        search order is locals first, then globals. 
 
        - If no dict arguments are passed, an attempt is made to use the 
          globals from obj (or the respective module's globals for classes), 
          and these are also used as the locals.  If the object does not appear 
          to have globals, an empty dictionary is used. 
 
        - If one dict argument is passed, it is used for both globals and 
          locals. 
 
        - If two dict arguments are passed, they specify globals and 
          locals, respectively. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;Annotated&quot;</span><span class="s1">):</span>
            <span class="s1">hint = typing.get_type_hints(</span>
                <span class="s1">obj</span><span class="s0">, </span><span class="s1">globalns=globalns</span><span class="s0">, </span><span class="s1">localns=localns</span><span class="s0">, </span><span class="s1">include_extras=</span><span class="s0">True</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">hint = typing.get_type_hints(obj</span><span class="s0">, </span><span class="s1">globalns=globalns</span><span class="s0">, </span><span class="s1">localns=localns)</span>
        <span class="s0">if </span><span class="s1">include_extras:</span>
            <span class="s0">return </span><span class="s1">hint</span>
        <span class="s0">return </span><span class="s1">{k: _strip_extras(t) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">hint.items()}</span>


<span class="s2"># Python 3.9+ has PEP 593 (Annotated)</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'Annotated'</span><span class="s1">):</span>
    <span class="s1">Annotated = typing.Annotated</span>
    <span class="s2"># Not exported and not a public API, but needed for get_origin() and get_args()</span>
    <span class="s2"># to work.</span>
    <span class="s1">_AnnotatedAlias = typing._AnnotatedAlias</span>
<span class="s2"># 3.7-3.8</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_AnnotatedAlias(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Runtime representation of an annotated type. 
 
        At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't' 
        with extra annotations. The alias behaves like a normal typing alias, 
        instantiating is the same as instantiating the underlying type, binding 
        it to types is also the same. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">origin</span><span class="s0">, </span><span class="s1">metadata):</span>
            <span class="s0">if </span><span class="s1">isinstance(origin</span><span class="s0">, </span><span class="s1">_AnnotatedAlias):</span>
                <span class="s1">metadata = origin.__metadata__ + metadata</span>
                <span class="s1">origin = origin.__origin__</span>
            <span class="s1">super().__init__(origin</span><span class="s0">, </span><span class="s1">origin)</span>
            <span class="s1">self.__metadata__ = metadata</span>

        <span class="s0">def </span><span class="s1">copy_with(self</span><span class="s0">, </span><span class="s1">params):</span>
            <span class="s0">assert </span><span class="s1">len(params) == </span><span class="s5">1</span>
            <span class="s1">new_type = params[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">return </span><span class="s1">_AnnotatedAlias(new_type</span><span class="s0">, </span><span class="s1">self.__metadata__)</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s3">f&quot;typing_extensions.Annotated[</span><span class="s0">{</span><span class="s1">typing._type_repr(self.__origin__)</span><span class="s0">}</span><span class="s3">, &quot;</span>
                    <span class="s3">f&quot;</span><span class="s0">{</span><span class="s3">', '</span><span class="s1">.join(repr(a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">self.__metadata__)</span><span class="s0">}</span><span class="s3">]&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__reduce__(self):</span>
            <span class="s0">return </span><span class="s1">operator.getitem</span><span class="s0">, </span><span class="s1">(</span>
                <span class="s1">Annotated</span><span class="s0">, </span><span class="s1">(self.__origin__</span><span class="s0">,</span><span class="s1">) + self.__metadata__</span>
            <span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">_AnnotatedAlias):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s0">if </span><span class="s1">self.__origin__ != other.__origin__:</span>
                <span class="s0">return False</span>
            <span class="s0">return </span><span class="s1">self.__metadata__ == other.__metadata__</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">hash((self.__origin__</span><span class="s0">, </span><span class="s1">self.__metadata__))</span>

    <span class="s0">class </span><span class="s1">Annotated:</span>
        <span class="s4">&quot;&quot;&quot;Add context specific metadata to a type. 
 
        Example: Annotated[int, runtime_check.Unsigned] indicates to the 
        hypothetical runtime_check module that this type is an unsigned int. 
        Every other consumer of this type can ignore this metadata and treat 
        this type as int. 
 
        The first argument to Annotated must be a valid type (and will be in 
        the __origin__ field), the remaining arguments are kept as a tuple in 
        the __extra__ field. 
 
        Details: 
 
        - It's an error to call `Annotated` with less than two arguments. 
        - Nested Annotated are flattened:: 
 
            Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3] 
 
        - Instantiating an annotated type is equivalent to instantiating the 
        underlying type:: 
 
            Annotated[C, Ann1](5) == C(5) 
 
        - Annotated can be used as a generic type alias:: 
 
            Optimized = Annotated[T, runtime.Optimize()] 
            Optimized[int] == Annotated[int, runtime.Optimize()] 
 
            OptimizedList = Annotated[List[T], runtime.Optimize()] 
            OptimizedList[int] == Annotated[List[int], runtime.Optimize()] 
        &quot;&quot;&quot;</span>

        <span class="s1">__slots__ = ()</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Type Annotated cannot be instantiated.&quot;</span><span class="s1">)</span>

        <span class="s1">@typing._tp_cache</span>
        <span class="s0">def </span><span class="s1">__class_getitem__(cls</span><span class="s0">, </span><span class="s1">params):</span>
            <span class="s0">if not </span><span class="s1">isinstance(params</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">or </span><span class="s1">len(params) &lt; </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Annotated[...] should be used &quot;</span>
                                <span class="s3">&quot;with at least two arguments (a type and an &quot;</span>
                                <span class="s3">&quot;annotation).&quot;</span><span class="s1">)</span>
            <span class="s1">allowed_special_forms = (ClassVar</span><span class="s0">, </span><span class="s1">Final)</span>
            <span class="s0">if </span><span class="s1">get_origin(params[</span><span class="s5">0</span><span class="s1">]) </span><span class="s0">in </span><span class="s1">allowed_special_forms:</span>
                <span class="s1">origin = params[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s3">&quot;Annotated[t, ...]: t must be a type.&quot;</span>
                <span class="s1">origin = typing._type_check(params[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">metadata = tuple(params[</span><span class="s5">1</span><span class="s1">:])</span>
            <span class="s0">return </span><span class="s1">_AnnotatedAlias(origin</span><span class="s0">, </span><span class="s1">metadata)</span>

        <span class="s0">def </span><span class="s1">__init_subclass__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s3">f&quot;Cannot subclass </span><span class="s0">{</span><span class="s1">cls.__module__</span><span class="s0">}</span><span class="s3">.Annotated&quot;</span>
            <span class="s1">)</span>

<span class="s2"># Python 3.8 has get_origin() and get_args() but those implementations aren't</span>
<span class="s2"># Annotated-aware, so we can't use those. Python 3.9's versions don't support</span>
<span class="s2"># ParamSpecArgs and ParamSpecKwargs, so only Python 3.10's versions will do.</span>
<span class="s0">if </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">10</span><span class="s1">):</span>
    <span class="s1">get_origin = typing.get_origin</span>
    <span class="s1">get_args = typing.get_args</span>
<span class="s2"># 3.7-3.9</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s2"># 3.9+</span>
        <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">_BaseGenericAlias</span>
    <span class="s0">except </span><span class="s1">ImportError:</span>
        <span class="s1">_BaseGenericAlias = typing._GenericAlias</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s2"># 3.9+</span>
        <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">GenericAlias </span><span class="s0">as </span><span class="s1">_typing_GenericAlias</span>
    <span class="s0">except </span><span class="s1">ImportError:</span>
        <span class="s1">_typing_GenericAlias = typing._GenericAlias</span>

    <span class="s0">def </span><span class="s1">get_origin(tp):</span>
        <span class="s4">&quot;&quot;&quot;Get the unsubscripted version of a type. 
 
        This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar 
        and Annotated. Return None for unsupported types. Examples:: 
 
            get_origin(Literal[42]) is Literal 
            get_origin(int) is None 
            get_origin(ClassVar[int]) is ClassVar 
            get_origin(Generic) is Generic 
            get_origin(Generic[T]) is Generic 
            get_origin(Union[T, int]) is Union 
            get_origin(List[Tuple[T, T]][int]) == list 
            get_origin(P.args) is P 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">_AnnotatedAlias):</span>
            <span class="s0">return </span><span class="s1">Annotated</span>
        <span class="s0">if </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_typing_GenericAlias</span><span class="s0">, </span><span class="s1">_BaseGenericAlias</span><span class="s0">,</span>
                           <span class="s1">ParamSpecArgs</span><span class="s0">, </span><span class="s1">ParamSpecKwargs)):</span>
            <span class="s0">return </span><span class="s1">tp.__origin__</span>
        <span class="s0">if </span><span class="s1">tp </span><span class="s0">is </span><span class="s1">typing.Generic:</span>
            <span class="s0">return </span><span class="s1">typing.Generic</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">get_args(tp):</span>
        <span class="s4">&quot;&quot;&quot;Get type arguments with all substitutions performed. 
 
        For unions, basic simplifications used by Union constructor are performed. 
        Examples:: 
            get_args(Dict[str, int]) == (str, int) 
            get_args(int) == () 
            get_args(Union[int, Union[T, int], str][int]) == (int, str) 
            get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int]) 
            get_args(Callable[[], T][int]) == ([], int) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">_AnnotatedAlias):</span>
            <span class="s0">return </span><span class="s1">(tp.__origin__</span><span class="s0">,</span><span class="s1">) + tp.__metadata__</span>
        <span class="s0">if </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_typing_GenericAlias)):</span>
            <span class="s0">if </span><span class="s1">getattr(tp</span><span class="s0">, </span><span class="s3">&quot;_special&quot;</span><span class="s0">, False</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">()</span>
            <span class="s1">res = tp.__args__</span>
            <span class="s0">if </span><span class="s1">get_origin(tp) </span><span class="s0">is </span><span class="s1">collections.abc.Callable </span><span class="s0">and </span><span class="s1">res[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">is not </span><span class="s1">Ellipsis:</span>
                <span class="s1">res = (list(res[:-</span><span class="s5">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">res[-</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s0">return </span><span class="s1">res</span>
        <span class="s0">return </span><span class="s1">()</span>


<span class="s2"># 3.10+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'TypeAlias'</span><span class="s1">):</span>
    <span class="s1">TypeAlias = typing.TypeAlias</span>
<span class="s2"># 3.9</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_TypeAliasForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

    <span class="s1">@_TypeAliasForm</span>
    <span class="s0">def </span><span class="s1">TypeAlias(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s4">&quot;&quot;&quot;Special marker indicating that an assignment should 
        be recognized as a proper type alias definition by type 
        checkers. 
 
        For example:: 
 
            Predicate: TypeAlias = Callable[..., bool] 
 
        It's invalid when used anywhere except as in the example above. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">is not subscriptable&quot;</span><span class="s1">)</span>
<span class="s2"># 3.7-3.8</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_TypeAliasForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

    <span class="s1">TypeAlias = _TypeAliasForm(</span><span class="s3">'TypeAlias'</span><span class="s0">,</span>
                               <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;Special marker indicating that an assignment should 
                               be recognized as a proper type alias definition by type 
                               checkers. 
 
                               For example:: 
 
                                   Predicate: TypeAlias = Callable[..., bool] 
 
                               It's invalid when used anywhere except as in the example 
                               above.&quot;&quot;&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_set_default(type_param</span><span class="s0">, </span><span class="s1">default):</span>
    <span class="s0">if </span><span class="s1">isinstance(default</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list)):</span>
        <span class="s1">type_param.__default__ = tuple((typing._type_check(d</span><span class="s0">, </span><span class="s3">&quot;Default must be a type&quot;</span><span class="s1">)</span>
                                        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">default))</span>
    <span class="s0">elif </span><span class="s1">default != _marker:</span>
        <span class="s1">type_param.__default__ = typing._type_check(default</span><span class="s0">, </span><span class="s3">&quot;Default must be a type&quot;</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">type_param.__default__ = </span><span class="s0">None</span>


<span class="s0">def </span><span class="s1">_set_module(typevarlike):</span>
    <span class="s2"># for pickling:</span>
    <span class="s1">def_mod = _caller(depth=</span><span class="s5">3</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">def_mod != </span><span class="s3">'typing_extensions'</span><span class="s1">:</span>
        <span class="s1">typevarlike.__module__ = def_mod</span>


<span class="s0">class </span><span class="s1">_DefaultMixin:</span>
    <span class="s4">&quot;&quot;&quot;Mixin for TypeVarLike defaults.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>
    <span class="s1">__init__ = _set_default</span>


<span class="s2"># Classes using this metaclass must provide a _backported_typevarlike ClassVar</span>
<span class="s0">class </span><span class="s1">_TypeVarLikeMeta(type):</span>
    <span class="s0">def </span><span class="s1">__instancecheck__(cls</span><span class="s0">, </span><span class="s1">__instance: Any) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">isinstance(__instance</span><span class="s0">, </span><span class="s1">cls._backported_typevarlike)</span>


<span class="s2"># Add default and infer_variance parameters from PEP 696 and 695</span>
<span class="s0">class </span><span class="s1">TypeVar(metaclass=_TypeVarLikeMeta):</span>
    <span class="s4">&quot;&quot;&quot;Type variable.&quot;&quot;&quot;</span>

    <span class="s1">_backported_typevarlike = typing.TypeVar</span>

    <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">*constraints</span><span class="s0">, </span><span class="s1">bound=</span><span class="s0">None,</span>
                <span class="s1">covariant=</span><span class="s0">False, </span><span class="s1">contravariant=</span><span class="s0">False,</span>
                <span class="s1">default=_marker</span><span class="s0">, </span><span class="s1">infer_variance=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;TypeAliasType&quot;</span><span class="s1">):</span>
            <span class="s2"># PEP 695 implemented, can pass infer_variance to typing.TypeVar</span>
            <span class="s1">typevar = typing.TypeVar(name</span><span class="s0">, </span><span class="s1">*constraints</span><span class="s0">, </span><span class="s1">bound=bound</span><span class="s0">,</span>
                                     <span class="s1">covariant=covariant</span><span class="s0">, </span><span class="s1">contravariant=contravariant</span><span class="s0">,</span>
                                     <span class="s1">infer_variance=infer_variance)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">typevar = typing.TypeVar(name</span><span class="s0">, </span><span class="s1">*constraints</span><span class="s0">, </span><span class="s1">bound=bound</span><span class="s0">,</span>
                                     <span class="s1">covariant=covariant</span><span class="s0">, </span><span class="s1">contravariant=contravariant)</span>
            <span class="s0">if </span><span class="s1">infer_variance </span><span class="s0">and </span><span class="s1">(covariant </span><span class="s0">or </span><span class="s1">contravariant):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Variance cannot be specified with infer_variance.&quot;</span><span class="s1">)</span>
            <span class="s1">typevar.__infer_variance__ = infer_variance</span>
        <span class="s1">_set_default(typevar</span><span class="s0">, </span><span class="s1">default)</span>
        <span class="s1">_set_module(typevar)</span>
        <span class="s0">return </span><span class="s1">typevar</span>

    <span class="s0">def </span><span class="s1">__init_subclass__(cls) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;type '</span><span class="s0">{</span><span class="s1">__name__</span><span class="s0">}</span><span class="s3">.TypeVar' is not an acceptable base type&quot;</span><span class="s1">)</span>


<span class="s2"># Python 3.10+ has PEP 612</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'ParamSpecArgs'</span><span class="s1">):</span>
    <span class="s1">ParamSpecArgs = typing.ParamSpecArgs</span>
    <span class="s1">ParamSpecKwargs = typing.ParamSpecKwargs</span>
<span class="s2"># 3.7-3.9</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_Immutable:</span>
        <span class="s4">&quot;&quot;&quot;Mixin to indicate that object should not be copied.&quot;&quot;&quot;</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s0">def </span><span class="s1">__copy__(self):</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s0">def </span><span class="s1">__deepcopy__(self</span><span class="s0">, </span><span class="s1">memo):</span>
            <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">class </span><span class="s1">ParamSpecArgs(_Immutable):</span>
        <span class="s4">&quot;&quot;&quot;The args for a ParamSpec object. 
 
        Given a ParamSpec object P, P.args is an instance of ParamSpecArgs. 
 
        ParamSpecArgs objects have a reference back to their ParamSpec: 
 
        P.args.__origin__ is P 
 
        This type is meant for runtime introspection and has no special meaning to 
        static type checkers. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">origin):</span>
            <span class="s1">self.__origin__ = origin</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self.__origin__.__name__</span><span class="s0">}</span><span class="s3">.args&quot;</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">ParamSpecArgs):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s0">return </span><span class="s1">self.__origin__ == other.__origin__</span>

    <span class="s0">class </span><span class="s1">ParamSpecKwargs(_Immutable):</span>
        <span class="s4">&quot;&quot;&quot;The kwargs for a ParamSpec object. 
 
        Given a ParamSpec object P, P.kwargs is an instance of ParamSpecKwargs. 
 
        ParamSpecKwargs objects have a reference back to their ParamSpec: 
 
        P.kwargs.__origin__ is P 
 
        This type is meant for runtime introspection and has no special meaning to 
        static type checkers. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">origin):</span>
            <span class="s1">self.__origin__ = origin</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self.__origin__.__name__</span><span class="s0">}</span><span class="s3">.kwargs&quot;</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">ParamSpecKwargs):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s0">return </span><span class="s1">self.__origin__ == other.__origin__</span>

<span class="s2"># 3.10+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'ParamSpec'</span><span class="s1">):</span>

    <span class="s2"># Add default parameter - PEP 696</span>
    <span class="s0">class </span><span class="s1">ParamSpec(metaclass=_TypeVarLikeMeta):</span>
        <span class="s4">&quot;&quot;&quot;Parameter specification.&quot;&quot;&quot;</span>

        <span class="s1">_backported_typevarlike = typing.ParamSpec</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">bound=</span><span class="s0">None,</span>
                    <span class="s1">covariant=</span><span class="s0">False, </span><span class="s1">contravariant=</span><span class="s0">False,</span>
                    <span class="s1">infer_variance=</span><span class="s0">False, </span><span class="s1">default=_marker):</span>
            <span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;TypeAliasType&quot;</span><span class="s1">):</span>
                <span class="s2"># PEP 695 implemented, can pass infer_variance to typing.TypeVar</span>
                <span class="s1">paramspec = typing.ParamSpec(name</span><span class="s0">, </span><span class="s1">bound=bound</span><span class="s0">,</span>
                                             <span class="s1">covariant=covariant</span><span class="s0">,</span>
                                             <span class="s1">contravariant=contravariant</span><span class="s0">,</span>
                                             <span class="s1">infer_variance=infer_variance)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">paramspec = typing.ParamSpec(name</span><span class="s0">, </span><span class="s1">bound=bound</span><span class="s0">,</span>
                                             <span class="s1">covariant=covariant</span><span class="s0">,</span>
                                             <span class="s1">contravariant=contravariant)</span>
                <span class="s1">paramspec.__infer_variance__ = infer_variance</span>

            <span class="s1">_set_default(paramspec</span><span class="s0">, </span><span class="s1">default)</span>
            <span class="s1">_set_module(paramspec)</span>
            <span class="s0">return </span><span class="s1">paramspec</span>

        <span class="s0">def </span><span class="s1">__init_subclass__(cls) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;type '</span><span class="s0">{</span><span class="s1">__name__</span><span class="s0">}</span><span class="s3">.ParamSpec' is not an acceptable base type&quot;</span><span class="s1">)</span>

<span class="s2"># 3.7-3.9</span>
<span class="s0">else</span><span class="s1">:</span>

    <span class="s2"># Inherits from list as a workaround for Callable checks in Python &lt; 3.9.2.</span>
    <span class="s0">class </span><span class="s1">ParamSpec(list</span><span class="s0">, </span><span class="s1">_DefaultMixin):</span>
        <span class="s4">&quot;&quot;&quot;Parameter specification variable. 
 
        Usage:: 
 
           P = ParamSpec('P') 
 
        Parameter specification variables exist primarily for the benefit of static 
        type checkers.  They are used to forward the parameter types of one 
        callable to another callable, a pattern commonly found in higher order 
        functions and decorators.  They are only valid when used in ``Concatenate``, 
        or s the first argument to ``Callable``. In Python 3.10 and higher, 
        they are also supported in user-defined Generics at runtime. 
        See class Generic for more information on generic types.  An 
        example for annotating a decorator:: 
 
           T = TypeVar('T') 
           P = ParamSpec('P') 
 
           def add_logging(f: Callable[P, T]) -&gt; Callable[P, T]: 
               '''A type-safe decorator to add logging to a function.''' 
               def inner(*args: P.args, **kwargs: P.kwargs) -&gt; T: 
                   logging.info(f'{f.__name__} was called') 
                   return f(*args, **kwargs) 
               return inner 
 
           @add_logging 
           def add_two(x: float, y: float) -&gt; float: 
               '''Add two numbers together.''' 
               return x + y 
 
        Parameter specification variables defined with covariant=True or 
        contravariant=True can be used to declare covariant or contravariant 
        generic types.  These keyword arguments are valid, but their actual semantics 
        are yet to be decided.  See PEP 612 for details. 
 
        Parameter specification variables can be introspected. e.g.: 
 
           P.__name__ == 'T' 
           P.__bound__ == None 
           P.__covariant__ == False 
           P.__contravariant__ == False 
 
        Note that only parameter specification variables defined in global scope can 
        be pickled. 
        &quot;&quot;&quot;</span>

        <span class="s2"># Trick Generic __parameters__.</span>
        <span class="s1">__class__ = typing.TypeVar</span>

        <span class="s1">@property</span>
        <span class="s0">def </span><span class="s1">args(self):</span>
            <span class="s0">return </span><span class="s1">ParamSpecArgs(self)</span>

        <span class="s1">@property</span>
        <span class="s0">def </span><span class="s1">kwargs(self):</span>
            <span class="s0">return </span><span class="s1">ParamSpecKwargs(self)</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">bound=</span><span class="s0">None, </span><span class="s1">covariant=</span><span class="s0">False, </span><span class="s1">contravariant=</span><span class="s0">False,</span>
                     <span class="s1">infer_variance=</span><span class="s0">False, </span><span class="s1">default=_marker):</span>
            <span class="s1">super().__init__([self])</span>
            <span class="s1">self.__name__ = name</span>
            <span class="s1">self.__covariant__ = bool(covariant)</span>
            <span class="s1">self.__contravariant__ = bool(contravariant)</span>
            <span class="s1">self.__infer_variance__ = bool(infer_variance)</span>
            <span class="s0">if </span><span class="s1">bound:</span>
                <span class="s1">self.__bound__ = typing._type_check(bound</span><span class="s0">, </span><span class="s3">'Bound must be a type.'</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.__bound__ = </span><span class="s0">None</span>
            <span class="s1">_DefaultMixin.__init__(self</span><span class="s0">, </span><span class="s1">default)</span>

            <span class="s2"># for pickling:</span>
            <span class="s1">def_mod = _caller()</span>
            <span class="s0">if </span><span class="s1">def_mod != </span><span class="s3">'typing_extensions'</span><span class="s1">:</span>
                <span class="s1">self.__module__ = def_mod</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">if </span><span class="s1">self.__infer_variance__:</span>
                <span class="s1">prefix = </span><span class="s3">''</span>
            <span class="s0">elif </span><span class="s1">self.__covariant__:</span>
                <span class="s1">prefix = </span><span class="s3">'+'</span>
            <span class="s0">elif </span><span class="s1">self.__contravariant__:</span>
                <span class="s1">prefix = </span><span class="s3">'-'</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">prefix = </span><span class="s3">'~'</span>
            <span class="s0">return </span><span class="s1">prefix + self.__name__</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">object.__hash__(self)</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">return </span><span class="s1">self </span><span class="s0">is </span><span class="s1">other</span>

        <span class="s0">def </span><span class="s1">__reduce__(self):</span>
            <span class="s0">return </span><span class="s1">self.__name__</span>

        <span class="s2"># Hack to get typing._type_check to pass.</span>
        <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">pass</span>


<span class="s2"># 3.7-3.9</span>
<span class="s0">if not </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'Concatenate'</span><span class="s1">):</span>
    <span class="s2"># Inherits from list as a workaround for Callable checks in Python &lt; 3.9.2.</span>
    <span class="s0">class </span><span class="s1">_ConcatenateGenericAlias(list):</span>

        <span class="s2"># Trick Generic into looking into this for __parameters__.</span>
        <span class="s1">__class__ = typing._GenericAlias</span>

        <span class="s2"># Flag in 3.8.</span>
        <span class="s1">_special = </span><span class="s0">False</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">origin</span><span class="s0">, </span><span class="s1">args):</span>
            <span class="s1">super().__init__(args)</span>
            <span class="s1">self.__origin__ = origin</span>
            <span class="s1">self.__args__ = args</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s1">_type_repr = typing._type_repr</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s3">f'</span><span class="s0">{</span><span class="s1">_type_repr(self.__origin__)</span><span class="s0">}</span><span class="s3">'</span>
                    <span class="s3">f'[</span><span class="s0">{</span><span class="s3">&quot;, &quot;</span><span class="s1">.join(_type_repr(arg) </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">self.__args__)</span><span class="s0">}</span><span class="s3">]'</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">hash((self.__origin__</span><span class="s0">, </span><span class="s1">self.__args__))</span>

        <span class="s2"># Hack to get typing._type_check to pass in Generic.</span>
        <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">pass</span>

        <span class="s1">@property</span>
        <span class="s0">def </span><span class="s1">__parameters__(self):</span>
            <span class="s0">return </span><span class="s1">tuple(</span>
                <span class="s1">tp </span><span class="s0">for </span><span class="s1">tp </span><span class="s0">in </span><span class="s1">self.__args__ </span><span class="s0">if </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">(typing.TypeVar</span><span class="s0">, </span><span class="s1">ParamSpec))</span>
            <span class="s1">)</span>


<span class="s2"># 3.7-3.9</span>
<span class="s1">@typing._tp_cache</span>
<span class="s0">def </span><span class="s1">_concatenate_getitem(self</span><span class="s0">, </span><span class="s1">parameters):</span>
    <span class="s0">if </span><span class="s1">parameters == ():</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Cannot take a Concatenate of no types.&quot;</span><span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">isinstance(parameters</span><span class="s0">, </span><span class="s1">tuple):</span>
        <span class="s1">parameters = (parameters</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">isinstance(parameters[-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ParamSpec):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;The last parameter to Concatenate should be a &quot;</span>
                        <span class="s3">&quot;ParamSpec variable.&quot;</span><span class="s1">)</span>
    <span class="s1">msg = </span><span class="s3">&quot;Concatenate[arg, ...]: each arg must be a type.&quot;</span>
    <span class="s1">parameters = tuple(typing._type_check(p</span><span class="s0">, </span><span class="s1">msg) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">parameters)</span>
    <span class="s0">return </span><span class="s1">_ConcatenateGenericAlias(self</span><span class="s0">, </span><span class="s1">parameters)</span>


<span class="s2"># 3.10+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'Concatenate'</span><span class="s1">):</span>
    <span class="s1">Concatenate = typing.Concatenate</span>
    <span class="s1">_ConcatenateGenericAlias = typing._ConcatenateGenericAlias  </span><span class="s2"># noqa: F811</span>
<span class="s2"># 3.9</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
    <span class="s1">@_TypeAliasForm</span>
    <span class="s0">def </span><span class="s1">Concatenate(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s4">&quot;&quot;&quot;Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a 
        higher order function which adds, removes or transforms parameters of a 
        callable. 
 
        For example:: 
 
           Callable[Concatenate[int, P], int] 
 
        See PEP 612 for detailed information. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_concatenate_getitem(self</span><span class="s0">, </span><span class="s1">parameters)</span>
<span class="s2"># 3.7-8</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_ConcatenateForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s0">return </span><span class="s1">_concatenate_getitem(self</span><span class="s0">, </span><span class="s1">parameters)</span>

    <span class="s1">Concatenate = _ConcatenateForm(</span>
        <span class="s3">'Concatenate'</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a 
        higher order function which adds, removes or transforms parameters of a 
        callable. 
 
        For example:: 
 
           Callable[Concatenate[int, P], int] 
 
        See PEP 612 for detailed information. 
        &quot;&quot;&quot;</span><span class="s1">)</span>

<span class="s2"># 3.10+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'TypeGuard'</span><span class="s1">):</span>
    <span class="s1">TypeGuard = typing.TypeGuard</span>
<span class="s2"># 3.9</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_TypeGuardForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

    <span class="s1">@_TypeGuardForm</span>
    <span class="s0">def </span><span class="s1">TypeGuard(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s4">&quot;&quot;&quot;Special typing form used to annotate the return type of a user-defined 
        type guard function.  ``TypeGuard`` only accepts a single type argument. 
        At runtime, functions marked this way should return a boolean. 
 
        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static 
        type checkers to determine a more precise type of an expression within a 
        program's code flow.  Usually type narrowing is done by analyzing 
        conditional code flow and applying the narrowing to a block of code.  The 
        conditional expression here is sometimes referred to as a &quot;type guard&quot;. 
 
        Sometimes it would be convenient to use a user-defined boolean function 
        as a type guard.  Such a function should use ``TypeGuard[...]`` as its 
        return type to alert static type checkers to this intention. 
 
        Using  ``-&gt; TypeGuard`` tells the static type checker that for a given 
        function: 
 
        1. The return value is a boolean. 
        2. If the return value is ``True``, the type of its argument 
        is the type inside ``TypeGuard``. 
 
        For example:: 
 
            def is_str(val: Union[str, float]): 
                # &quot;isinstance&quot; type guard 
                if isinstance(val, str): 
                    # Type of ``val`` is narrowed to ``str`` 
                    ... 
                else: 
                    # Else, type of ``val`` is narrowed to ``float``. 
                    ... 
 
        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower 
        form of ``TypeA`` (it can even be a wider form) and this may lead to 
        type-unsafe results.  The main reason is to allow for things like 
        narrowing ``List[object]`` to ``List[str]`` even though the latter is not 
        a subtype of the former, since ``List`` is invariant.  The responsibility of 
        writing type-safe type guards is left to the user. 
 
        ``TypeGuard`` also works with type variables.  For more information, see 
        PEP 647 (User-Defined Type Guards). 
        &quot;&quot;&quot;</span>
        <span class="s1">item = typing._type_check(parameters</span><span class="s0">, </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">accepts only a single type.'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>
<span class="s2"># 3.7-3.8</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_TypeGuardForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s1">item = typing._type_check(parameters</span><span class="s0">,</span>
                                      <span class="s3">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s3">accepts only a single type'</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">TypeGuard = _TypeGuardForm(</span>
        <span class="s3">'TypeGuard'</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;Special typing form used to annotate the return type of a user-defined 
        type guard function.  ``TypeGuard`` only accepts a single type argument. 
        At runtime, functions marked this way should return a boolean. 
 
        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static 
        type checkers to determine a more precise type of an expression within a 
        program's code flow.  Usually type narrowing is done by analyzing 
        conditional code flow and applying the narrowing to a block of code.  The 
        conditional expression here is sometimes referred to as a &quot;type guard&quot;. 
 
        Sometimes it would be convenient to use a user-defined boolean function 
        as a type guard.  Such a function should use ``TypeGuard[...]`` as its 
        return type to alert static type checkers to this intention. 
 
        Using  ``-&gt; TypeGuard`` tells the static type checker that for a given 
        function: 
 
        1. The return value is a boolean. 
        2. If the return value is ``True``, the type of its argument 
        is the type inside ``TypeGuard``. 
 
        For example:: 
 
            def is_str(val: Union[str, float]): 
                # &quot;isinstance&quot; type guard 
                if isinstance(val, str): 
                    # Type of ``val`` is narrowed to ``str`` 
                    ... 
                else: 
                    # Else, type of ``val`` is narrowed to ``float``. 
                    ... 
 
        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower 
        form of ``TypeA`` (it can even be a wider form) and this may lead to 
        type-unsafe results.  The main reason is to allow for things like 
        narrowing ``List[object]`` to ``List[str]`` even though the latter is not 
        a subtype of the former, since ``List`` is invariant.  The responsibility of 
        writing type-safe type guards is left to the user. 
 
        ``TypeGuard`` also works with type variables.  For more information, see 
        PEP 647 (User-Defined Type Guards). 
        &quot;&quot;&quot;</span><span class="s1">)</span>


<span class="s2"># Vendored from cpython typing._SpecialFrom</span>
<span class="s0">class </span><span class="s1">_SpecialForm(typing._Final</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s1">__slots__ = (</span><span class="s3">'_name'</span><span class="s0">, </span><span class="s3">'__doc__'</span><span class="s0">, </span><span class="s3">'_getitem'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">getitem):</span>
        <span class="s1">self._getitem = getitem</span>
        <span class="s1">self._name = getitem.__name__</span>
        <span class="s1">self.__doc__ = getitem.__doc__</span>

    <span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s0">if </span><span class="s1">item </span><span class="s0">in </span><span class="s1">{</span><span class="s3">'__name__'</span><span class="s0">, </span><span class="s3">'__qualname__'</span><span class="s1">}:</span>
            <span class="s0">return </span><span class="s1">self._name</span>

        <span class="s0">raise </span><span class="s1">AttributeError(item)</span>

    <span class="s0">def </span><span class="s1">__mro_entries__(self</span><span class="s0">, </span><span class="s1">bases):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Cannot subclass </span><span class="s0">{</span><span class="s1">self</span><span class="s0">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s3">f'typing_extensions.</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">}</span><span class="s3">'</span>

    <span class="s0">def </span><span class="s1">__reduce__(self):</span>
        <span class="s0">return </span><span class="s1">self._name</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Cannot instantiate </span><span class="s0">{</span><span class="s1">self</span><span class="s0">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__or__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">return </span><span class="s1">typing.Union[self</span><span class="s0">, </span><span class="s1">other]</span>

    <span class="s0">def </span><span class="s1">__ror__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">return </span><span class="s1">typing.Union[other</span><span class="s0">, </span><span class="s1">self]</span>

    <span class="s0">def </span><span class="s1">__instancecheck__(self</span><span class="s0">, </span><span class="s1">obj):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">cannot be used with isinstance()&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__subclasscheck__(self</span><span class="s0">, </span><span class="s1">cls):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">cannot be used with issubclass()&quot;</span><span class="s1">)</span>

    <span class="s1">@typing._tp_cache</span>
    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s0">return </span><span class="s1">self._getitem(self</span><span class="s0">, </span><span class="s1">parameters)</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;LiteralString&quot;</span><span class="s1">):</span>
    <span class="s1">LiteralString = typing.LiteralString</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">@_SpecialForm</span>
    <span class="s0">def </span><span class="s1">LiteralString(self</span><span class="s0">, </span><span class="s1">params):</span>
        <span class="s4">&quot;&quot;&quot;Represents an arbitrary literal string. 
 
        Example:: 
 
          from typing_extensions import LiteralString 
 
          def query(sql: LiteralString) -&gt; ...: 
              ... 
 
          query(&quot;SELECT * FROM table&quot;)  # ok 
          query(f&quot;SELECT * FROM {input()}&quot;)  # not ok 
 
        See PEP 675 for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">is not subscriptable&quot;</span><span class="s1">)</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;Self&quot;</span><span class="s1">):</span>
    <span class="s1">Self = typing.Self</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">@_SpecialForm</span>
    <span class="s0">def </span><span class="s1">Self(self</span><span class="s0">, </span><span class="s1">params):</span>
        <span class="s4">&quot;&quot;&quot;Used to spell the type of &quot;self&quot; in classes. 
 
        Example:: 
 
          from typing import Self 
 
          class ReturnsSelf: 
              def parse(self, data: bytes) -&gt; Self: 
                  ... 
                  return self 
 
        &quot;&quot;&quot;</span>

        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">is not subscriptable&quot;</span><span class="s1">)</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;Never&quot;</span><span class="s1">):</span>
    <span class="s1">Never = typing.Never</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">@_SpecialForm</span>
    <span class="s0">def </span><span class="s1">Never(self</span><span class="s0">, </span><span class="s1">params):</span>
        <span class="s4">&quot;&quot;&quot;The bottom type, a type that has no members. 
 
        This can be used to define a function that should never be 
        called, or a function that never returns:: 
 
            from typing_extensions import Never 
 
            def never_call_me(arg: Never) -&gt; None: 
                pass 
 
            def int_or_str(arg: int | str) -&gt; None: 
                never_call_me(arg)  # type checker error 
                match arg: 
                    case int(): 
                        print(&quot;It's an int&quot;) 
                    case str(): 
                        print(&quot;It's a str&quot;) 
                    case _: 
                        never_call_me(arg)  # ok, arg is of type Never 
 
        &quot;&quot;&quot;</span>

        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">is not subscriptable&quot;</span><span class="s1">)</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'Required'</span><span class="s1">):</span>
    <span class="s1">Required = typing.Required</span>
    <span class="s1">NotRequired = typing.NotRequired</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_ExtensionsSpecialForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

    <span class="s1">@_ExtensionsSpecialForm</span>
    <span class="s0">def </span><span class="s1">Required(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s4">&quot;&quot;&quot;A special typing construct to mark a key of a total=False TypedDict 
        as required. For example: 
 
            class Movie(TypedDict, total=False): 
                title: Required[str] 
                year: int 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
 
        There is no runtime checking that a required key is actually provided 
        when instantiating a related TypedDict. 
        &quot;&quot;&quot;</span>
        <span class="s1">item = typing._type_check(parameters</span><span class="s0">, </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s3">accepts only a single type.'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">@_ExtensionsSpecialForm</span>
    <span class="s0">def </span><span class="s1">NotRequired(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s4">&quot;&quot;&quot;A special typing construct to mark a key of a TypedDict as 
        potentially missing. For example: 
 
            class Movie(TypedDict): 
                title: str 
                year: NotRequired[int] 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
        &quot;&quot;&quot;</span>
        <span class="s1">item = typing._type_check(parameters</span><span class="s0">, </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s3">accepts only a single type.'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_RequiredForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s1">item = typing._type_check(parameters</span><span class="s0">,</span>
                                      <span class="s3">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s3">accepts only a single type.'</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">Required = _RequiredForm(</span>
        <span class="s3">'Required'</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;A special typing construct to mark a key of a total=False TypedDict 
        as required. For example: 
 
            class Movie(TypedDict, total=False): 
                title: Required[str] 
                year: int 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
 
        There is no runtime checking that a required key is actually provided 
        when instantiating a related TypedDict. 
        &quot;&quot;&quot;</span><span class="s1">)</span>
    <span class="s1">NotRequired = _RequiredForm(</span>
        <span class="s3">'NotRequired'</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;A special typing construct to mark a key of a TypedDict as 
        potentially missing. For example: 
 
            class Movie(TypedDict): 
                title: str 
                year: NotRequired[int] 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
        &quot;&quot;&quot;</span><span class="s1">)</span>


<span class="s1">_UNPACK_DOC = </span><span class="s3">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s3">Type unpack operator. 
 
The type unpack operator takes the child types from some container type, 
such as `tuple[int, str]` or a `TypeVarTuple`, and 'pulls them out'. For 
example: 
 
  # For some generic class `Foo`: 
  Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str] 
 
  Ts = TypeVarTuple('Ts') 
  # Specifies that `Bar` is generic in an arbitrary number of types. 
  # (Think of `Ts` as a tuple of an arbitrary number of individual 
  #  `TypeVar`s, which the `Unpack` is 'pulling out' directly into the 
  #  `Generic[]`.) 
  class Bar(Generic[Unpack[Ts]]): ... 
  Bar[int]  # Valid 
  Bar[int, str]  # Also valid 
 
From Python 3.11, this can also be done using the `*` operator: 
 
    Foo[*tuple[int, str]] 
    class Bar(Generic[*Ts]): ... 
 
The operator can also be used along with a `TypedDict` to annotate 
`**kwargs` in a function signature. For instance: 
 
  class Movie(TypedDict): 
    name: str 
    year: int 
 
  # This function expects two keyword arguments - *name* of type `str` and 
  # *year* of type `int`. 
  def foo(**kwargs: Unpack[Movie]): ... 
 
Note that there is only some runtime checking of this operator. Not 
everything the runtime allows may be accepted by static type checkers. 
 
For more information, see PEP 646 and PEP 692. 
&quot;&quot;&quot;</span>


<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">12</span><span class="s1">):  </span><span class="s2"># PEP 692 changed the repr of Unpack[]</span>
    <span class="s1">Unpack = typing.Unpack</span>

    <span class="s0">def </span><span class="s1">_is_unpack(obj):</span>
        <span class="s0">return </span><span class="s1">get_origin(obj) </span><span class="s0">is </span><span class="s1">Unpack</span>

<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_UnpackSpecialForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">getitem):</span>
            <span class="s1">super().__init__(getitem)</span>
            <span class="s1">self.__doc__ = _UNPACK_DOC</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

    <span class="s0">class </span><span class="s1">_UnpackAlias(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">__class__ = typing.TypeVar</span>

    <span class="s1">@_UnpackSpecialForm</span>
    <span class="s0">def </span><span class="s1">Unpack(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s1">item = typing._type_check(parameters</span><span class="s0">, </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s3">accepts only a single type.'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">_UnpackAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">_is_unpack(obj):</span>
        <span class="s0">return </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">_UnpackAlias)</span>

<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_UnpackAlias(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">__class__ = typing.TypeVar</span>

    <span class="s0">class </span><span class="s1">_UnpackForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s1">item = typing._type_check(parameters</span><span class="s0">,</span>
                                      <span class="s3">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s3">accepts only a single type.'</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">_UnpackAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">Unpack = _UnpackForm(</span><span class="s3">'Unpack'</span><span class="s0">, </span><span class="s1">doc=_UNPACK_DOC)</span>

    <span class="s0">def </span><span class="s1">_is_unpack(obj):</span>
        <span class="s0">return </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">_UnpackAlias)</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;TypeVarTuple&quot;</span><span class="s1">):  </span><span class="s2"># 3.11+</span>

    <span class="s2"># Add default parameter - PEP 696</span>
    <span class="s0">class </span><span class="s1">TypeVarTuple(metaclass=_TypeVarLikeMeta):</span>
        <span class="s4">&quot;&quot;&quot;Type variable tuple.&quot;&quot;&quot;</span>

        <span class="s1">_backported_typevarlike = typing.TypeVarTuple</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">default=_marker):</span>
            <span class="s1">tvt = typing.TypeVarTuple(name)</span>
            <span class="s1">_set_default(tvt</span><span class="s0">, </span><span class="s1">default)</span>
            <span class="s1">_set_module(tvt)</span>
            <span class="s0">return </span><span class="s1">tvt</span>

        <span class="s0">def </span><span class="s1">__init_subclass__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Cannot subclass special typing classes&quot;</span><span class="s1">)</span>

<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">TypeVarTuple(_DefaultMixin):</span>
        <span class="s4">&quot;&quot;&quot;Type variable tuple. 
 
        Usage:: 
 
            Ts = TypeVarTuple('Ts') 
 
        In the same way that a normal type variable is a stand-in for a single 
        type such as ``int``, a type variable *tuple* is a stand-in for a *tuple* 
        type such as ``Tuple[int, str]``. 
 
        Type variable tuples can be used in ``Generic`` declarations. 
        Consider the following example:: 
 
            class Array(Generic[*Ts]): ... 
 
        The ``Ts`` type variable tuple here behaves like ``tuple[T1, T2]``, 
        where ``T1`` and ``T2`` are type variables. To use these type variables 
        as type parameters of ``Array``, we must *unpack* the type variable tuple using 
        the star operator: ``*Ts``. The signature of ``Array`` then behaves 
        as if we had simply written ``class Array(Generic[T1, T2]): ...``. 
        In contrast to ``Generic[T1, T2]``, however, ``Generic[*Shape]`` allows 
        us to parameterise the class with an *arbitrary* number of type parameters. 
 
        Type variable tuples can be used anywhere a normal ``TypeVar`` can. 
        This includes class definitions, as shown above, as well as function 
        signatures and variable annotations:: 
 
            class Array(Generic[*Ts]): 
 
                def __init__(self, shape: Tuple[*Ts]): 
                    self._shape: Tuple[*Ts] = shape 
 
                def get_shape(self) -&gt; Tuple[*Ts]: 
                    return self._shape 
 
            shape = (Height(480), Width(640)) 
            x: Array[Height, Width] = Array(shape) 
            y = abs(x)  # Inferred type is Array[Height, Width] 
            z = x + x   #        ...    is Array[Height, Width] 
            x.get_shape()  #     ...    is tuple[Height, Width] 
 
        &quot;&quot;&quot;</span>

        <span class="s2"># Trick Generic __parameters__.</span>
        <span class="s1">__class__ = typing.TypeVar</span>

        <span class="s0">def </span><span class="s1">__iter__(self):</span>
            <span class="s0">yield </span><span class="s1">self.__unpacked__</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">default=_marker):</span>
            <span class="s1">self.__name__ = name</span>
            <span class="s1">_DefaultMixin.__init__(self</span><span class="s0">, </span><span class="s1">default)</span>

            <span class="s2"># for pickling:</span>
            <span class="s1">def_mod = _caller()</span>
            <span class="s0">if </span><span class="s1">def_mod != </span><span class="s3">'typing_extensions'</span><span class="s1">:</span>
                <span class="s1">self.__module__ = def_mod</span>

            <span class="s1">self.__unpacked__ = Unpack[self]</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s1">self.__name__</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">object.__hash__(self)</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">return </span><span class="s1">self </span><span class="s0">is </span><span class="s1">other</span>

        <span class="s0">def </span><span class="s1">__reduce__(self):</span>
            <span class="s0">return </span><span class="s1">self.__name__</span>

        <span class="s0">def </span><span class="s1">__init_subclass__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
            <span class="s0">if </span><span class="s3">'_root' </span><span class="s0">not in </span><span class="s1">kwds:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Cannot subclass special typing classes&quot;</span><span class="s1">)</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;reveal_type&quot;</span><span class="s1">):</span>
    <span class="s1">reveal_type = typing.reveal_type</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">reveal_type(__obj: T) -&gt; T:</span>
        <span class="s4">&quot;&quot;&quot;Reveal the inferred type of a variable. 
 
        When a static type checker encounters a call to ``reveal_type()``, 
        it will emit the inferred type of the argument:: 
 
            x: int = 1 
            reveal_type(x) 
 
        Running a static type checker (e.g., ``mypy``) on this example 
        will produce output similar to 'Revealed type is &quot;builtins.int&quot;'. 
 
        At runtime, the function prints the runtime type of the 
        argument and returns it unchanged. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">print(</span><span class="s3">f&quot;Runtime type is </span><span class="s0">{</span><span class="s1">type(__obj).__name__</span><span class="s0">!r}</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s1">file=sys.stderr)</span>
        <span class="s0">return </span><span class="s1">__obj</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;assert_never&quot;</span><span class="s1">):</span>
    <span class="s1">assert_never = typing.assert_never</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">assert_never(__arg: Never) -&gt; Never:</span>
        <span class="s4">&quot;&quot;&quot;Assert to the type checker that a line of code is unreachable. 
 
        Example:: 
 
            def int_or_str(arg: int | str) -&gt; None: 
                match arg: 
                    case int(): 
                        print(&quot;It's an int&quot;) 
                    case str(): 
                        print(&quot;It's a str&quot;) 
                    case _: 
                        assert_never(arg) 
 
        If a type checker finds that a call to assert_never() is 
        reachable, it will emit an error. 
 
        At runtime, this throws an exception when called. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s3">&quot;Expected code to be unreachable&quot;</span><span class="s1">)</span>


<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">12</span><span class="s1">):</span>
    <span class="s2"># dataclass_transform exists in 3.11 but lacks the frozen_default parameter</span>
    <span class="s1">dataclass_transform = typing.dataclass_transform</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">dataclass_transform(</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">eq_default: bool = </span><span class="s0">True,</span>
        <span class="s1">order_default: bool = </span><span class="s0">False,</span>
        <span class="s1">kw_only_default: bool = </span><span class="s0">False,</span>
        <span class="s1">frozen_default: bool = </span><span class="s0">False,</span>
        <span class="s1">field_specifiers: typing.Tuple[</span>
            <span class="s1">typing.Union[typing.Type[typing.Any]</span><span class="s0">, </span><span class="s1">typing.Callable[...</span><span class="s0">, </span><span class="s1">typing.Any]]</span><span class="s0">,</span>
            <span class="s1">...</span>
        <span class="s1">] = ()</span><span class="s0">,</span>
        <span class="s1">**kwargs: typing.Any</span><span class="s0">,</span>
    <span class="s1">) -&gt; typing.Callable[[T]</span><span class="s0">, </span><span class="s1">T]:</span>
        <span class="s4">&quot;&quot;&quot;Decorator that marks a function, class, or metaclass as providing 
        dataclass-like behavior. 
 
        Example: 
 
            from typing_extensions import dataclass_transform 
 
            _T = TypeVar(&quot;_T&quot;) 
 
            # Used on a decorator function 
            @dataclass_transform() 
            def create_model(cls: type[_T]) -&gt; type[_T]: 
                ... 
                return cls 
 
            @create_model 
            class CustomerModel: 
                id: int 
                name: str 
 
            # Used on a base class 
            @dataclass_transform() 
            class ModelBase: ... 
 
            class CustomerModel(ModelBase): 
                id: int 
                name: str 
 
            # Used on a metaclass 
            @dataclass_transform() 
            class ModelMeta(type): ... 
 
            class ModelBase(metaclass=ModelMeta): ... 
 
            class CustomerModel(ModelBase): 
                id: int 
                name: str 
 
        Each of the ``CustomerModel`` classes defined in this example will now 
        behave similarly to a dataclass created with the ``@dataclasses.dataclass`` 
        decorator. For example, the type checker will synthesize an ``__init__`` 
        method. 
 
        The arguments to this decorator can be used to customize this behavior: 
        - ``eq_default`` indicates whether the ``eq`` parameter is assumed to be 
          True or False if it is omitted by the caller. 
        - ``order_default`` indicates whether the ``order`` parameter is 
          assumed to be True or False if it is omitted by the caller. 
        - ``kw_only_default`` indicates whether the ``kw_only`` parameter is 
          assumed to be True or False if it is omitted by the caller. 
        - ``frozen_default`` indicates whether the ``frozen`` parameter is 
          assumed to be True or False if it is omitted by the caller. 
        - ``field_specifiers`` specifies a static list of supported classes 
          or functions that describe fields, similar to ``dataclasses.field()``. 
 
        At runtime, this decorator records its arguments in the 
        ``__dataclass_transform__`` attribute on the decorated object. 
 
        See PEP 681 for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">decorator(cls_or_fn):</span>
            <span class="s1">cls_or_fn.__dataclass_transform__ = {</span>
                <span class="s3">&quot;eq_default&quot;</span><span class="s1">: eq_default</span><span class="s0">,</span>
                <span class="s3">&quot;order_default&quot;</span><span class="s1">: order_default</span><span class="s0">,</span>
                <span class="s3">&quot;kw_only_default&quot;</span><span class="s1">: kw_only_default</span><span class="s0">,</span>
                <span class="s3">&quot;frozen_default&quot;</span><span class="s1">: frozen_default</span><span class="s0">,</span>
                <span class="s3">&quot;field_specifiers&quot;</span><span class="s1">: field_specifiers</span><span class="s0">,</span>
                <span class="s3">&quot;kwargs&quot;</span><span class="s1">: kwargs</span><span class="s0">,</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">cls_or_fn</span>
        <span class="s0">return </span><span class="s1">decorator</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;override&quot;</span><span class="s1">):</span>
    <span class="s1">override = typing.override</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">_F = typing.TypeVar(</span><span class="s3">&quot;_F&quot;</span><span class="s0">, </span><span class="s1">bound=typing.Callable[...</span><span class="s0">, </span><span class="s1">typing.Any])</span>

    <span class="s0">def </span><span class="s1">override(__arg: _F) -&gt; _F:</span>
        <span class="s4">&quot;&quot;&quot;Indicate that a method is intended to override a method in a base class. 
 
        Usage: 
 
            class Base: 
                def method(self) -&gt; None: ... 
                    pass 
 
            class Child(Base): 
                @override 
                def method(self) -&gt; None: 
                    super().method() 
 
        When this decorator is applied to a method, the type checker will 
        validate that it overrides a method with the same name on a base class. 
        This helps prevent bugs that may occur when a base class is changed 
        without an equivalent change to a child class. 
 
        There is no runtime checking of these properties. The decorator 
        sets the ``__override__`` attribute to ``True`` on the decorated object 
        to allow runtime introspection. 
 
        See PEP 698 for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">__arg.__override__ = </span><span class="s0">True</span>
        <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">TypeError):</span>
            <span class="s2"># Skip the attribute silently if it is not writable.</span>
            <span class="s2"># AttributeError happens if the object has __slots__ or a</span>
            <span class="s2"># read-only property, TypeError if it's a builtin class.</span>
            <span class="s0">pass</span>
        <span class="s0">return </span><span class="s1">__arg</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;deprecated&quot;</span><span class="s1">):</span>
    <span class="s1">deprecated = typing.deprecated</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">_T = typing.TypeVar(</span><span class="s3">&quot;_T&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">deprecated(</span>
        <span class="s1">__msg: str</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">category: typing.Optional[typing.Type[Warning]] = DeprecationWarning</span><span class="s0">,</span>
        <span class="s1">stacklevel: int = </span><span class="s5">1</span><span class="s0">,</span>
    <span class="s1">) -&gt; typing.Callable[[_T]</span><span class="s0">, </span><span class="s1">_T]:</span>
        <span class="s4">&quot;&quot;&quot;Indicate that a class, function or overload is deprecated. 
 
        Usage: 
 
            @deprecated(&quot;Use B instead&quot;) 
            class A: 
                pass 
 
            @deprecated(&quot;Use g instead&quot;) 
            def f(): 
                pass 
 
            @overload 
            @deprecated(&quot;int support is deprecated&quot;) 
            def g(x: int) -&gt; int: ... 
            @overload 
            def g(x: str) -&gt; int: ... 
 
        When this decorator is applied to an object, the type checker 
        will generate a diagnostic on usage of the deprecated object. 
 
        The warning specified by ``category`` will be emitted on use 
        of deprecated objects. For functions, that happens on calls; 
        for classes, on instantiation. If the ``category`` is ``None``, 
        no warning is emitted. The ``stacklevel`` determines where the 
        warning is emitted. If it is ``1`` (the default), the warning 
        is emitted at the direct caller of the deprecated object; if it 
        is higher, it is emitted further up the stack. 
 
        The decorator sets the ``__deprecated__`` 
        attribute on the decorated object to the deprecation message 
        passed to the decorator. If applied to an overload, the decorator 
        must be after the ``@overload`` decorator for the attribute to 
        exist on the overload as returned by ``get_overloads()``. 
 
        See PEP 702 for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">decorator(__arg: _T) -&gt; _T:</span>
            <span class="s0">if </span><span class="s1">category </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">__arg.__deprecated__ = __msg</span>
                <span class="s0">return </span><span class="s1">__arg</span>
            <span class="s0">elif </span><span class="s1">isinstance(__arg</span><span class="s0">, </span><span class="s1">type):</span>
                <span class="s1">original_new = __arg.__new__</span>
                <span class="s1">has_init = __arg.__init__ </span><span class="s0">is not </span><span class="s1">object.__init__</span>

                <span class="s1">@functools.wraps(original_new)</span>
                <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                    <span class="s1">warnings.warn(__msg</span><span class="s0">, </span><span class="s1">category=category</span><span class="s0">, </span><span class="s1">stacklevel=stacklevel + </span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s0">if </span><span class="s1">original_new </span><span class="s0">is not </span><span class="s1">object.__new__:</span>
                        <span class="s0">return </span><span class="s1">original_new(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
                    <span class="s2"># Mirrors a similar check in object.__new__.</span>
                    <span class="s0">elif not </span><span class="s1">has_init </span><span class="s0">and </span><span class="s1">(args </span><span class="s0">or </span><span class="s1">kwargs):</span>
                        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">cls.__name__</span><span class="s0">}</span><span class="s3">() takes no arguments&quot;</span><span class="s1">)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s0">return </span><span class="s1">original_new(cls)</span>

                <span class="s1">__arg.__new__ = staticmethod(__new__)</span>
                <span class="s1">__arg.__deprecated__ = __new__.__deprecated__ = __msg</span>
                <span class="s0">return </span><span class="s1">__arg</span>
            <span class="s0">elif </span><span class="s1">callable(__arg):</span>
                <span class="s1">@functools.wraps(__arg)</span>
                <span class="s0">def </span><span class="s1">wrapper(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                    <span class="s1">warnings.warn(__msg</span><span class="s0">, </span><span class="s1">category=category</span><span class="s0">, </span><span class="s1">stacklevel=stacklevel + </span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s0">return </span><span class="s1">__arg(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

                <span class="s1">__arg.__deprecated__ = wrapper.__deprecated__ = __msg</span>
                <span class="s0">return </span><span class="s1">wrapper</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;@deprecated decorator with non-None category must be applied to &quot;</span>
                    <span class="s3">f&quot;a class or callable, not </span><span class="s0">{</span><span class="s1">__arg</span><span class="s0">!r}</span><span class="s3">&quot;</span>
                <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">decorator</span>


<span class="s2"># We have to do some monkey patching to deal with the dual nature of</span>
<span class="s2"># Unpack/TypeVarTuple:</span>
<span class="s2"># - We want Unpack to be a kind of TypeVar so it gets accepted in</span>
<span class="s2">#   Generic[Unpack[Ts]]</span>
<span class="s2"># - We want it to *not* be treated as a TypeVar for the purposes of</span>
<span class="s2">#   counting generic parameters, so that when we subscript a generic,</span>
<span class="s2">#   the runtime doesn't try to substitute the Unpack with the subscripted type.</span>
<span class="s0">if not </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;TypeVarTuple&quot;</span><span class="s1">):</span>
    <span class="s1">typing._collect_type_vars = _collect_type_vars</span>
    <span class="s1">typing._check_generic = _check_generic</span>


<span class="s2"># Backport typing.NamedTuple as it exists in Python 3.12.</span>
<span class="s2"># In 3.11, the ability to define generic `NamedTuple`s was supported.</span>
<span class="s2"># This was explicitly disallowed in 3.9-3.10, and only half-worked in &lt;=3.8.</span>
<span class="s2"># On 3.12, we added __orig_bases__ to call-based NamedTuples</span>
<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">12</span><span class="s1">):</span>
    <span class="s1">NamedTuple = typing.NamedTuple</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">_make_nmtuple(name</span><span class="s0">, </span><span class="s1">types</span><span class="s0">, </span><span class="s1">module</span><span class="s0">, </span><span class="s1">defaults=()):</span>
        <span class="s1">fields = [n </span><span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">types]</span>
        <span class="s1">annotations = {n: typing._type_check(t</span><span class="s0">, </span><span class="s3">f&quot;field </span><span class="s0">{</span><span class="s1">n</span><span class="s0">} </span><span class="s3">annotation must be a type&quot;</span><span class="s1">)</span>
                       <span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">types}</span>
        <span class="s1">nm_tpl = collections.namedtuple(name</span><span class="s0">, </span><span class="s1">fields</span><span class="s0">,</span>
                                        <span class="s1">defaults=defaults</span><span class="s0">, </span><span class="s1">module=module)</span>
        <span class="s1">nm_tpl.__annotations__ = nm_tpl.__new__.__annotations__ = annotations</span>
        <span class="s2"># The `_field_types` attribute was removed in 3.9;</span>
        <span class="s2"># in earlier versions, it is the same as the `__annotations__` attribute</span>
        <span class="s0">if </span><span class="s1">sys.version_info &lt; (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
            <span class="s1">nm_tpl._field_types = annotations</span>
        <span class="s0">return </span><span class="s1">nm_tpl</span>

    <span class="s1">_prohibited_namedtuple_fields = typing._prohibited</span>
    <span class="s1">_special_namedtuple_fields = frozenset({</span><span class="s3">'__module__'</span><span class="s0">, </span><span class="s3">'__name__'</span><span class="s0">, </span><span class="s3">'__annotations__'</span><span class="s1">})</span>

    <span class="s0">class </span><span class="s1">_NamedTupleMeta(type):</span>
        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">typename</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">ns):</span>
            <span class="s0">assert </span><span class="s1">_NamedTuple </span><span class="s0">in </span><span class="s1">bases</span>
            <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">bases:</span>
                <span class="s0">if </span><span class="s1">base </span><span class="s0">is not </span><span class="s1">_NamedTuple </span><span class="s0">and </span><span class="s1">base </span><span class="s0">is not </span><span class="s1">typing.Generic:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s3">'can only inherit from a NamedTuple type and Generic'</span><span class="s1">)</span>
            <span class="s1">bases = tuple(tuple </span><span class="s0">if </span><span class="s1">base </span><span class="s0">is </span><span class="s1">_NamedTuple </span><span class="s0">else </span><span class="s1">base </span><span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">bases)</span>
            <span class="s1">types = ns.get(</span><span class="s3">'__annotations__'</span><span class="s0">, </span><span class="s1">{})</span>
            <span class="s1">default_names = []</span>
            <span class="s0">for </span><span class="s1">field_name </span><span class="s0">in </span><span class="s1">types:</span>
                <span class="s0">if </span><span class="s1">field_name </span><span class="s0">in </span><span class="s1">ns:</span>
                    <span class="s1">default_names.append(field_name)</span>
                <span class="s0">elif </span><span class="s1">default_names:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Non-default namedtuple field </span><span class="s0">{</span><span class="s1">field_name</span><span class="s0">} </span><span class="s3">&quot;</span>
                                    <span class="s3">f&quot;cannot follow default field&quot;</span>
                                    <span class="s3">f&quot;</span><span class="s0">{</span><span class="s3">'s' </span><span class="s0">if </span><span class="s1">len(default_names) &gt; </span><span class="s5">1 </span><span class="s0">else </span><span class="s3">''</span><span class="s0">} </span><span class="s3">&quot;</span>
                                    <span class="s3">f&quot;</span><span class="s0">{</span><span class="s3">', '</span><span class="s1">.join(default_names)</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s1">nm_tpl = _make_nmtuple(</span>
                <span class="s1">typename</span><span class="s0">, </span><span class="s1">types.items()</span><span class="s0">,</span>
                <span class="s1">defaults=[ns[n] </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">default_names]</span><span class="s0">,</span>
                <span class="s1">module=ns[</span><span class="s3">'__module__'</span><span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s1">nm_tpl.__bases__ = bases</span>
            <span class="s0">if </span><span class="s1">typing.Generic </span><span class="s0">in </span><span class="s1">bases:</span>
                <span class="s1">class_getitem = typing.Generic.__class_getitem__.__func__</span>
                <span class="s1">nm_tpl.__class_getitem__ = classmethod(class_getitem)</span>
            <span class="s2"># update from user namespace without overriding special namedtuple attributes</span>
            <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">ns:</span>
                <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">_prohibited_namedtuple_fields:</span>
                    <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;Cannot overwrite NamedTuple attribute &quot; </span><span class="s1">+ key)</span>
                <span class="s0">elif </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">_special_namedtuple_fields </span><span class="s0">and </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">nm_tpl._fields:</span>
                    <span class="s1">setattr(nm_tpl</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">ns[key])</span>
            <span class="s0">if </span><span class="s1">typing.Generic </span><span class="s0">in </span><span class="s1">bases:</span>
                <span class="s1">nm_tpl.__init_subclass__()</span>
            <span class="s0">return </span><span class="s1">nm_tpl</span>

    <span class="s0">def </span><span class="s1">NamedTuple(__typename</span><span class="s0">, </span><span class="s1">__fields=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">__fields </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">__fields = kwargs.items()</span>
        <span class="s0">elif </span><span class="s1">kwargs:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Either list of fields or keywords&quot;</span>
                            <span class="s3">&quot; can be provided to NamedTuple, not both&quot;</span><span class="s1">)</span>
        <span class="s1">nt = _make_nmtuple(__typename</span><span class="s0">, </span><span class="s1">__fields</span><span class="s0">, </span><span class="s1">module=_caller())</span>
        <span class="s1">nt.__orig_bases__ = (NamedTuple</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">nt</span>

    <span class="s1">NamedTuple.__doc__ = typing.NamedTuple.__doc__</span>
    <span class="s1">_NamedTuple = type.__new__(_NamedTupleMeta</span><span class="s0">, </span><span class="s3">'NamedTuple'</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">{})</span>

    <span class="s2"># On 3.8+, alter the signature so that it matches typing.NamedTuple.</span>
    <span class="s2"># The signature of typing.NamedTuple on &gt;=3.8 is invalid syntax in Python 3.7,</span>
    <span class="s2"># so just leave the signature as it is on 3.7.</span>
    <span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">8</span><span class="s1">):</span>
        <span class="s1">NamedTuple.__text_signature__ = </span><span class="s3">'(typename, fields=None, /, **kwargs)'</span>

    <span class="s0">def </span><span class="s1">_namedtuple_mro_entries(bases):</span>
        <span class="s0">assert </span><span class="s1">NamedTuple </span><span class="s0">in </span><span class="s1">bases</span>
        <span class="s0">return </span><span class="s1">(_NamedTuple</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">NamedTuple.__mro_entries__ = _namedtuple_mro_entries</span>


<span class="s0">if </span><span class="s1">hasattr(collections.abc</span><span class="s0">, </span><span class="s3">&quot;Buffer&quot;</span><span class="s1">):</span>
    <span class="s1">Buffer = collections.abc.Buffer</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">Buffer(abc.ABC):</span>
        <span class="s4">&quot;&quot;&quot;Base class for classes that implement the buffer protocol. 
 
        The buffer protocol allows Python objects to expose a low-level 
        memory buffer interface. Before Python 3.12, it is not possible 
        to implement the buffer protocol in pure Python code, or even 
        to check whether a class implements the buffer protocol. In 
        Python 3.12 and higher, the ``__buffer__`` method allows access 
        to the buffer protocol from Python code, and the 
        ``collections.abc.Buffer`` ABC allows checking whether a class 
        implements the buffer protocol. 
 
        To indicate support for the buffer protocol in earlier versions, 
        inherit from this ABC, either in a stub file or at runtime, 
        or use ABC registration. This ABC provides no methods, because 
        there is no Python-accessible methods shared by pre-3.12 buffer 
        classes. It is useful primarily for static checks. 
 
        &quot;&quot;&quot;</span>

    <span class="s2"># As a courtesy, register the most common stdlib buffer classes.</span>
    <span class="s1">Buffer.register(memoryview)</span>
    <span class="s1">Buffer.register(bytearray)</span>
    <span class="s1">Buffer.register(bytes)</span>


<span class="s2"># Backport of types.get_original_bases, available on 3.12+ in CPython</span>
<span class="s0">if </span><span class="s1">hasattr(_types</span><span class="s0">, </span><span class="s3">&quot;get_original_bases&quot;</span><span class="s1">):</span>
    <span class="s1">get_original_bases = _types.get_original_bases</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">get_original_bases(__cls):</span>
        <span class="s4">&quot;&quot;&quot;Return the class's &quot;original&quot; bases prior to modification by `__mro_entries__`. 
 
        Examples:: 
 
            from typing import TypeVar, Generic 
            from typing_extensions import NamedTuple, TypedDict 
 
            T = TypeVar(&quot;T&quot;) 
            class Foo(Generic[T]): ... 
            class Bar(Foo[int], float): ... 
            class Baz(list[str]): ... 
            Eggs = NamedTuple(&quot;Eggs&quot;, [(&quot;a&quot;, int), (&quot;b&quot;, str)]) 
            Spam = TypedDict(&quot;Spam&quot;, {&quot;a&quot;: int, &quot;b&quot;: str}) 
 
            assert get_original_bases(Bar) == (Foo[int], float) 
            assert get_original_bases(Baz) == (list[str],) 
            assert get_original_bases(Eggs) == (NamedTuple,) 
            assert get_original_bases(Spam) == (TypedDict,) 
            assert get_original_bases(int) == (object,) 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">__cls.__orig_bases__</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">__cls.__bases__</span>
            <span class="s0">except </span><span class="s1">AttributeError:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">f'Expected an instance of type, not </span><span class="s0">{</span><span class="s1">type(__cls).__name__</span><span class="s0">!r}</span><span class="s3">'</span>
                <span class="s1">) </span><span class="s0">from None</span>


<span class="s2"># NewType is a class on Python 3.10+, making it pickleable</span>
<span class="s2"># The error message for subclassing instances of NewType was improved on 3.11+</span>
<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">11</span><span class="s1">):</span>
    <span class="s1">NewType = typing.NewType</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">NewType:</span>
        <span class="s4">&quot;&quot;&quot;NewType creates simple unique types with almost zero 
        runtime overhead. NewType(name, tp) is considered a subtype of tp 
        by static type checkers. At runtime, NewType(name, tp) returns 
        a dummy callable that simply returns its argument. Usage:: 
            UserId = NewType('UserId', int) 
            def name_by_id(user_id: UserId) -&gt; str: 
                ... 
            UserId('user')          # Fails type check 
            name_by_id(42)          # Fails type check 
            name_by_id(UserId(42))  # OK 
            num = UserId(5) + 1     # type: int 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">obj):</span>
            <span class="s0">return </span><span class="s1">obj</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">tp):</span>
            <span class="s1">self.__qualname__ = name</span>
            <span class="s0">if </span><span class="s3">'.' </span><span class="s0">in </span><span class="s1">name:</span>
                <span class="s1">name = name.rpartition(</span><span class="s3">'.'</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">self.__name__ = name</span>
            <span class="s1">self.__supertype__ = tp</span>
            <span class="s1">def_mod = _caller()</span>
            <span class="s0">if </span><span class="s1">def_mod != </span><span class="s3">'typing_extensions'</span><span class="s1">:</span>
                <span class="s1">self.__module__ = def_mod</span>

        <span class="s0">def </span><span class="s1">__mro_entries__(self</span><span class="s0">, </span><span class="s1">bases):</span>
            <span class="s2"># We defined __mro_entries__ to get a better error message</span>
            <span class="s2"># if a user attempts to subclass a NewType instance. bpo-46170</span>
            <span class="s1">supercls_name = self.__name__</span>

            <span class="s0">class </span><span class="s1">Dummy:</span>
                <span class="s0">def </span><span class="s1">__init_subclass__(cls):</span>
                    <span class="s1">subcls_name = cls.__name__</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s3">f&quot;Cannot subclass an instance of NewType. &quot;</span>
                        <span class="s3">f&quot;Perhaps you were looking for: &quot;</span>
                        <span class="s3">f&quot;`</span><span class="s0">{</span><span class="s1">subcls_name</span><span class="s0">} </span><span class="s3">= NewType(</span><span class="s0">{</span><span class="s1">subcls_name</span><span class="s0">!r}</span><span class="s3">, </span><span class="s0">{</span><span class="s1">supercls_name</span><span class="s0">}</span><span class="s3">)`&quot;</span>
                    <span class="s1">)</span>

            <span class="s0">return </span><span class="s1">(Dummy</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self.__module__</span><span class="s0">}</span><span class="s3">.</span><span class="s0">{</span><span class="s1">self.__qualname__</span><span class="s0">}</span><span class="s3">'</span>

        <span class="s0">def </span><span class="s1">__reduce__(self):</span>
            <span class="s0">return </span><span class="s1">self.__qualname__</span>

        <span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">10</span><span class="s1">):</span>
            <span class="s2"># PEP 604 methods</span>
            <span class="s2"># It doesn't make sense to have these methods on Python &lt;3.10</span>

            <span class="s0">def </span><span class="s1">__or__(self</span><span class="s0">, </span><span class="s1">other):</span>
                <span class="s0">return </span><span class="s1">typing.Union[self</span><span class="s0">, </span><span class="s1">other]</span>

            <span class="s0">def </span><span class="s1">__ror__(self</span><span class="s0">, </span><span class="s1">other):</span>
                <span class="s0">return </span><span class="s1">typing.Union[other</span><span class="s0">, </span><span class="s1">self]</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;TypeAliasType&quot;</span><span class="s1">):</span>
    <span class="s1">TypeAliasType = typing.TypeAliasType</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">_is_unionable(obj):</span>
        <span class="s4">&quot;&quot;&quot;Corresponds to is_unionable() in unionobject.c in CPython.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">obj </span><span class="s0">is None or </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">(</span>
            <span class="s1">type</span><span class="s0">,</span>
            <span class="s1">_types.GenericAlias</span><span class="s0">,</span>
            <span class="s1">_types.UnionType</span><span class="s0">,</span>
            <span class="s1">TypeAliasType</span><span class="s0">,</span>
        <span class="s1">))</span>

    <span class="s0">class </span><span class="s1">TypeAliasType:</span>
        <span class="s4">&quot;&quot;&quot;Create named, parameterized type aliases. 
 
        This provides a backport of the new `type` statement in Python 3.12: 
 
            type ListOrSet[T] = list[T] | set[T] 
 
        is equivalent to: 
 
            T = TypeVar(&quot;T&quot;) 
            ListOrSet = TypeAliasType(&quot;ListOrSet&quot;, list[T] | set[T], type_params=(T,)) 
 
        The name ListOrSet can then be used as an alias for the type it refers to. 
 
        The type_params argument should contain all the type parameters used 
        in the value of the type alias. If the alias is not generic, this 
        argument is omitted. 
 
        Static type checkers should only support type aliases declared using 
        TypeAliasType that follow these rules: 
 
        - The first argument (the name) must be a string literal. 
        - The TypeAliasType instance must be immediately assigned to a variable 
          of the same name. (For example, 'X = TypeAliasType(&quot;Y&quot;, int)' is invalid, 
          as is 'X, Y = TypeAliasType(&quot;X&quot;, int), TypeAliasType(&quot;Y&quot;, int)'). 
 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name: str</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">type_params=()):</span>
            <span class="s0">if not </span><span class="s1">isinstance(name</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;TypeAliasType name must be a string&quot;</span><span class="s1">)</span>
            <span class="s1">self.__value__ = value</span>
            <span class="s1">self.__type_params__ = type_params</span>

            <span class="s1">parameters = []</span>
            <span class="s0">for </span><span class="s1">type_param </span><span class="s0">in </span><span class="s1">type_params:</span>
                <span class="s0">if </span><span class="s1">isinstance(type_param</span><span class="s0">, </span><span class="s1">TypeVarTuple):</span>
                    <span class="s1">parameters.extend(type_param)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">parameters.append(type_param)</span>
            <span class="s1">self.__parameters__ = tuple(parameters)</span>
            <span class="s1">def_mod = _caller()</span>
            <span class="s0">if </span><span class="s1">def_mod != </span><span class="s3">'typing_extensions'</span><span class="s1">:</span>
                <span class="s1">self.__module__ = def_mod</span>
            <span class="s2"># Setting this attribute closes the TypeAliasType from further modification</span>
            <span class="s1">self.__name__ = name</span>

        <span class="s0">def </span><span class="s1">__setattr__(self</span><span class="s0">, </span><span class="s1">__name: str</span><span class="s0">, </span><span class="s1">__value: object) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s3">&quot;__name__&quot;</span><span class="s1">):</span>
                <span class="s1">self._raise_attribute_error(__name)</span>
            <span class="s1">super().__setattr__(__name</span><span class="s0">, </span><span class="s1">__value)</span>

        <span class="s0">def </span><span class="s1">__delattr__(self</span><span class="s0">, </span><span class="s1">__name: str) -&gt; Never:</span>
            <span class="s1">self._raise_attribute_error(__name)</span>

        <span class="s0">def </span><span class="s1">_raise_attribute_error(self</span><span class="s0">, </span><span class="s1">name: str) -&gt; Never:</span>
            <span class="s2"># Match the Python 3.12 error messages exactly</span>
            <span class="s0">if </span><span class="s1">name == </span><span class="s3">&quot;__name__&quot;</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;readonly attribute&quot;</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">name </span><span class="s0">in </span><span class="s1">{</span><span class="s3">&quot;__value__&quot;</span><span class="s0">, </span><span class="s3">&quot;__type_params__&quot;</span><span class="s0">, </span><span class="s3">&quot;__parameters__&quot;</span><span class="s0">, </span><span class="s3">&quot;__module__&quot;</span><span class="s1">}:</span>
                <span class="s0">raise </span><span class="s1">AttributeError(</span>
                    <span class="s3">f&quot;attribute '</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s3">' of 'typing.TypeAliasType' objects &quot;</span>
                    <span class="s3">&quot;is not writable&quot;</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">AttributeError(</span>
                    <span class="s3">f&quot;'typing.TypeAliasType' object has no attribute '</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s3">'&quot;</span>
                <span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
            <span class="s0">return </span><span class="s1">self.__name__</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s0">if not </span><span class="s1">isinstance(parameters</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">parameters = (parameters</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">parameters = [</span>
                <span class="s1">typing._type_check(</span>
                    <span class="s1">item</span><span class="s0">, </span><span class="s3">f'Subscripting </span><span class="s0">{</span><span class="s1">self.__name__</span><span class="s0">} </span><span class="s3">requires a type.'</span>
                <span class="s1">)</span>
                <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">parameters</span>
            <span class="s1">]</span>
            <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">tuple(parameters))</span>

        <span class="s0">def </span><span class="s1">__reduce__(self):</span>
            <span class="s0">return </span><span class="s1">self.__name__</span>

        <span class="s0">def </span><span class="s1">__init_subclass__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s3">&quot;type 'typing_extensions.TypeAliasType' is not an acceptable base type&quot;</span>
            <span class="s1">)</span>

        <span class="s2"># The presence of this method convinces typing._type_check</span>
        <span class="s2"># that TypeAliasTypes are types.</span>
        <span class="s0">def </span><span class="s1">__call__(self):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Type alias is not callable&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">10</span><span class="s1">):</span>
            <span class="s0">def </span><span class="s1">__or__(self</span><span class="s0">, </span><span class="s1">right):</span>
                <span class="s2"># For forward compatibility with 3.12, reject Unions</span>
                <span class="s2"># that are not accepted by the built-in Union.</span>
                <span class="s0">if not </span><span class="s1">_is_unionable(right):</span>
                    <span class="s0">return </span><span class="s1">NotImplemented</span>
                <span class="s0">return </span><span class="s1">typing.Union[self</span><span class="s0">, </span><span class="s1">right]</span>

            <span class="s0">def </span><span class="s1">__ror__(self</span><span class="s0">, </span><span class="s1">left):</span>
                <span class="s0">if not </span><span class="s1">_is_unionable(left):</span>
                    <span class="s0">return </span><span class="s1">NotImplemented</span>
                <span class="s0">return </span><span class="s1">typing.Union[left</span><span class="s0">, </span><span class="s1">self]</span>
</pre>
</body>
</html>